C:/Users/corte/VS Code Projects/billing_inventory_system_new/README.md:
# El Rincón de Ébano - Inventory and Billing System

An inventory and billing management system designed specifically for Chilean minimarket operations.

## Overview

This system manages:

- Product inventory with barcode support
- Customer management with department associations
- Sales and purchase tracking
- Basic analytics and reporting

## Key Features

- Barcode scanning support
- Weight-based product sales support
- Customer department tracking
- Chilean Peso (CLP) monetary operations
- Weekly automated backups
- Simple and efficient UI designed for retail operations

## Technical Details

For complete technical specifications, business rules, and implementation details, please see [SPECIFICATIONS.md](SPECIFICATIONS.md).

## Dependencies

See `requirements.txt` for Python package dependencies.

## Setup

1. Install required packages: `pip install -r requirements.txt`
2. Initialize the database: System will auto-initialize on first run
3. Configure backup location in app_config.json

## License

[License information goes here]



C:/Users/corte/VS Code Projects/billing_inventory_system_new/SPECIFICATIONS.md:
# El Rincón de Ébano - System Specifications

## Core Business Rules

### Currency and Monetary Operations

- Currency: Chilean Peso (CLP) only
- All prices must be integers (no decimals)
- Maximum price: 1.000.000 CLP (cost_price and sell_price)
- Display format: Use dots as thousand separators (e.g., 1.000.000)
- Calculations: Round each operation individually

### Product Quantities

- Standard products: Integer quantities
- Weight-based products:
  - Unit: Kilograms only
  - Precision: 3 decimal places
  - Minimum: 0.001 kg
  - Display: Show up to 3 decimal places

### Customer Management

#### Cell Phone Numbers (9-digit Identifier)

- Must start with digit '9'
- Exactly 9 digits long
- Examples: 912345678, 987654321
- Must be unique per customer
- One customer can only have one department

#### Department Numbers (3/4-digit Identifier)

- Length: 3 or 4 digits
- Must not start with 0
- Can be associated with multiple customers
- Associations can be updated anytime
- No historical tracking needed except in sales records

### Operations Volume

#### Sales

- Daily average: 10 sales
- Items per sale: 2-3 items
- Deletion: Allowed anytime
- No time restrictions on modifications

#### Purchases

- Weekly average: 3 purchases
- Items per purchase: ~20 items
- No historical price tracking needed

### Barcode Operations

- Successful scans: Play sound
- Failed scans: Show message only
- Auto-clear input after successful scan
- Optimized for rapid minimarket operations

### Data Backup

- Frequency: Weekly
- Retention: Last 2 weeks only
- Scope: All historical data
- Timing: No specific schedule required

## Technical Implementation

### Database Requirements

- SQLite with WAL mode
- Enforce foreign key constraints
- Decimal storage: String format, 3 decimal places
- Price storage: Integer values

### User Interface

- Monetary display: Dot separators everywhere
- Supported themes: default, dark, light only
- Sound effects: Barcode scans only
- Language: English only

### Data Validation Rules

#### Customer Names

- Allowed: Letters, Spanish accents, spaces
- Pattern: ^[A-Za-zÁÉÍÓÚÑáéíóúñ ]+$
- Maximum length: 50 characters

#### Cell Phone Numbers

- Must start with 9
- Exactly 9 digits
- Must be unique

#### Department Numbers

- 3 or 4 digits
- Cannot start with 0
- Can have multiple associated customers

### Performance Specifications

- Annual volume: ~5,000 sales, ~156 purchases
- No strict performance requirements
- Optimize common searches:
  - Customer lookups
  - Barcode scans
  - Product searches
  - Sales history

### Security Specifications

- No user roles required
- Basic input sanitization only
- No special security requirements

### System Requirements

- Self-contained system
- No external integrations
- No multi-currency support
- Single language (English) UI

### Future Compatibility Notes

- Designed for CLP only
- No multi-currency expansion planned
- No additional theme support planned
- No multi-language support planned
  


C:/Users/corte/VS Code Projects/billing_inventory_system_new/config.py:
import logging
import os
import re
import json
import time
from enum import IntEnum
from pathlib import Path
from typing import Dict, Any, Optional, Union
from json.decoder import JSONDecodeError
import threading

# Custom exceptions
class ConfigError(Exception):
    """Base exception for configuration errors."""
    pass

class ConfigLoadError(ConfigError):
    """Error loading configuration file."""
    pass

class ConfigValidationError(ConfigError):
    """Error validating configuration."""
    pass

# Application settings
APP_NAME: str = "Inventory and Billing System"
APP_VERSION: str = "2.0"
COMPANY_NAME: str = "El Rincón de Ébano"
CONFIG_VERSION: str = "1.0"

# Database configuration
def get_safe_db_path(db_name: str) -> Path:
    """
    Safely construct database path preventing directory traversal.
    
    Args:
        db_name: The name of the database file
        
    Returns:
        Path: Safe path to database file
    """
    sanitized_name = re.sub(r'[^a-zA-Z0-9_.-]', '', db_name)
    return Path(__file__).parent / sanitized_name

DATABASE_NAME = os.environ.get("DATABASE_NAME", "billing_inventory.db")
DATABASE_PATH = get_safe_db_path(DATABASE_NAME)

# Debug Level configuration
class DebugLevel(IntEnum):
    """Enum representing different debug levels for the application."""
    CRITICAL = 1
    ERROR = 2
    WARNING = 3
    INFO = 4
    DEBUG = 5

DEBUG_LEVEL_MAP: Dict[DebugLevel, int] = {
    DebugLevel.CRITICAL: logging.CRITICAL,
    DebugLevel.ERROR: logging.ERROR,
    DebugLevel.WARNING: logging.WARNING,
    DebugLevel.INFO: logging.INFO,
    DebugLevel.DEBUG: logging.DEBUG,
}

# Set the desired debug level
DEBUG_LEVEL = logging.INFO  # This should control the global level

class Config:
    """Thread-safe singleton class for managing application configuration."""

    _instance: Optional['Config'] = None
    _config: Optional[Dict[str, Any]] = None
    _lock = threading.Lock()
    _cache_ttl: int = 300  # 5 minutes
    _last_load_time: float = 0
    _config_file: Optional[Path] = None

    def __new__(cls) -> 'Config':
        """Ensure singleton instance."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(Config, cls).__new__(cls)
        return cls._instance

    @classmethod
    def _is_cache_valid(cls) -> bool:
        """Check if cached configuration is still valid."""
        return cls._config is not None and time.time() - cls._last_load_time < cls._cache_ttl

    @classmethod
    def _load_config(cls) -> None:
        """Load configuration from file or create default if not exists."""
        if not cls._is_cache_valid():
            with cls._lock:
                if not cls._is_cache_valid():
                    config_file = Path(__file__).parent / 'app_config.json'
                    if config_file.exists():
                        try:
                            with open(config_file, 'r') as f:
                                loaded_config = json.load(f)
                            cls._validate_config(loaded_config)
                            cls._config = loaded_config
                            cls._last_load_time = time.time()
                        except (IOError, JSONDecodeError) as e:
                            logging.error(f"Error loading configuration: {e}")
                            raise ConfigLoadError(f"Failed to load config: {e}")
                        except (ValueError, TypeError) as e:
                            logging.error(f"Invalid configuration: {e}")
                            raise ConfigValidationError(f"Invalid config: {e}")
                    else:
                        cls._config = cls._get_default_config()
                        cls._save_config()
                        cls._last_load_time = time.time()

    @classmethod
    def _get_default_config(cls) -> Dict[str, Union[str, int]]:
        """Return the default configuration."""
        return {
            "version": CONFIG_VERSION,
            "theme": "default",
            "language": "en",
            "backup_interval": 24,
        }

    @classmethod
    def _save_config(cls) -> None:
        """Save current configuration to file."""
        if cls._config is None:
            cls._config = cls._get_default_config()
        
        config_file = Path(__file__).parent / 'app_config.json'
        try:
            with open(config_file, 'w') as f:
                json.dump(cls._config, f, indent=4)
        except IOError as e:
            logging.error(f"Error saving configuration: {e}")
            raise ConfigLoadError(f"Failed to save config: {e}")

    @classmethod
    def _validate_config(cls, config: Dict[str, Any]) -> None:
        """
        Validate the configuration structure and types.
        
        Args:
            config: Configuration dictionary to validate
            
        Raises:
            ConfigValidationError: If validation fails
        """
        required_keys = {
            "version": (str, [CONFIG_VERSION]),
            "theme": (str, ["default", "dark", "light"]),
            "language": (str, ["en", "es"]), 
            "backup_interval": (int, (1, 168))  # 1 hour to 1 week
        }
        
        for key, (expected_type, valid_values) in required_keys.items():
            if key not in config:
                raise ConfigValidationError(f"Missing required key: {key}")
                
            value = config[key]
            if not isinstance(value, expected_type):
                raise ConfigValidationError(
                    f"Invalid type for {key}. Expected {expected_type}, got {type(value)}"
                )
                
            if isinstance(valid_values, (list, tuple)):
                if value not in valid_values and not (
                    isinstance(valid_values, tuple) and 
                    valid_values[0] <= value <= valid_values[1]
                ):
                    raise ConfigValidationError(
                        f"Invalid value for {key}. Must be one of {valid_values}"
                    )

    @classmethod
    def get(cls, key: str, default: Any = None) -> Any:
        """
        Get a configuration value.

        Args:
            key: The configuration key
            default: Default value if key is not found

        Returns:
            The configuration value or default
        """
        cls._load_config()
        with cls._lock:
            return cls._config.get(key, default) if cls._config is not None else default

    @classmethod
    def set(cls, key: str, value: Any) -> None:
        """
        Set a configuration value.

        Args:
            key: The configuration key
            value: The value to set
        """
        cls._load_config()
        with cls._lock:
            if cls._config is None:
                cls._config = cls._get_default_config()
            cls._config[key] = value
            cls._save_config()

    @classmethod
    def reload(cls) -> None:
        """Force reload of the configuration from file."""
        with cls._lock:
            cls._config = None
            cls._last_load_time = 0
        cls._load_config()

    @classmethod
    def _reset_for_testing(cls, config_file=None):
        """Reset singleton state for testing."""
        cls._instance = None
        cls._config = None
        cls._config_file = config_file

# Global instance of Config
config = Config()


C:/Users/corte/VS Code Projects/billing_inventory_system_new/login_config.yaml:
version: 1
disable_existing_loggers: false

formatters:
    standard:
        format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    error:
        format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

handlers:
    console:
        class: logging.StreamHandler
        level: DEBUG
        formatter: standard
        stream: ext://sys.stdout

    file_handler:
        class: logging.handlers.RotatingFileHandler
        level: DEBUG
        formatter: standard
        filename: inventory_system.log
        maxBytes: 10485760 # 10MB
        backupCount: 5
        encoding: utf8

    error_file_handler:
        class: logging.handlers.RotatingFileHandler
        level: ERROR
        formatter: error
        filename: inventory_system_error.log
        maxBytes: 10485760 # 10MB
        backupCount: 5
        encoding: utf8

root:
    level: DEBUG
    handlers: [console, file_handler, error_file_handler]

loggers:
    inventory_system:
        level: DEBUG
        handlers: [console, file_handler, error_file_handler]
        propagate: no


C:/Users/corte/VS Code Projects/billing_inventory_system_new/main.py:
import sys
from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow
from database import init_db
from utils.system.logger import logger
from utils.exceptions import DatabaseException, AppException
from utils.decorators import handle_exceptions
from config import config, APP_NAME, APP_VERSION
from utils.validation.data_validator import DataValidationService


class Application:
    @staticmethod
    @handle_exceptions(AppException, show_dialog=True)
    def initialize():
        logger.info("Initializing the application")
        try:
            init_db()
            DataValidationService.validate_all_data()
            logger.info("Database initialized and validated successfully")
        except DatabaseException as e:
            logger.critical(f"Failed to initialize database: {e}")
            raise AppException(f"Failed to initialize database: {e}")

    @staticmethod
    @handle_exceptions(AppException, show_dialog=True)
    def run():
        app = QApplication(sys.argv)
        app.setApplicationName(APP_NAME)
        app.setApplicationVersion(APP_VERSION)

        Application.apply_theme(app)

        window = MainWindow()
        window.show()
        logger.debug("Application started")
        sys.exit(app.exec())

    @staticmethod
    def apply_theme(app: QApplication):
        theme = config.get('theme', 'default')
        if theme != 'default':
            app.setStyle(theme)
        logger.debug(f"Applied theme: {theme}")

    @staticmethod
    def shutdown():
        logger.info("Application shutting down")
        # Perform any necessary cleanup here
        # For example, close database connections, save application state, etc.

if __name__ == "__main__":
    try:
        Application.initialize()
        Application.run()
    except AppException as e:
        logger.critical(f"An unhandled error occurred: {e}")
        sys.exit(1)
    finally:
        Application.shutdown()



C:/Users/corte/VS Code Projects/billing_inventory_system_new/readme.md:
# El Rincón de Ébano - Inventory and Billing System

An inventory and billing management system designed specifically for Chilean minimarket operations.

## Overview

This system manages:

- Product inventory with barcode support
- Customer management with department associations
- Sales and purchase tracking
- Basic analytics and reporting

## Key Features

- Barcode scanning support
- Weight-based product sales support
- Customer department tracking
- Chilean Peso (CLP) monetary operations
- Weekly automated backups
- Simple and efficient UI designed for retail operations

## Technical Details

For complete technical specifications, business rules, and implementation details, please see [SPECIFICATIONS.md](SPECIFICATIONS.md).

## Dependencies

See `requirements.txt` for Python package dependencies.

## Setup

1. Install required packages: `pip install -r requirements.txt`
2. Initialize the database: System will auto-initialize on first run
3. Configure backup location in app_config.json

## License

[License information goes here]



C:/Users/corte/VS Code Projects/billing_inventory_system_new/specifications.md:
# El Rincón de Ébano - System Specifications

## Core Business Rules

### Currency and Monetary Operations

- Currency: Chilean Peso (CLP) only
- All prices must be integers (no decimals)
- Maximum price: 1.000.000 CLP (cost_price and sell_price)
- Display format: Use dots as thousand separators (e.g., 1.000.000)
- Calculations: Round each operation individually

### Product Quantities

- Standard products: Integer quantities
- Weight-based products:
  - Unit: Kilograms only
  - Precision: 3 decimal places
  - Minimum: 0.001 kg
  - Display: Show up to 3 decimal places

### Customer Management

#### Cell Phone Numbers (9-digit Identifier)

- Must start with digit '9'
- Exactly 9 digits long
- Examples: 912345678, 987654321
- Must be unique per customer
- One customer can only have one department

#### Department Numbers (3/4-digit Identifier)

- Length: 3 or 4 digits
- Must not start with 0
- Can be associated with multiple customers
- Associations can be updated anytime
- No historical tracking needed except in sales records

### Operations Volume

#### Sales

- Daily average: 10 sales
- Items per sale: 2-3 items
- Deletion: Allowed anytime
- No time restrictions on modifications

#### Purchases

- Weekly average: 3 purchases
- Items per purchase: ~20 items
- No historical price tracking needed

### Barcode Operations

- Successful scans: Play sound
- Failed scans: Show message only
- Auto-clear input after successful scan
- Optimized for rapid minimarket operations

### Data Backup

- Frequency: Weekly
- Retention: Last 2 weeks only
- Scope: All historical data
- Timing: No specific schedule required

## Technical Implementation

### Database Requirements

- SQLite with WAL mode
- Enforce foreign key constraints
- Decimal storage: String format, 3 decimal places
- Price storage: Integer values

### User Interface

- Monetary display: Dot separators everywhere
- Supported themes: default, dark, light only
- Sound effects: Barcode scans only
- Language: English only

### Data Validation Rules

#### Customer Names

- Allowed: Letters, Spanish accents, spaces
- Pattern: ^[A-Za-zÁÉÍÓÚÑáéíóúñ ]+$
- Maximum length: 50 characters

#### Cell Phone Numbers

- Must start with 9
- Exactly 9 digits
- Must be unique

#### Department Numbers

- 3 or 4 digits
- Cannot start with 0
- Can have multiple associated customers

### Performance Specifications

- Annual volume: ~5,000 sales, ~156 purchases
- No strict performance requirements
- Optimize common searches:
  - Customer lookups
  - Barcode scans
  - Product searches
  - Sales history

### Security Specifications

- No user roles required
- Basic input sanitization only
- No special security requirements

### System Requirements

- Self-contained system
- No external integrations
- No multi-currency support
- Single language (English) UI

### Future Compatibility Notes

- Designed for CLP only
- No multi-currency expansion planned
- No additional theme support planned
- No multi-language support planned
  


C:/Users/corte/VS Code Projects/billing_inventory_system_new/database/database_manager.py:
import sqlite3
from contextlib import contextmanager
from utils.exceptions import DatabaseException
from typing import Union, Dict, Any, List, Tuple

class DatabaseManager:
    _connection = None

    @classmethod
    def initialize(cls, db_path: str = "billing_inventory.db"):
        """Initialize database connection"""
        cls._connection = sqlite3.connect(db_path)
        cls._connection.row_factory = sqlite3.Row

    @classmethod
    def _get_cursor(cls):
        if cls._connection is None:
            cls.initialize()
        if cls._connection is None:  # If still None after initialization
            raise DatabaseException("Could not establish database connection")
        return cls._connection.cursor()

    @classmethod
    @contextmanager
    def transaction(cls):
        """Context manager for database transactions"""
        if cls._connection is None:
            cls.initialize()
        if cls._connection is None:
            raise DatabaseException("No active database connection")
        try:
            yield
            cls._connection.commit()
        except Exception as e:
            cls._connection.rollback()
            raise DatabaseException(f"Transaction failed: {str(e)}")

    @classmethod
    def fetch_one(cls, query: str, params: Union[tuple, Dict[str, Any]] = ()):
        cursor = cls._get_cursor()
        cursor.execute(query, params)
        row = cursor.fetchone()
        return dict(row) if row else None

    @classmethod
    def fetch_all(cls, query: str, params: Union[tuple, Dict[str, Any]] = ()):
        cursor = cls._get_cursor()
        cursor.execute(query, params)
        return [dict(row) for row in cursor.fetchall()]

    @classmethod
    def execute_query(cls, query: str, params: Union[tuple, Dict[str, Any]] = ()) -> sqlite3.Cursor:
        """Execute a query and return the cursor."""
        if cls._connection is None:
            cls.initialize()
        if cls._connection is None:
            raise DatabaseException("No active database connection")
        cursor = cls._get_cursor()
        cursor.execute(query, params)
        cls._connection.commit()
        return cursor 

    @classmethod
    def begin_transaction(cls):
        """Begin a database transaction."""
        cls._get_cursor().execute("BEGIN TRANSACTION")

    @classmethod
    def commit_transaction(cls):
        """Commit the current transaction."""
        if cls._connection is None:
            raise DatabaseException("No active database connection")
        cls._connection.commit()

    @classmethod
    def rollback_transaction(cls):
        """Rollback the current transaction."""
        if cls._connection is None:
            raise DatabaseException("No active database connection")
        cls._connection.rollback() 

    @classmethod
    @contextmanager
    def get_db_connection(cls):
        """Get a database connection context manager."""
        if cls._connection is None:
            cls.initialize()
        if cls._connection is None:
            raise DatabaseException("No active database connection")
        try:
            yield cls._connection
        except Exception as e:
            raise DatabaseException(f"Database connection error: {str(e)}")

    @classmethod
    def executemany(cls, query: str, params: List[Tuple]) -> sqlite3.Cursor:
        """Execute a query with multiple parameter sets."""
        cursor = cls._get_cursor()
        cursor.executemany(query, params)
        return cursor



C:/Users/corte/VS Code Projects/billing_inventory_system_new/database/__init__.py:
from utils.exceptions import DatabaseException
from database.database_manager import DatabaseManager

__all__ = ['init_db', 'DatabaseManager']

def init_db(db_path: str = "billing_inventory.db"):
    """Initialize the database connection and create tables."""
    try:
        DatabaseManager.initialize(db_path)
        
        # First, backup existing data
        backup_query = """
        CREATE TEMPORARY TABLE customers_backup AS 
        SELECT id, identifier_9, name 
        FROM customers;
        """
        
        # Drop old table
        drop_query = "DROP TABLE IF EXISTS customers;"
        
        # Create new table without REGEXP
        create_query = """
        CREATE TABLE customers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            identifier_9 TEXT NOT NULL UNIQUE COLLATE NOCASE,
            name TEXT,
            CHECK (LENGTH(identifier_9) = 9),
            CHECK (identifier_9 GLOB '[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'),
            CHECK (name IS NULL OR LENGTH(name) <= 50)
        );
        """
        
        # Restore data
        restore_query = """
        INSERT INTO customers (id, identifier_9, name)
        SELECT id, identifier_9, name FROM customers_backup;
        """
        
        with DatabaseManager.transaction():
            cursor = DatabaseManager._get_cursor()
            cursor.executescript(backup_query)
            cursor.executescript(drop_query)
            cursor.executescript(create_query)
            cursor.executescript(restore_query)
            
    except Exception as e:
        raise DatabaseException(f"Failed to initialize database: {str(e)}")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/category.py:
from dataclasses import dataclass, field, replace
from typing import Dict, Any, ClassVar
from datetime import datetime
from utils.exceptions import ValidationException
from utils.system.logger import logger
import re

@dataclass(frozen=True)
class Category:
    """
    Represents a product category in the system.
    
    Attributes:
        id (int): Unique identifier for the category
        name (str): Name of the category
        created_at (datetime): Timestamp when category was created
        updated_at (datetime): Timestamp when category was last updated
    """
    id: int
    name: str
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    # Class constants
    NAME_MAX_LENGTH: ClassVar[int] = 50
    NAME_MIN_LENGTH: ClassVar[int] = 1
    NAME_PATTERN: ClassVar[str] = r'^[\w\s\-]+$'

    def __post_init__(self) -> None:
        """Validate category data after initialization."""
        self.validate_name(self.name)
        if not isinstance(self.id, int):
            logger.error("Invalid category ID type", extra={"id": self.id, "type": type(self.id)})
            raise ValidationException("Category ID must be an integer")
        if self.id < 0:
            logger.error("Negative category ID", extra={"id": self.id})
            raise ValidationException("Category ID cannot be negative")

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "Category":
        """
        Create a Category instance from a database row.

        Args:
            row: Dictionary containing category data from database

        Returns:
            Category: New Category instance

        Raises:
            ValidationException: If required fields are missing or invalid
        """
        try:
            return cls(
                id=int(row["id"]),
                name=str(row["name"]),
                created_at=datetime.fromisoformat(row["created_at"]) if "created_at" in row else datetime.now(),
                updated_at=datetime.fromisoformat(row["updated_at"]) if "updated_at" in row else datetime.now()
            )
        except (KeyError, ValueError, TypeError) as e:
            logger.error("Failed to create category from DB row", extra={
                "error": str(e),
                "row": row
            })
            raise ValidationException(f"Invalid category data: {str(e)}")

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert category to dictionary representation.

        Returns:
            Dict[str, Any]: Dictionary containing category data
        """
        return {
            "id": self.id,
            "name": self.name,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    @staticmethod
    def validate_name(name: str) -> str:
        """
        Validate and normalize category name.
        
        Args:
            name: Category name to validate
            
        Returns:
            str: Normalized category name
            
        Raises:
            ValidationException: If name is invalid
        """
        if not name:
            logger.warning("Empty category name provided")
            raise ValidationException("Category name cannot be empty")
            
        # Normalize whitespace first
        normalized_name = " ".join(name.split())
        
        if len(normalized_name) < Category.NAME_MIN_LENGTH:
            raise ValidationException("Category name cannot be empty")
            
        if len(normalized_name) > Category.NAME_MAX_LENGTH:
            logger.warning("Category name exceeds maximum length", extra={
                "name": normalized_name,
                "length": len(normalized_name),
                "max_length": Category.NAME_MAX_LENGTH
            })
            raise ValidationException(
                f"Category name cannot exceed {Category.NAME_MAX_LENGTH} characters"
            )
            
        if not re.match(Category.NAME_PATTERN, normalized_name):
            logger.warning("Invalid category name format", extra={"name": normalized_name})
            raise ValidationException(
                "Category name can only contain letters, numbers, spaces, and hyphens"
            )
            
        return normalized_name

    def clone(self, **changes: Any) -> "Category":
        """
        Create a copy of this category with optional changes.

        Args:
            **changes: Attribute changes to apply to the clone

        Returns:
            Category: New Category instance with changes applied
        """
        return replace(self, **changes)

    def update(self, name: str) -> "Category":
        """
        Create new category instance with updated name.

        Args:
            name: New category name

        Returns:
            Category: New Category instance with updated name
            
        Raises:
            ValidationException: If name is invalid
        """
        self.validate_name(name)
        return self.clone(
            name=name,
            updated_at=datetime.now()
        )

    def __str__(self) -> str:
        """String representation of category."""
        return f"Category(id={self.id}, name='{self.name}')"

    def __eq__(self, other: object) -> bool:
        """Check if categories are equal."""
        if not isinstance(other, Category):
            return NotImplemented
        return self.id == other.id and self.name == other.name

    def __hash__(self) -> int:
        """Hash based on id and name."""
        return hash((self.id, self.name))

    def __lt__(self, other: "Category") -> bool:
        """Compare categories by name."""
        if not isinstance(other, Category):
            return NotImplemented
        return self.name.lower() < other.name.lower()

    @classmethod
    def create_empty(cls, id: int = -1) -> "Category":
        """
        Create an empty category instance.

        Args:
            id: Category ID (defaults to -1)

        Returns:
            Category: New empty Category instance
        """
        return cls(id=id, name="")


C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/customer.py:
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from utils.exceptions import ValidationException
import re

@dataclass
class Customer:
    id: int
    identifier_9: str
    name: Optional[str] = None
    identifier_3or4: Optional[str] = None
    _identifiers: List[str] = field(default_factory=list, init=False)

    def __post_init__(self):
        """
        Validate all fields after initialization and set up identifiers list.
        """
        self.validate_identifier_9(self.identifier_9)
        if self.identifier_3or4:
            self.validate_identifier_3or4(self.identifier_3or4)
        if self.name is not None:
            self.validate_name(self.name)
        
        # Initialize identifiers list
        self._identifiers = [self.identifier_9]
        if self.identifier_3or4:
            self._identifiers.append(self.identifier_3or4)

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "Customer":
        """
        Create a Customer instance from a database row.

        Args:
            row (Dict[str, Any]): Database row containing customer data.

        Returns:
            Customer: A new Customer instance.
        """
        return cls(
            id=row["id"],
            identifier_9=row["identifier_9"],
            name=row.get("name"),
            identifier_3or4=row.get("identifier_3or4"),
        )

    @staticmethod
    def validate_identifier_9(identifier: str) -> None:
        """
        Validate 9-digit identifier.

        Args:
            identifier (str): The identifier to validate.

        Raises:
            ValidationException: If identifier is invalid.
        """
        if not isinstance(identifier, str) or len(identifier) != 9 or not identifier.isdigit():
            raise ValidationException("identifier_9 must be a string of 9 digits")

    @staticmethod
    def validate_identifier_3or4(identifier: Optional[str]) -> None:
        """
        Validate 3 or 4-digit identifier.

        Args:
            identifier (Optional[str]): The identifier to validate.

        Raises:
            ValidationException: If identifier is invalid.
        """
        if identifier is not None:
            if not isinstance(identifier, str) or len(identifier) not in (3, 4) or not identifier.isdigit():
                raise ValidationException("identifier_3or4 must be a string of 3 or 4 digits")

    @staticmethod
    def validate_name(name: str) -> None:
        """
        Validate customer name.

        Args:
            name (str): The name to validate.

        Raises:
            ValidationException: If name is invalid.
        """
        if not isinstance(name, str):
            raise ValidationException("Name must be a string")

        # Remove extra whitespace and normalize
        name = " ".join(name.split())

        if len(name) > 50:
            raise ValidationException("Name cannot exceed 50 characters")

        # Validate that name contains only letters, spaces, and Spanish characters
        if not re.match(r'^[A-Za-zÁÉÍÓÚÑáéíóúñ ]+$', name):
            raise ValidationException("Name can only contain letters, accented characters, and spaces")

    def update_identifier_9(self, new_identifier_9: str) -> None:
        """
        Update the 9-digit identifier.

        Args:
            new_identifier_9 (str): The new identifier.
        """
        self.validate_identifier_9(new_identifier_9)
        self.identifier_9 = new_identifier_9
        self._identifiers[0] = new_identifier_9

    def update_identifier_3or4(self, new_identifier_3or4: Optional[str]) -> None:
        """
        Update the 3 or 4-digit identifier.

        Args:
            new_identifier_3or4 (Optional[str]): The new identifier.
        """
        self.validate_identifier_3or4(new_identifier_3or4)
        self.identifier_3or4 = new_identifier_3or4
        if new_identifier_3or4:
            if len(self._identifiers) > 1:
                self._identifiers[1] = new_identifier_3or4
            else:
                self._identifiers.append(new_identifier_3or4)
        elif len(self._identifiers) > 1:
            self._identifiers.pop()

    def update_name(self, new_name: Optional[str]) -> None:
        """
        Update the customer name.

        Args:
            new_name (Optional[str]): The new name.
        """
        if new_name is not None:
            self.validate_name(new_name)
            new_name = " ".join(new_name.split())  # Normalize whitespace
        self.name = new_name

    def get_all_identifiers(self) -> List[str]:
        """
        Get all identifiers associated with this customer.

        Returns:
            List[str]: List of identifiers.
        """
        return self._identifiers.copy()

    def get_display_name(self) -> str:
        """
        Get a formatted display name including identifiers and name.

        Returns:
            str: Formatted display name.
        """
        base = f"{self.identifier_9} ({self.identifier_3or4 or 'N/A'})"
        if self.name:
            return f"{base} - {self.name}"
        return base

    def __str__(self) -> str:
        """String representation of the customer."""
        identifiers = ", ".join(self._identifiers)
        name_info = f", name: {self.name}" if self.name else ""
        return f"Customer(id={self.id}, identifiers=[{identifiers}]{name_info})"

    def __eq__(self, other: object) -> bool:
        """Check equality with another customer."""
        if not isinstance(other, Customer):
            return NotImplemented
        return (
            self.id == other.id and 
            self._identifiers == other._identifiers and 
            self.name == other.name
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert customer to dictionary.

        Returns:
            Dict[str, Any]: Dictionary representation of the customer.
        """
        return {
            "id": self.id,
            "identifier_9": self.identifier_9,
            "identifier_3or4": self.identifier_3or4,
            "name": self.name
        }



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/inventory.py:
from dataclasses import dataclass, field, replace
from typing import Dict, Any, Optional, ClassVar
from datetime import datetime
from utils.exceptions import ValidationException
from enum import Enum

class StockStatus(Enum):
    """Enumeration of possible stock statuses."""
    OUT_OF_STOCK = "out_of_stock"
    LOW_STOCK = "low_stock"
    OPTIMAL = "optimal"
    OVERSTOCKED = "overstocked"

@dataclass(frozen=True)
class Inventory:
    """
    Represents inventory for a product in the system.
    
    Attributes:
        id (int): Unique identifier
        product_id (int): Associated product ID
        quantity (float): Current quantity in stock (up to 3 decimals)
        min_stock_level (float): Minimum stock level before reorder
        max_stock_level (Optional[float]): Maximum stock level capacity
        reorder_point (float): Point at which to reorder stock
        reorder_quantity (float): Quantity to reorder when reordering
        created_at (datetime): Creation timestamp
        updated_at (datetime): Last update timestamp
    """
    id: int
    product_id: int
    quantity: float
    min_stock_level: float = field(default=0.0)
    max_stock_level: Optional[float] = None
    reorder_point: float = field(default=0.0)
    reorder_quantity: float = field(default=0.0)
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    # Class constants
    QUANTITY_PRECISION: ClassVar[int] = 3
    MAX_QUANTITY: ClassVar[float] = 9999999.999

    def __post_init__(self) -> None:
        """
        Validate inventory data after initialization.
        
        Raises:
            ValidationException: If validation fails
        """
        if not isinstance(self.id, int) or self.id < 0:
            raise ValidationException("Invalid inventory ID")
            
        if not isinstance(self.product_id, int) or self.product_id < 0:
            raise ValidationException("Invalid product ID")

        self._validate_float_field(self.quantity, "Quantity")
        self._validate_float_field(self.min_stock_level, "Minimum stock level")
        
        if self.max_stock_level is not None:
            self._validate_float_field(self.max_stock_level, "Maximum stock level")
            if self.max_stock_level <= self.min_stock_level:
                raise ValidationException(
                    "Maximum stock level must be greater than minimum stock level"
                )

        self._validate_float_field(self.reorder_point, "Reorder point")
        self._validate_float_field(self.reorder_quantity, "Reorder quantity")

        # Round all float values to specified precision
        object.__setattr__(self, 'quantity', 
            self._round_quantity(self.quantity))
        object.__setattr__(self, 'min_stock_level', 
            self._round_quantity(self.min_stock_level))
        if self.max_stock_level is not None:
            object.__setattr__(self, 'max_stock_level', 
                self._round_quantity(self.max_stock_level))
        object.__setattr__(self, 'reorder_point', 
            self._round_quantity(self.reorder_point))
        object.__setattr__(self, 'reorder_quantity', 
            self._round_quantity(self.reorder_quantity))

    @classmethod
    def _round_quantity(cls, value: float) -> float:
        """Round float to specified precision."""
        return round(float(value), cls.QUANTITY_PRECISION)

    @staticmethod
    def _validate_float_field(value: float, field_name: str) -> None:
        """
        Validate a float field.
        
        Args:
            value: Value to validate
            field_name: Name of field for error messages
            
        Raises:
            ValidationException: If validation fails
        """
        if not isinstance(value, (int, float)):
            raise ValidationException(f"{field_name} must be a numeric value")
        
        float_value = float(value)
        if float_value < 0:
            raise ValidationException(f"{field_name} cannot be negative")
        
        if float_value > Inventory.MAX_QUANTITY:
            raise ValidationException(f"{field_name} exceeds maximum allowed value")

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "Inventory":
        """
        Create an Inventory instance from a database row.

        Args:
            row: Dictionary containing inventory data from database

        Returns:
            Inventory: New Inventory instance

        Raises:
            ValidationException: If required fields are missing or invalid
        """
        try:
            return cls(
                id=int(row["id"]),
                product_id=int(row["product_id"]),
                quantity=float(str(row["quantity"])),
                min_stock_level=float(str(row.get("min_stock_level", 0))),
                max_stock_level=float(str(row["max_stock_level"])) if row.get("max_stock_level") is not None else None,
                reorder_point=float(str(row.get("reorder_point", 0))),
                reorder_quantity=float(str(row.get("reorder_quantity", 0))),
                created_at=datetime.fromisoformat(row["created_at"]) if "created_at" in row else datetime.now(),
                updated_at=datetime.fromisoformat(row["updated_at"]) if "updated_at" in row else datetime.now()
            )
        except (KeyError, ValueError, TypeError) as e:
            raise ValidationException(f"Invalid inventory data: {str(e)}")

    def update_quantity(self, change: float) -> "Inventory":
        """
        Create new inventory instance with updated quantity.

        Args:
            change: Amount to change quantity by (positive or negative)

        Returns:
            Inventory: New Inventory instance with updated quantity
            
        Raises:
            ValidationException: If new quantity would be invalid
        """
        new_quantity = self.quantity + float(change)
        if new_quantity < 0:
            raise ValidationException(
                f"Cannot decrease quantity by {abs(change)}. Current quantity: {self.quantity}"
            )
        
        if self.max_stock_level is not None and new_quantity > self.max_stock_level:
            raise ValidationException(
                f"Cannot increase quantity above max stock level of {self.max_stock_level}"
            )
            
        return self.clone(
            quantity=new_quantity,
            updated_at=datetime.now()
        )

    def set_quantity(self, new_quantity: float) -> "Inventory":
        """
        Create new inventory instance with set quantity.

        Args:
            new_quantity: New quantity value

        Returns:
            Inventory: New Inventory instance with set quantity
            
        Raises:
            ValidationException: If new quantity is invalid
        """
        self._validate_float_field(new_quantity, "New quantity")
        if self.max_stock_level is not None and new_quantity > self.max_stock_level:
            raise ValidationException(
                f"Cannot set quantity above max stock level of {self.max_stock_level}"
            )
            
        return self.clone(
            quantity=new_quantity,
            updated_at=datetime.now()
        )

    def set_stock_levels(
        self,
        min_level: float,
        max_level: Optional[float] = None,
        reorder_point: Optional[float] = None,
        reorder_quantity: Optional[float] = None
    ) -> "Inventory":
        """
        Create new inventory instance with updated stock levels.

        Args:
            min_level: New minimum stock level
            max_level: New maximum stock level
            reorder_point: New reorder point
            reorder_quantity: New reorder quantity

        Returns:
            Inventory: New Inventory instance with updated stock levels
            
        Raises:
            ValidationException: If new levels are invalid
        """
        self._validate_float_field(min_level, "Minimum stock level")
        if max_level is not None:
            self._validate_float_field(max_level, "Maximum stock level")
            if max_level <= min_level:
                raise ValidationException(
                    "Maximum stock level must be greater than minimum stock level"
                )

        updates = {
            "min_stock_level": min_level,
            "max_stock_level": max_level,
            "updated_at": datetime.now()
        }
        
        if reorder_point is not None:
            self._validate_float_field(reorder_point, "Reorder point")
            updates["reorder_point"] = reorder_point
            
        if reorder_quantity is not None:
            self._validate_float_field(reorder_quantity, "Reorder quantity")
            updates["reorder_quantity"] = reorder_quantity

        return self.clone(**updates)

    def get_stock_status(self) -> StockStatus:
        """
        Get current stock status.

        Returns:
            StockStatus: Current stock status
        """
        if self.quantity == 0:
            return StockStatus.OUT_OF_STOCK
        if self.quantity <= self.min_stock_level:
            return StockStatus.LOW_STOCK
        if self.max_stock_level is not None and self.quantity >= self.max_stock_level:
            return StockStatus.OVERSTOCKED
        return StockStatus.OPTIMAL

    def needs_reorder(self) -> bool:
        """
        Check if stock needs reordering.

        Returns:
            bool: True if stock needs reordering
        """
        return self.quantity <= self.reorder_point and self.reorder_quantity > 0

    def get_suggested_order_quantity(self) -> Optional[float]:
        """
        Get suggested order quantity if reorder is needed.

        Returns:
            Optional[float]: Suggested order quantity or None if no reorder needed
        """
        if not self.needs_reorder():
            return None
            
        if self.max_stock_level is not None:
            return min(
                self.reorder_quantity,
                self.max_stock_level - self.quantity
            )
        return self.reorder_quantity

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert inventory to dictionary representation.

        Returns:
            Dict[str, Any]: Dictionary containing inventory data
        """
        return {
            "id": self.id,
            "product_id": self.product_id,
            "quantity": str(self.quantity),
            "min_stock_level": str(self.min_stock_level),
            "max_stock_level": str(self.max_stock_level) if self.max_stock_level is not None else None,
            "reorder_point": str(self.reorder_point),
            "reorder_quantity": str(self.reorder_quantity),
            "stock_status": self.get_stock_status().value,
            "needs_reorder": self.needs_reorder(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    def clone(self, **changes: Any) -> "Inventory":
        """
        Create a copy of this inventory with optional changes.

        Args:
            **changes: Attribute changes to apply to the clone

        Returns:
            Inventory: New Inventory instance with changes applied
        """
        return replace(self, **changes)

    def __str__(self) -> str:
        """String representation of inventory."""
        return (
            f"Inventory(id={self.id}, product_id={self.product_id}, "
            f"quantity={self.quantity}, status={self.get_stock_status().value})"
        )

    @classmethod
    def create_empty(cls, product_id: int, id: int = -1) -> "Inventory":
        """
        Create an empty inventory instance.

        Args:
            product_id: Associated product ID
            id: Inventory ID (defaults to -1)

        Returns:
            Inventory: New empty Inventory instance
        """
        return cls(
            id=id,
            product_id=product_id,
            quantity=0.0
        )



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/product.py:
from typing import Dict, Any, Optional
from utils.exceptions import ValidationException
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class Product:
    def __init__(
        self,
        id: int,
        name: str,
        description: str,
        category_id: int,
        cost_price: float,
        sell_price: float,
        barcode: Optional[str] = None,
        category_name: Optional[str] = None
    ):
        self.id = id
        self.name = name
        self.description = description
        self.category_id = category_id
        self.category_name = category_name
        self._cost_price = int(cost_price) if cost_price is not None else 0
        self._sell_price = int(sell_price) if sell_price is not None else 0
        self.barcode = barcode

    @property
    def cost_price(self) -> int:
        return self._cost_price

    @cost_price.setter
    def cost_price(self, value: Any):
        if value is None:
            self._cost_price = 0
            return
        try:
            price = int(value)
            if price < 0:
                raise ValidationException("Cost price cannot be negative")
            self._cost_price = price
        except (TypeError, ValueError):
            raise ValidationException("Invalid cost price format")

    @property
    def sell_price(self) -> int:
        return self._sell_price

    @sell_price.setter
    def sell_price(self, value: Any):
        if value is None:
            self._sell_price = 0
            return
        try:
            price = int(value)
            if price < 0:
                raise ValidationException("Sell price cannot be negative")
            self._sell_price = price
        except (TypeError, ValueError):
            raise ValidationException("Invalid sell price format")

    def calculate_profit(self) -> int:
        """Calculate the profit for this product."""
        return self.sell_price - self.cost_price

    def calculate_profit_margin(self) -> float:
        """Calculate the profit margin as a percentage."""
        if self.cost_price == 0:
            return 0
        return round((self.calculate_profit() / self.cost_price * 100), 2)

    def to_dict(self) -> Dict[str, Any]:
        """Convert product to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "category_id": self.category_id,
            "category_name": self.category_name or 'Uncategorized',
            "cost_price": int(self.cost_price),
            "sell_price": int(self.sell_price),
            "barcode": self.barcode
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Product':
        """Create a Product instance from a dictionary."""
        return cls(
            id=data.get('id', 0),
            name=data.get('name', ''),
            description=data.get('description', ''),
            category_id=data.get('category_id', 0),
            cost_price=data.get('cost_price', 0),
            sell_price=data.get('sell_price', 0),
            barcode=data.get('barcode', '')
        )

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> 'Product':
        """Create a Product instance from a database row."""
        logger.debug(f"Creating Product from row: {row}")
        product = cls(
            id=row['id'],
            name=row['name'],
            description=row['description'],
            category_id=row['category_id'],
            cost_price=row['cost_price'],
            sell_price=row['sell_price'],
            barcode=row['barcode'],
            category_name=row.get('category_name', 'Uncategorized')
        )
        logger.debug(f"Created Product: {vars(product)}")
        return product

    def validate(self):
        """Validate the product data."""
        if not self.name:
            raise ValidationException("Product name is required")
        if not self.category_id:
            raise ValidationException("Category ID is required")
        if not self.barcode:
            raise ValidationException("Barcode is required")
        if len(self.barcode) != 8:
            raise ValidationException("Barcode must be 8 digits")
        if not self.barcode.isdigit():
            raise ValidationException("Barcode must contain only digits")
        if self.sell_price is not None and self.cost_price is not None and self.sell_price < self.cost_price:
            raise ValidationException("Sell price cannot be less than cost price")

    def __str__(self) -> str:
        return f"Product(id={self.id}, name={self.name}, barcode={self.barcode})"

    def __repr__(self) -> str:
        return self.__str__()

    @staticmethod
    def validate_barcode(barcode: str) -> None:
        """Validate barcode format."""
        if not barcode:
            return  # Allow empty barcode
        
        if not barcode.isdigit():
            raise ValidationException("Barcode must contain only digits")
        
        valid_lengths = [8, 12, 13, 14]
        if len(barcode) not in valid_lengths:
            raise ValidationException(f"Barcode must be one of these lengths: {valid_lengths}")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/purchase.py:
from dataclasses import dataclass, field
from typing import List, Dict, Any
from datetime import datetime
from utils.exceptions import ValidationException
from utils.system.logger import logger
from utils.validation.validators import validate_money, validate_money_multiplication

@dataclass
class PurchaseItem:
    id: int
    purchase_id: int
    product_id: int
    quantity: float  # Allows up to 3 decimal places
    price: int      # Chilean Pesos - always integer

    def __post_init__(self):
        self.validate_quantity(self.quantity)
        self.validate_price(self.price)

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "PurchaseItem":
        return cls(
            id=row["id"],
            purchase_id=row["purchase_id"],
            product_id=row["product_id"],
            quantity=float(row["quantity"]),
            price=int(row["price"]),
        )

    @staticmethod
    def validate_quantity(quantity: float) -> None:
        """
        Validate that the quantity is positive and has max 3 decimal places.
        """
        if quantity <= 0:
            raise ValidationException("Quantity must be positive")
        
        # Check decimal places (convert to string to check actual decimal places)
        decimal_str = str(quantity).split('.')
        if len(decimal_str) > 1 and len(decimal_str[1]) > 3:
            raise ValidationException("Quantity cannot have more than 3 decimal places")

    @staticmethod
    def validate_price(price: int) -> None:
        """
        Validate that the price is a positive integer.
        """
        if not isinstance(price, int):
            raise ValidationException("Price must be an integer")
        if price < 0:
            raise ValidationException("Price cannot be negative")

    def total_price(self) -> int:
        """Calculate total price ensuring proper CLP rounding."""
        return validate_money_multiplication(self.price, self.quantity, "Total price")

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "purchase_id": self.purchase_id,
            "product_id": self.product_id,
            "quantity": round(self.quantity, 3),  # Always round to 3 decimal places
            "price": self.price,
            "total_price": self.total_price(),
        }

@dataclass
class Purchase:
    id: int
    supplier: str
    date: datetime
    items: List[PurchaseItem] = field(default_factory=list)
    _total_amount: int = field(init=False, default=0)  # Chilean Pesos - always integer

    def __post_init__(self):
        self.validate_supplier(self.supplier)
        self.validate_date(self.date)
        self.recalculate_total()

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "Purchase":
        return cls(
            id=row["id"],
            supplier=row["supplier"],
            date=datetime.fromisoformat(row["date"]),
        )

    @staticmethod
    def validate_supplier(supplier: str) -> None:
        """
        Validate supplier name.
        """
        if not supplier or len(supplier.strip()) == 0:
            raise ValidationException("Supplier name cannot be empty")
        if len(supplier) > 100:
            raise ValidationException("Supplier name cannot exceed 100 characters")

    @staticmethod
    def validate_date(date: datetime) -> None:
        """
        Validate purchase date is not in the future.
        """
        if date > datetime.now():
            raise ValidationException("Purchase date cannot be in the future")

    def add_item(self, item: PurchaseItem) -> None:
        """
        Add a purchase item and update total.
        """
        self.items.append(item)
        self._total_amount += item.total_price()

    def remove_item(self, item_id: int) -> None:
        """
        Remove a purchase item and update total.
        """
        item = next((item for item in self.items if item.id == item_id), None)
        if item:
            self.items.remove(item)
            self._total_amount -= item.total_price()
        else:
            raise ValidationException(f"Item with id {item_id} not found in the purchase")

    def recalculate_total(self) -> None:
        """Recalculate total amount ensuring proper CLP handling."""
        try:
            total = sum(item.total_price() for item in self.items)
            self._total_amount = validate_money(total, "Total amount")
        except Exception as e:
            logger.error(f"Error calculating total: {str(e)}")
            raise ValidationException("Error calculating total amount")

    @property
    def total_amount(self) -> int:
        """
        Get the total amount as integer (Chilean Pesos).
        """
        return self._total_amount

    def update_supplier(self, new_supplier: str) -> None:
        """
        Update supplier name with validation.
        """
        self.validate_supplier(new_supplier)
        self.supplier = new_supplier

    def update_date(self, new_date: datetime) -> None:
        """
        Update purchase date with validation.
        """
        self.validate_date(new_date)
        self.date = new_date

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert purchase to dictionary representation.
        """
        return {
            "id": self.id,
            "supplier": self.supplier,
            "date": self.date.isoformat(),
            "total_amount": self.total_amount,
            "items": [item.to_dict() for item in self.items],
        }

    def __str__(self) -> str:
        """
        String representation of the purchase.
        """
        return (
            f"Purchase(id={self.id}, supplier='{self.supplier}', "
            f"date='{self.date.isoformat()}', "
            f"total_amount={self.total_amount})"
        )

    @staticmethod
    def validate_items(items: List[PurchaseItem]) -> None:
        """
        Validate all items in a purchase.
        """
        if not items:
            raise ValidationException("Purchase must have at least one item")
        for item in items:
            if not isinstance(item, PurchaseItem):
                raise ValidationException("Invalid item type")
            item.validate_quantity(item.quantity)
            item.validate_price(item.price)

    def verify_totals(self) -> bool:
        """
        Verify that all totals are correctly calculated.
        """
        expected_total = sum(item.total_price() for item in self.items)
        return self._total_amount == expected_total

    def add_items(self, items: List[PurchaseItem]) -> None:
        """
        Add multiple items at once.
        """
        self.validate_items(items)
        for item in items:
            self.add_item(item)

    def get_item_count(self) -> int:
        """
        Get the total number of items.
        """
        return len(self.items)

    def get_total_quantity(self) -> float:
        """
        Get the total quantity of all items, rounded to 3 decimal places.
        """
        return round(sum(item.quantity for item in self.items), 3)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/sale.py:
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
from utils.exceptions import ValidationException
from utils.system.logger import logger
from utils.validation.validators import validate_money, validate_money_multiplication

@dataclass
class SaleItem:
    id: int
    sale_id: int
    product_id: int
    quantity: float  # Allow up to 3 decimals for weight-based products
    unit_price: int  # Chilean Pesos - always integer
    profit: int      # Chilean Pesos - always integer
    product_name: Optional[str] = None

    def __post_init__(self):
        self.quantity = self.normalize_quantity(self.quantity)
        self.validate_price(self.unit_price)
        self.validate_profit(self.profit)

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "SaleItem":
        try:
            return cls(
                id=int(row["id"]),
                sale_id=int(row["sale_id"]),
                product_id=int(row["product_id"]),
                quantity=float(row["quantity"]),
                unit_price=int(row["price"]),
                profit=int(row["profit"]),
                product_name=row.get("product_name")
            )
        except (ValueError, TypeError) as e:
            logger.error(f"Error creating SaleItem from row: {row}")
            logger.error(f"Error details: {str(e)}")
            raise

    @staticmethod
    def normalize_quantity(quantity: float) -> float:
        """Normalize and validate quantity value."""
        try:
            # Convert to float if not already
            if not isinstance(quantity, (int, float)):
                quantity = float(str(quantity))
            
            if quantity <= 0:
                raise ValidationException("Quantity must be positive")
            
            # Round to 3 decimal places for weight-based products
            return round(quantity, 3)
            
        except (ValueError, TypeError):
            raise ValidationException("Invalid quantity format")

    @staticmethod
    def validate_price(price: int) -> None:
        """Validate price value."""
        if not isinstance(price, int):
            raise ValidationException("Price must be an integer")
        if price < 0:
            raise ValidationException("Price cannot be negative")

    @staticmethod
    def validate_profit(profit: int) -> None:
        """Validate profit value."""
        if not isinstance(profit, int):
            raise ValidationException("Profit must be an integer")

    def total_price(self) -> int:
        """Calculate total price ensuring proper CLP rounding."""
        return validate_money_multiplication(self.unit_price, self.quantity, "Total price")

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "sale_id": self.sale_id,
            "product_id": self.product_id,
            "quantity": self.quantity,
            "unit_price": self.unit_price,
            "product_name": self.product_name,
            "total_price": self.total_price(),
            "profit": self.profit,
        }

@dataclass
class Sale:
    id: int
    customer_id: int
    date: datetime
    total_amount: int     # Chilean Pesos - always integer
    total_profit: int     # Chilean Pesos - always integer
    receipt_id: Optional[str] = None
    items: List[SaleItem] = field(default_factory=list)

    def __post_init__(self):
        self.validate_customer_id(self.customer_id)
        self.validate_date(self.date)
        self.validate_total_amount(self.total_amount)
        self.validate_total_profit(self.total_profit)

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]) -> "Sale":
        try:
            return cls(
                id=int(row["id"]),
                customer_id=int(row["customer_id"]),
                date=datetime.fromisoformat(row["date"]),
                total_amount=int(row["total_amount"]),
                total_profit=int(row["total_profit"]),
                receipt_id=row.get("receipt_id")
            )
        except (ValueError, TypeError) as e:
            logger.error(f"Error creating Sale from row: {row}")
            logger.error(f"Error details: {str(e)}")
            raise

    @staticmethod
    def validate_customer_id(customer_id: int) -> None:
        if not isinstance(customer_id, int) or customer_id <= 0:
            raise ValidationException("Invalid customer ID")

    @staticmethod
    def validate_date(date: datetime) -> None:
        if date > datetime.now():
            raise ValidationException("Sale date cannot be in the future")

    @staticmethod
    def validate_total_amount(total_amount: int) -> None:
        if not isinstance(total_amount, int):
            raise ValidationException("Total amount must be an integer")
        if total_amount < 0:
            raise ValidationException("Total amount cannot be negative")

    @staticmethod
    def validate_total_profit(total_profit: int) -> None:
        if not isinstance(total_profit, int):
            raise ValidationException("Total profit must be an integer")

    def add_item(self, item: SaleItem) -> None:
        self.items.append(item)
        self.recalculate_total()

    def remove_item(self, item_id: int) -> None:
        self.items = [item for item in self.items if item.id != item_id]
        self.recalculate_total()

    def recalculate_total(self) -> None:
        """Recalculate totals ensuring proper CLP handling."""
        self.total_amount = sum(item.total_price() for item in self.items)
        # Validate final total
        self.total_amount = validate_money(self.total_amount, "Total amount")
        
        # Calculate and validate total profit
        self.total_profit = sum(item.profit for item in self.items)
        self.total_profit = validate_money(self.total_profit, "Total profit")

    def update_date(self, new_date: datetime) -> None:
        self.validate_date(new_date)
        self.date = new_date

    def update_customer(self, new_customer_id: int) -> None:
        self.validate_customer_id(new_customer_id)
        self.customer_id = new_customer_id

    def update_receipt_id(self, new_receipt_id: Optional[str]) -> None:
        self.receipt_id = new_receipt_id

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "customer_id": self.customer_id,
            "date": self.date.isoformat(),
            "total_amount": self.total_amount,
            "total_profit": self.total_profit,
            "receipt_id": self.receipt_id,
            "items": [item.to_dict() for item in self.items],
        }

    def __str__(self) -> str:
        return (
            f"Sale(id={self.id}, customer_id={self.customer_id}, "
            f"date='{self.date.isoformat()}', total_amount={self.total_amount}, "
            f"total_profit={self.total_profit}, receipt_id='{self.receipt_id}')"
        )



C:/Users/corte/VS Code Projects/billing_inventory_system_new/models/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/analytics_service.py:
from typing import List, Dict, Any, Tuple
from database.database_manager import DatabaseManager
from functools import lru_cache
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException
from utils.validation.validators import validate_integer, validate_date
from utils.system.logger import logger
from datetime import datetime, timedelta

class AnalyticsService:
    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_sales_by_weekday(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                CASE CAST(strftime('%w', date) AS INTEGER)
                    WHEN 0 THEN 'Sunday'
                    WHEN 1 THEN 'Monday'
                    WHEN 2 THEN 'Tuesday'
                    WHEN 3 THEN 'Wednesday'
                    WHEN 4 THEN 'Thursday'
                    WHEN 5 THEN 'Friday'
                    WHEN 6 THEN 'Saturday'
                END AS weekday,
                SUM(total_amount) as total_sales,
                COUNT(*) as sale_count
            FROM sales
            WHERE date BETWEEN ? AND ?
            GROUP BY weekday
            ORDER BY CAST(strftime('%w', date) AS INTEGER)
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info("Sales by weekday retrieved", extra={"start_date": start_date, "end_date": end_date})
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_top_selling_products(start_date: str, end_date: str, limit: int = 10) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        limit = validate_integer(limit, min_value=1)
        query = """
            SELECT p.id, p.name, 
                   ROUND(SUM(si.quantity), 3) as total_quantity, 
                   SUM(ROUND(si.quantity * si.price)) as total_revenue,
                   COUNT(DISTINCT s.id) as sale_count
            FROM products p
            JOIN sale_items si ON p.id = si.product_id
            JOIN sales s ON si.sale_id = s.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY p.id
            ORDER BY total_quantity DESC
            LIMIT ?
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date, limit))
        logger.info("Top selling products retrieved", extra={
            "start_date": start_date,
            "end_date": end_date,
            "limit": limit
        })
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_sales_trend(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT date, 
                   total_amount as daily_sales,
                   COUNT(*) as sale_count
            FROM sales
            WHERE date BETWEEN ? AND ?
            GROUP BY date
            ORDER BY date
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info("Sales trend retrieved", extra={"start_date": start_date, "end_date": end_date})
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_weekly_profit_trend(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                strftime('%Y-%W', date) as week,
                MIN(date) as week_start,
                SUM(total_profit) as weekly_profit
            FROM sales
            WHERE date BETWEEN ? AND ?
            GROUP BY week
            ORDER BY week
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info("Weekly profit trend retrieved", extra={"start_date": start_date, "end_date": end_date})
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_profit_and_volume_by_product(start_date: str, end_date: str, limit: int = 5) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        limit = validate_integer(limit, min_value=1, max_value=100)
        query = """
            SELECT 
                p.id,
                p.name,
                SUM(ROUND(si.quantity * (si.price - p.cost_price))) as total_profit,
                ROUND(SUM(si.quantity), 3) as sales_volume
            FROM products p
            JOIN sale_items si ON p.id = si.product_id
            JOIN sales s ON si.sale_id = s.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY p.id
            ORDER BY total_profit DESC
            LIMIT ?
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date, limit))
        logger.info(f"Retrieved profit and volume by product: {len(result)} products")
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_category_performance(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                c.name as category,
                SUM(ROUND(si.quantity * si.price)) as total_sales,
                ROUND(SUM(si.quantity), 3) as number_of_products_sold,
                COUNT(DISTINCT s.id) as sale_count
            FROM categories c
            JOIN products p ON c.id = p.category_id
            JOIN sale_items si ON p.id = si.product_id
            JOIN sales s ON si.sale_id = s.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY c.id
            ORDER BY total_sales DESC
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info("Category performance retrieved", extra={"start_date": start_date, "end_date": end_date})
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_profit_by_product(start_date: str, end_date: str, limit: int = 10) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        limit = validate_integer(limit, min_value=1)
        query = """
            SELECT p.id, p.name, 
                   SUM(ROUND(si.quantity * si.price)) as total_revenue,
                   SUM(ROUND(si.quantity * p.cost_price)) as total_cost,
                   SUM(ROUND(si.quantity * (si.price - p.cost_price))) as total_profit,
                   COUNT(DISTINCT s.id) as sale_count
            FROM products p
            JOIN sale_items si ON p.id = si.product_id
            JOIN sales s ON si.sale_id = s.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY p.id
            ORDER BY total_profit DESC
            LIMIT ?
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date, limit))
        logger.info(f"Retrieved profit by product: {len(result)} products")
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_profit_trend(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT date, 
                total_amount as daily_revenue,
                total_profit as daily_profit,
                COUNT(*) as sale_count
            FROM sales
            WHERE date BETWEEN ? AND ?
            GROUP BY date
            ORDER BY date
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info(f"Retrieved profit trend: {len(result)} days")
        return result

    @staticmethod
    @lru_cache(maxsize=32)
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_profit_margin_distribution(start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                CASE 
                    WHEN profit_margin < 0 THEN 'Loss'
                    WHEN profit_margin BETWEEN 0 AND 10 THEN '0-10%'
                    WHEN profit_margin BETWEEN 10 AND 20 THEN '10-20%'
                    WHEN profit_margin BETWEEN 20 AND 30 THEN '20-30%'
                    WHEN profit_margin BETWEEN 30 AND 40 THEN '30-40%'
                    ELSE '40%+'
                END as margin_range,
                COUNT(*) as product_count,
                ROUND(AVG(profit_margin), 2) as average_margin,
                SUM(total_sales) as total_sales
            FROM (
                SELECT 
                    p.id,
                    CASE 
                        WHEN SUM(ROUND(si.quantity * si.price)) > 0 
                        THEN (CAST(SUM(ROUND(si.quantity * (si.price - p.cost_price))) AS FLOAT) / 
                              SUM(ROUND(si.quantity * si.price))) * 100
                        ELSE 0 
                    END as profit_margin,
                    SUM(ROUND(si.quantity * si.price)) as total_sales
                FROM products p
                JOIN sale_items si ON p.id = si.product_id
                JOIN sales s ON si.sale_id = s.id
                WHERE s.date BETWEEN ? AND ?
                GROUP BY p.id
            ) as product_margins
            GROUP BY margin_range
            ORDER BY 
                CASE margin_range
                    WHEN 'Loss' THEN 1
                    WHEN '0-10%' THEN 2
                    WHEN '10-20%' THEN 3
                    WHEN '20-30%' THEN 4
                    WHEN '30-40%' THEN 5
                    ELSE 6
                END
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        logger.info(f"Retrieved profit margin distribution: {len(result)} ranges")
        return result

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def get_sales_summary(start_date: str, end_date: str) -> Dict[str, Any]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                COUNT(*) as total_sales,
                COALESCE(SUM(total_amount), 0) as total_revenue,
                COALESCE(SUM(total_profit), 0) as total_profit,
                COALESCE(ROUND(AVG(total_amount)), 0) as average_sale_value,
                COUNT(DISTINCT customer_id) as unique_customers
            FROM sales
            WHERE date BETWEEN ? AND ?
        """
        result = DatabaseManager.fetch_one(query, (start_date, end_date))
        if result is None:
            logger.warning(f"No sales data found for period {start_date} to {end_date}")
            return {
                "total_sales": 0,
                "total_revenue": 0,
                "total_profit": 0,
                "average_sale_value": 0,
                "unique_customers": 0
            }
        logger.info(f"Retrieved sales summary from {start_date} to {end_date}")
        return dict(result)

    @staticmethod
    def clear_cache():
        AnalyticsService.get_sales_by_weekday.cache_clear()
        AnalyticsService.get_top_selling_products.cache_clear()
        AnalyticsService.get_sales_trend.cache_clear()
        AnalyticsService.get_weekly_profit_trend.cache_clear()
        AnalyticsService.get_profit_and_volume_by_product.cache_clear()
        AnalyticsService.get_category_performance.cache_clear()
        AnalyticsService.get_profit_by_product.cache_clear()
        AnalyticsService.get_profit_trend.cache_clear()
        AnalyticsService.get_profit_margin_distribution.cache_clear()
        logger.debug("Analytics cache cleared")

    @staticmethod
    def get_date_range(range_type: str) -> Tuple[str, str]:
        today = datetime.now().date()
        if range_type == 'today':
            return today.isoformat(), today.isoformat()
        elif range_type == 'yesterday':
            yesterday = today - timedelta(days=1)
            return yesterday.isoformat(), yesterday.isoformat()
        elif range_type == 'this_week':
            start_of_week = today - timedelta(days=today.weekday())
            return start_of_week.isoformat(), today.isoformat()
        elif range_type == 'this_month':
            start_of_month = today.replace(day=1)
            return start_of_month.isoformat(), today.isoformat()
        elif range_type == 'this_year':
            start_of_year = today.replace(month=1, day=1)
            return start_of_year.isoformat(), today.isoformat()
        else:
            raise ValueError("Invalid range type")

    def _validate_date_range(self, start_date: str, end_date: str) -> None:
        """Validate date range for analytics queries."""
        try:
            start = datetime.fromisoformat(start_date)
            end = datetime.fromisoformat(end_date)
            today = datetime.now()
            
            if start > today or end > today:
                raise ValidationException("Date range cannot be in the future")
            if start > end:
                raise ValidationException("Start date must be before end date")
                
        except ValueError as e:
            raise ValidationException(f"Invalid date format: {str(e)}")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/category_service.py:
from typing import List, Optional, Dict, Any
from database.database_manager import DatabaseManager
from models.category import Category
from utils.validation.validators import validate_string, validate_integer
from utils.sanitizers import sanitize_html, sanitize_sql
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import ValidationException, NotFoundException, DatabaseException
from utils.system.logger import logger
from utils.system.event_system import event_system
from functools import lru_cache

class CategoryService:
    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def create_category(name: str) -> Optional[int]:
        name = validate_string(name, min_length=1, max_length=50)
        name = sanitize_html(name)
        query = "INSERT INTO categories (name) VALUES (?)"
        try:
            cursor = DatabaseManager.execute_query(query, (name,))
            category_id = cursor.lastrowid
            CategoryService.clear_cache()
            logger.info("Category created", extra={"category_id": category_id, "name": name})
            event_system.category_added.emit(category_id)
            return category_id
        except Exception as e:
            logger.error("Failed to create category", extra={"error": str(e), "name": name})
            raise DatabaseException(f"Failed to create category: {str(e)}")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_category(category_id: int) -> Optional[Category]:
        category_id = validate_integer(category_id, min_value=1)
        query = "SELECT * FROM categories WHERE id = ?"
        row = DatabaseManager.fetch_one(query, (category_id,))
        if row:
            logger.info("Category retrieved", extra={"category_id": category_id})
            return Category.from_db_row(row)
        else:
            logger.warning("Category not found", extra={"category_id": category_id})
            raise NotFoundException(f"Category with ID {category_id} not found")

    @staticmethod
    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_all_categories() -> List[Category]:
        query = "SELECT * FROM categories ORDER BY name"
        rows = DatabaseManager.fetch_all(query)
        categories = [Category.from_db_row(row) for row in rows]
        logger.info("All categories retrieved", extra={"count": len(categories)})
        return categories

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, ValidationException, DatabaseException, show_dialog=True)
    def update_category(category_id: int, name: str) -> None:
        category_id = validate_integer(category_id, min_value=1)
        name = validate_string(name, min_length=1, max_length=50)
        name = sanitize_html(name)
        query = "UPDATE categories SET name = ? WHERE id = ?"
        try:
            cursor = DatabaseManager.execute_query(query, (name, category_id))
            if cursor.rowcount == 0:
                raise NotFoundException(f"Category with ID {category_id} not found")
            CategoryService.clear_cache()
            logger.info("Category updated", extra={"category_id": category_id, "new_name": name})
            event_system.category_updated.emit(category_id)
        except Exception as e:
            logger.error("Failed to update category", extra={"error": str(e), "category_id": category_id})
            raise DatabaseException(f"Failed to update category: {str(e)}")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def delete_category(category_id: int) -> None:
        category_id = validate_integer(category_id, min_value=1)
        query = "DELETE FROM categories WHERE id = ?"
        try:
            cursor = DatabaseManager.execute_query(query, (category_id,))
            if cursor.rowcount == 0:
                raise NotFoundException(f"Category with ID {category_id} not found")
            CategoryService.clear_cache()
            logger.info("Category deleted", extra={"category_id": category_id})
            event_system.category_deleted.emit(category_id)
        except Exception as e:
            logger.error("Failed to delete category", extra={"error": str(e), "category_id": category_id})
            raise DatabaseException(f"Failed to delete category: {str(e)}")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def search_categories(search_term: str) -> List[Category]:
        search_term = validate_string(search_term, max_length=50)
        query = """
        SELECT * FROM categories
        WHERE name LIKE ?
        ORDER BY name
        """
        search_pattern = f"%{sanitize_sql(search_term)}%"
        rows = DatabaseManager.fetch_all(query, (search_pattern,))
        categories = [Category.from_db_row(row) for row in rows]
        logger.info("Categories searched", extra={"search_term": search_term, "count": len(categories)})
        return categories

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_category_by_name(name: str) -> Optional[Category]:
        name = validate_string(name, min_length=1, max_length=50)
        query = "SELECT * FROM categories WHERE name = ?"
        row = DatabaseManager.fetch_one(query, (name,))
        if row:
            logger.info("Category retrieved by name", extra={"name": name})
            return Category.from_db_row(row)
        else:
            logger.warning("Category not found by name", extra={"name": name})
            raise NotFoundException(f"Category with name '{name}' not found")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_products_in_category(category_id: int) -> List[Dict[str, Any]]:
        category_id = validate_integer(category_id, min_value=1)
        query = """
        SELECT p.id, p.name, p.description, p.cost_price, p.sell_price
        FROM products p
        WHERE p.category_id = ?
        """
        rows = DatabaseManager.fetch_all(query, (category_id,))
        logger.info("Products retrieved for category", extra={"category_id": category_id, "count": len(rows)})
        return rows

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_category_statistics() -> List[Dict[str, Any]]:
        query = """
        SELECT 
            c.id, 
            c.name, 
            COUNT(p.id) as product_count,
            COALESCE(SUM(i.quantity), 0) as total_inventory,
            COALESCE(SUM(p.sell_price * i.quantity), 0) as inventory_value
        FROM categories c
        LEFT JOIN products p ON c.id = p.category_id
        LEFT JOIN inventory i ON p.id = i.product_id
        GROUP BY c.id
        ORDER BY c.name
        """
        rows = DatabaseManager.fetch_all(query)
        logger.info("Category statistics retrieved", extra={"count": len(rows)})
        return rows

    @staticmethod
    def clear_cache():
        CategoryService.get_all_categories.cache_clear()
        logger.debug("Category cache cleared")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/customer_service.py:
from typing import List, Dict, Any, Optional, Tuple
from database.database_manager import DatabaseManager
from models.customer import Customer
from utils.validation.validators import (
    validate_9digit_identifier as validate_identifier_9,
    validate_3or4digit_identifier as validate_identifier_3or4,
    validate_integer,
    validate_string
)
from utils.sanitizers import sanitize_html, sanitize_sql
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import NotFoundException, ValidationException, DatabaseException
from utils.system.logger import logger
from utils.system.event_system import event_system
from functools import lru_cache

class CustomerService:
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def create_customer(
        self,
        identifier_9: str,
        name: Optional[str] = None,
        identifier_3or4: Optional[str] = None
    ) -> Optional[int]:
        """
        Create a new customer.

        Args:
            identifier_9 (str): The 9-digit identifier.
            name (Optional[str]): The customer's name.
            identifier_3or4 (Optional[str]): The 3 or 4-digit identifier.

        Returns:
            Optional[int]: The ID of the created customer.

        Raises:
            ValidationException: If validation fails.
            DatabaseException: If database operation fails.
        """
        logger.debug(f"Creating customer with identifier_9: {identifier_9}")
        identifier_9 = validate_identifier_9(sanitize_html(str(identifier_9)))
        
        if name is not None:
            temp_customer = Customer(id=0, identifier_9="000000000", name=name)
            name = temp_customer.name  # This will be the normalized version
        
        if identifier_3or4:
            identifier_3or4 = validate_identifier_3or4(sanitize_html(identifier_3or4))

        query = "INSERT INTO customers (identifier_9, name) VALUES (?, ?)"
        params = (identifier_9, name)
        try:
            cursor = DatabaseManager.execute_query(query, params)
            customer_id = cursor.lastrowid

            if customer_id is not None and identifier_3or4:
                self.update_identifier_3or4(customer_id, identifier_3or4)

            self.clear_cache()
            logger.info("Customer created", extra={
                "customer_id": customer_id,
                "identifier_9": identifier_9
            })
            event_system.customer_added.emit(customer_id)
            return customer_id
        except Exception as e:
            logger.error("Failed to create customer", extra={
                "error": str(e),
                "identifier_9": identifier_9
            })
            raise DatabaseException(f"Failed to create customer: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def update_identifier_3or4(self, customer_id: int, identifier_3or4: Optional[str]) -> None:
        """
        Update the 3 or 4-digit identifier for a customer.

        Args:
            customer_id (int): The customer ID.
            identifier_3or4 (Optional[str]): The new identifier.

        Raises:
            ValidationException: If validation fails.
            DatabaseException: If database operation fails.
        """
        customer_id = validate_integer(customer_id, min_value=1)
        if identifier_3or4 is not None:
            identifier_3or4 = validate_identifier_3or4(sanitize_html(identifier_3or4))

        delete_query = "DELETE FROM customer_identifiers WHERE customer_id = ?"
        insert_query = "INSERT INTO customer_identifiers (customer_id, identifier_3or4) VALUES (?, ?)"

        try:
            DatabaseManager.execute_query(delete_query, (customer_id,))
            if identifier_3or4:
                DatabaseManager.execute_query(insert_query, (customer_id, identifier_3or4))
            logger.info("Customer 3or4 identifier updated", extra={
                "customer_id": customer_id,
                "identifier_3or4": identifier_3or4
            })
        except Exception as e:
            logger.error("Failed to update customer 3or4 identifier", extra={
                "error": str(e),
                "customer_id": customer_id
            })
            raise DatabaseException(f"Failed to update customer 3or4 identifier: {str(e)}")

        self.clear_cache()
        event_system.customer_updated.emit(customer_id)

    @db_operation(show_dialog=True)
    def get_customer(self, customer_id: int) -> Optional[Customer]:
        """
        Get a customer by ID.

        Args:
            customer_id (int): The customer ID.

        Returns:
            Optional[Customer]: The customer if found.

        Raises:
            NotFoundException: If customer not found.
            DatabaseException: If database operation fails.
        """
        customer_id = validate_integer(customer_id, min_value=1)
        query = """
        SELECT c.*, ci.identifier_3or4
        FROM customers c
        LEFT JOIN customer_identifiers ci ON c.id = ci.customer_id
        WHERE c.id = ?
        """
        row = DatabaseManager.fetch_one(query, (customer_id,))
        if not row:
            logger.warning(f"Customer not found", extra={"customer_id": customer_id})
            return None
        logger.debug("Customer retrieved", extra={"customer_id": customer_id})
        return Customer.from_db_row(row)

    @lru_cache(maxsize=100)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_all_customers(self) -> List[Customer]:
        """
        Get all customers.

        Returns:
            List[Customer]: List of all customers.

        Raises:
            DatabaseException: If database operation fails.
        """
        query = """
        SELECT c.*, ci.identifier_3or4
        FROM customers c
        LEFT JOIN customer_identifiers ci ON c.id = ci.customer_id
        ORDER BY c.identifier_9
        """
        try:
            # *** new log statement ***
            logger.debug(f"[get_all_customers] Executing SQL: {query}")

            rows = DatabaseManager.fetch_all(query)

            # *** new log statement ***
            logger.debug(f"[get_all_customers] Fetched {len(rows)} rows from DB. Example row: {rows[0] if rows else 'no rows'}")

            customers = [Customer.from_db_row(row) for row in rows]

            # *** new log statement ***
            for i, cust in enumerate(customers[:5]):  # just log first 5 for brevity
                logger.debug(f"[get_all_customers] Customer #{i} => ID={cust.id}...")

            logger.info("All customers retrieved", extra={"count": len(customers)})
            return customers
        except Exception as e:
            logger.error(f"Error fetching all customers: {str(e)}")
            raise DatabaseException(f"Failed to fetch customers: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def update_customer(self, customer_id: int, **kwargs):
        """Update customer details by ID."""
        logger.debug(f"[update_customer] Starting with kwargs: {kwargs}")
        
        try:
            customer_id = validate_integer(customer_id, min_value=1)
            customer_updates = {}
            
            # Debug log the validation steps
            logger.debug("[update_customer] Starting field validation")
            
            if 'name' in kwargs:
                logger.debug(f"[update_customer] Validating name: {kwargs['name']}")
                name = kwargs['name']
                if name is not None:
                    validate_string(name, max_length=50)
                customer_updates['name'] = name
                
            if 'identifier_9' in kwargs:
                logger.debug(f"[update_customer] Validating identifier_9: {kwargs['identifier_9']}")
                identifier_9 = validate_identifier_9(kwargs['identifier_9'])
                customer_updates['identifier_9'] = identifier_9

            # Log the SQL query before execution
            if customer_updates:
                update_fields = []
                params = []
                for key, value in customer_updates.items():
                    update_fields.append(f"{key} = ?")
                    params.append(value)
                
                query = """
                    UPDATE customers 
                    SET {} 
                    WHERE id = ?
                """.format(", ".join(update_fields))
                params.append(customer_id)
                
                # Debug log the actual SQL and parameters
                logger.debug(f"[update_customer] Executing SQL: {query}")
                logger.debug(f"[update_customer] With parameters: {params}")
                
                DatabaseManager.execute_query(query, tuple(params))

            # Handle identifier_3or4 separately
            if 'identifier_3or4' in kwargs:
                logger.debug(f"[update_customer] Handling identifier_3or4: {kwargs['identifier_3or4']}")
                identifier_3or4 = kwargs['identifier_3or4']
                if identifier_3or4:
                    identifier_3or4 = validate_identifier_3or4(identifier_3or4)
                self.update_identifier_3or4(customer_id, identifier_3or4)

            logger.debug("[update_customer] Update completed successfully")
            self.clear_cache()
            
        except Exception as e:
            logger.error(
                f"[update_customer] Error: {str(e)}", 
                extra={"exc_info": True}
            )
            raise DatabaseException(f"Failed to update customer: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def delete_customer(self, customer_id: int) -> None:
        """
        Delete a customer.

        Args:
            customer_id (int): The customer ID.

        Raises:
            DatabaseException: If database operation fails.
            NotFoundException: If customer not found.
        """
        customer_id = validate_integer(customer_id, min_value=1)
        query = "DELETE FROM customers WHERE id = ?"
        try:
            cursor = DatabaseManager.execute_query(query, (customer_id,))
            if cursor.rowcount == 0:
                raise NotFoundException(f"Customer with ID {customer_id} not found")
            DatabaseManager.execute_query(
                "DELETE FROM customer_identifiers WHERE customer_id = ?",
                (customer_id,)
            )
            logger.info("Customer deleted", extra={"customer_id": customer_id})
            self.clear_cache()
            event_system.customer_deleted.emit(customer_id)
        except Exception as e:
            logger.error("Failed to delete customer", extra={
                "error": str(e),
                "customer_id": customer_id
            })
            raise DatabaseException(f"Failed to delete customer: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_customer_by_identifier_9(self, identifier_9: str) -> Optional[Customer]:
        """
        Get a customer by their 9-digit identifier.

        Args:
            identifier_9 (str): The 9-digit identifier.

        Returns:
            Optional[Customer]: The customer if found.

        Raises:
            DatabaseException: If database operation fails.
        """
        identifier_9 = validate_identifier_9(identifier_9)
        query = """
        SELECT c.*, ci.identifier_3or4
        FROM customers c
        LEFT JOIN customer_identifiers ci ON c.id = ci.customer_id
        WHERE c.identifier_9 = ?
        """
        row = DatabaseManager.fetch_one(query, (identifier_9,))
        if row:
            logger.info("Customer retrieved by identifier_9", extra={"identifier_9": identifier_9})
            return Customer.from_db_row(row)
        else:
            logger.warning("Customer not found by identifier_9", extra={"identifier_9": identifier_9})
            return None

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_customers_by_identifier_3or4(self, identifier_3or4: str) -> List[Customer]:
        """
        Get customers by their 3 or 4-digit identifier.
        Returns a list of unique customers based on identifier_9.

        Args:
            identifier_3or4 (str): The 3 or 4-digit identifier.

        Returns:
            List[Customer]: List of unique matching customers.

        Raises:
            DatabaseException: If database operation fails.
        """
        identifier_3or4 = validate_identifier_3or4(identifier_3or4)
        query = """
        SELECT DISTINCT c.*, ci.identifier_3or4
        FROM customers c
        JOIN customer_identifiers ci ON c.id = ci.customer_id
        WHERE ci.identifier_3or4 = ?
        ORDER BY c.identifier_9
        """
        try:
            rows = DatabaseManager.fetch_all(query, (identifier_3or4,))
            customers = [Customer.from_db_row(row) for row in rows]
            
            # Remove duplicates based on identifier_9
            unique_customers = []
            seen_phones = set()
            for customer in customers:
                if customer.identifier_9 not in seen_phones:
                    unique_customers.append(customer)
                    seen_phones.add(customer.identifier_9)
                else:
                    logger.warning(f"Duplicate customer found with phone {customer.identifier_9} for department {identifier_3or4}")
            
            logger.info(f"Retrieved {len(unique_customers)} unique customers by identifier_3or4", extra={
                "identifier_3or4": identifier_3or4,
                "total_found": len(customers),
                "unique_count": len(unique_customers)
            })
            
            return unique_customers
            
        except Exception as e:
            logger.error(f"Error retrieving customers by identifier_3or4: {str(e)}")
            raise DatabaseException(f"Failed to retrieve customers: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_customer_stats(self, customer_id: int) -> Tuple[int, int]:
        """
        Get customer statistics.

        Args:
            customer_id (int): The customer ID.

        Returns:
            Tuple[int, int]: Total purchases and total amount.

        Raises:
            DatabaseException: If database operation fails.
        """
        customer_id = validate_integer(customer_id, min_value=1)
        query = """
            SELECT COUNT(*) as total_purchases,
                   COALESCE(SUM(total_amount), 0) as total_amount
            FROM sales
            WHERE customer_id = ?
        """
        result = DatabaseManager.fetch_one(query, (customer_id,))
        if result:
            logger.info("Customer stats retrieved", extra={"customer_id": customer_id})
            return result["total_purchases"], result["total_amount"]
        else:
            logger.warning("Customer stats not found", extra={"customer_id": customer_id})
            return 0, 0

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def search_customers(self, search_term: str) -> List[Customer]:
        """
        Search customers by name or identifier.

        Args:
            search_term (str): Search term.

        Returns:
            List[Customer]: List of matching customers.

        Raises:
            DatabaseException: If database operation fails.
        """
        search_term = validate_string(search_term, max_length=50)
        query = """
        SELECT DISTINCT c.*, ci.identifier_3or4
        FROM customers c
        LEFT JOIN customer_identifiers ci ON c.id = ci.customer_id
        WHERE c.identifier_9 LIKE ? 
           OR ci.identifier_3or4 LIKE ?
           OR (c.name IS NOT NULL AND LOWER(c.name) LIKE LOWER(?))
        """
        # For name search, only match from start
        name_pattern = f"{sanitize_sql(search_term)}%"
        # For identifiers, match anywhere
        id_pattern = f"%{sanitize_sql(search_term)}%"
        
        rows = DatabaseManager.fetch_all(query, (id_pattern, id_pattern, name_pattern))
        customers = [Customer.from_db_row(row) for row in rows]
        logger.info("Customers searched", extra={
            "search_term": search_term,
            "count": len(customers)
        })
        return customers

    def clear_cache(self):
        """Clear the customer cache."""
        self.get_all_customers.cache_clear()
        logger.debug("Customer cache cleared")

    @db_operation(show_dialog=True)
    def get_customer_purchase_history(self, customer_id: int, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get customer purchase history.

        Args:
            customer_id (int): The customer ID.
            limit (int): Maximum number of records to return.

        Returns:
            List[Dict[str, Any]]: List of purchase records.

        Raises:
            DatabaseException: If database operation fails.
        """
        customer_id = validate_integer(customer_id, min_value=1)
        limit = validate_integer(limit, min_value=1)
        query = """
        SELECT s.id as sale_id, s.date, s.total_amount, s.total_profit, s.receipt_id,
               COUNT(si.id) as item_count
        FROM sales s
        LEFT JOIN sale_items si ON s.id = si.sale_id
        WHERE s.customer_id = ?
        GROUP BY s.id
        ORDER BY s.date DESC
        LIMIT ?
        """
        rows = DatabaseManager.fetch_all(query, (customer_id, limit))
        logger.info("Customer purchase history retrieved", extra={
            "customer_id": customer_id,
            "count": len(rows)
        })
        return rows



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/inventory_service.py:
from typing import List, Dict, Any, Optional
from database.database_manager import DatabaseManager
from models.inventory import Inventory
from utils.system.event_system import event_system
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import ValidationException, NotFoundException, DatabaseException, UIException
from utils.validation.validators import validate_integer, validate_string, validate_float_non_negative, validate_float
from utils.system.logger import logger
from functools import lru_cache

class InventoryService:
    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def update_quantity(product_id: int, quantity_change: float) -> None:
        product_id = validate_integer(product_id, min_value=1)
        quantity_change = validate_float(quantity_change)  # Allow negative values for sales

        inventory = InventoryService.get_inventory(product_id)

        if inventory:
            # Round to 3 decimal places for precision
            new_quantity = round(inventory.quantity + quantity_change, 3)
            if new_quantity < 0:
                logger.warning(f"Attempted negative inventory for product {product_id}")
                raise ValidationException("Inventory cannot be negative")
            InventoryService._update_inventory_quantity(product_id, new_quantity)
        else:
            if quantity_change < 0:
                raise ValidationException(
                    f"Cannot decrease quantity for non-existent inventory item. Product ID: {product_id}"
                )
            InventoryService._create_inventory_item(product_id, quantity_change)

        InventoryService.clear_cache()
        event_system.inventory_changed.emit(product_id)
        logger.info(f"Inventory updated for product {product_id}", extra={
            "quantity_change": quantity_change,
            "new_quantity": new_quantity
        })

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_inventory(product_id: int) -> Optional[Inventory]:
        product_id = validate_integer(product_id, min_value=1)
        query = "SELECT * FROM inventory WHERE product_id = ?"
        row = DatabaseManager.fetch_one(query, (product_id,))
        if row:
            logger.info("Inventory retrieved", extra={"product_id": product_id})
            return Inventory.from_db_row(row)
        logger.warning("Inventory not found", extra={"product_id": product_id})
        return None

    @staticmethod
    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def get_all_inventory() -> List[Dict[str, Any]]:
        """Get all inventory items with product and category details."""
        query = """
            SELECT 
                i.product_id,
                i.quantity,
                p.name as product_name,
                p.barcode,
                COALESCE(c.name, 'Uncategorized') as category_name
            FROM inventory i
            JOIN products p ON i.product_id = p.id
            LEFT JOIN categories c ON p.category_id = c.id
            ORDER BY p.name
        """
        
        try:
            rows = DatabaseManager.fetch_all(query)
            inventory_items = []
            
            for row in rows:
                item = {
                    'product_id': row['product_id'],
                    'product_name': row['product_name'],
                    'category_name': row['category_name'],
                    'quantity': float(row['quantity']),
                    'barcode': row['barcode'] or 'No barcode'
                }
                inventory_items.append(item)
                
            return inventory_items
            
        except Exception as e:
            logger.error(f"Error fetching inventory: {str(e)}")
            raise DatabaseException(f"Failed to fetch inventory: {str(e)}")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def set_quantity(product_id: int, new_quantity: float) -> None:
        try:
            product_id = validate_integer(product_id, min_value=1)
            new_quantity = validate_float_non_negative(new_quantity)
            
            query = "UPDATE inventory SET quantity = ? WHERE product_id = ?"
            DatabaseManager.execute_query(query, (new_quantity, product_id))
            
            InventoryService.clear_cache()
            event_system.inventory_changed.emit(product_id)
            event_system.inventory_updated.emit()
            
        except Exception as e:
            logger.error(f"Failed to update inventory quantity: {str(e)}")
            raise DatabaseException(f"Failed to update inventory: {str(e)}")

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def delete_inventory(product_id: int) -> None:
        product_id = validate_integer(product_id, min_value=1)
        query = "DELETE FROM inventory WHERE product_id = ?"
        DatabaseManager.execute_query(query, (product_id,))
        InventoryService.clear_cache()
        event_system.inventory_changed.emit(product_id)
        logger.info("Inventory deleted", extra={"product_id": product_id})

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_inventory_value() -> int:
        query = """
            SELECT SUM(i.quantity * COALESCE(p.cost_price, 0)) as total_value
            FROM inventory i
            JOIN products p ON i.product_id = p.id
        """
        result = DatabaseManager.fetch_one(query)
        # Round to nearest integer since we're dealing with Chilean Pesos
        total_value = int(round(float(result["total_value"] if result and result["total_value"] is not None else 0)))
        logger.info("Total inventory value calculated", extra={"total_value": total_value})
        return total_value

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def adjust_inventory(product_id: int, quantity_change: float, reason: str) -> None:
        product_id = validate_integer(product_id, min_value=1)
        quantity_change = validate_float(quantity_change)  # Can be negative for adjustments
        reason = validate_string(reason, max_length=255)
        
        # Round to 3 decimal places
        quantity_change = round(quantity_change, 3)
        
        InventoryService.update_quantity(product_id, quantity_change)
        query = """
            INSERT INTO inventory_adjustments (product_id, quantity_change, reason, date) 
            VALUES (?, ?, ?, CURRENT_TIMESTAMP)
        """
        DatabaseManager.execute_query(query, (product_id, str(quantity_change), reason))
        InventoryService.clear_cache()
        logger.info("Inventory adjusted", extra={
            "product_id": product_id,
            "quantity_change": quantity_change,
            "reason": reason
        })

    @staticmethod
    def clear_cache() -> None:
        """Clear the inventory cache."""
        logger.debug("Clearing inventory cache")
        InventoryService.get_all_inventory.cache_clear()

    @staticmethod
    @db_operation(show_dialog=True)
    def _update_inventory_quantity(product_id: int, new_quantity: float) -> None:
        product_id = validate_integer(product_id, min_value=1)
        new_quantity = validate_float(new_quantity, min_value=0)  # Ensure non-negative inventory
        
        # Round to 3 decimal places
        new_quantity = round(new_quantity, 3)
        
        query = "UPDATE inventory SET quantity = ? WHERE product_id = ?"
        DatabaseManager.execute_query(query, (str(new_quantity), product_id))
        logger.debug("Inventory quantity updated", extra={
            "product_id": product_id,
            "new_quantity": new_quantity
        })

    @staticmethod
    @db_operation(show_dialog=True)
    def _create_inventory_item(product_id: int, quantity: float) -> None:
        product_id = validate_integer(product_id, min_value=1)
        quantity = validate_float(quantity, min_value=0)  # Ensure non-negative initial quantity
        
        # Round to 3 decimal places
        quantity = round(quantity, 3)
        
        query = "INSERT INTO inventory (product_id, quantity) VALUES (?, ?)"
        DatabaseManager.execute_query(query, (product_id, str(quantity)))
        logger.debug("New inventory item created", extra={
            "product_id": product_id,
            "initial_quantity": quantity
        })

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_inventory_movements(
        product_id: int, start_date: str, end_date: str
    ) -> List[Dict[str, Any]]:
        product_id = validate_integer(product_id, min_value=1)
        start_date = validate_string(start_date)
        end_date = validate_string(end_date)
        query = """
            SELECT 'adjustment' as type, date, quantity_change, reason
            FROM inventory_adjustments
            WHERE product_id = ? AND date BETWEEN ? AND ?
            UNION ALL
            SELECT 'sale' as type, s.date, -si.quantity as quantity_change, 
                   'Sale' as reason
            FROM sale_items si
            JOIN sales s ON si.sale_id = s.id
            WHERE si.product_id = ? AND s.date BETWEEN ? AND ?
            UNION ALL
            SELECT 'purchase' as type, p.date, pi.quantity as quantity_change, 
                   'Purchase' as reason
            FROM purchase_items pi
            JOIN purchases p ON pi.purchase_id = p.id
            WHERE pi.product_id = ? AND p.date BETWEEN ? AND ?
            ORDER BY date
        """
        params = (product_id, start_date, end_date) * 3
        result = DatabaseManager.fetch_all(query, params)
        logger.info("Inventory movements retrieved", extra={
            "product_id": product_id,
            "start_date": start_date,
            "end_date": end_date,
            "count": len(result)
        })
        return result

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_inventory_turnover(start_date: str, end_date: str) -> Dict[int, float]:
        start_date = validate_string(start_date)
        end_date = validate_string(end_date)
        query = """
            WITH sales_data AS (
                SELECT si.product_id, SUM(si.quantity) as total_sold
                FROM sale_items si
                JOIN sales s ON si.sale_id = s.id
                WHERE s.date BETWEEN ? AND ?
                GROUP BY si.product_id
            ),
            avg_inventory AS (
                SELECT product_id, AVG(quantity) as avg_quantity
                FROM inventory
                GROUP BY product_id
            )
            SELECT sd.product_id, 
                   CASE WHEN ai.avg_quantity > 0 
                        THEN sd.total_sold / ai.avg_quantity 
                        ELSE 0 
                   END as turnover_ratio
            FROM sales_data sd
            JOIN avg_inventory ai ON sd.product_id = ai.product_id
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        turnover_ratios = {row['product_id']: round(float(row['turnover_ratio']), 3) 
                          for row in result}
        logger.info("Inventory turnover calculated", extra={
            "start_date": start_date,
            "end_date": end_date,
            "product_count": len(turnover_ratios)
        })
        return turnover_ratios

    @staticmethod
    def get_low_stock_products() -> List[Dict[str, Any]]:
        query = """
            SELECT p.id, p.name, i.quantity
            FROM products p
            JOIN inventory i ON p.id = i.product_id
            WHERE i.quantity < 10
        """
        products = DatabaseManager.fetch_all(query)
        logger.debug("Retrieved low stock products", extra={
            "count": len(products)
        })
        return products

    @staticmethod
    def calculate_inventory_turnover(start_date: str, end_date: str) -> Dict[int, float]:
        start_date = validate_string(start_date)
        end_date = validate_string(end_date)
        query = """
            WITH sales_data AS (
                SELECT si.product_id, SUM(si.quantity) as total_sold
                FROM sale_items si
                JOIN sales s ON si.sale_id = s.id
                WHERE s.date BETWEEN ? AND ?
                GROUP BY si.product_id
            ),
            avg_inventory AS (
                SELECT product_id, AVG(quantity) as avg_quantity
                FROM inventory
                GROUP BY product_id
            )
            SELECT sd.product_id, 
                   CASE WHEN ai.avg_quantity > 0 
                        THEN sd.total_sold / ai.avg_quantity 
                        ELSE 0 
                   END as turnover_ratio
            FROM sales_data sd
            JOIN avg_inventory ai ON sd.product_id = ai.product_id
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date))
        turnover_ratios = {row['product_id']: round(float(row['turnover_ratio']), 3) 
                          for row in result}
        logger.info("Inventory turnover calculated", extra={
            "start_date": start_date,
            "end_date": end_date,
            "product_count": len(turnover_ratios)
        })
        return turnover_ratios



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/product_service.py:
from typing import List, Optional, Dict, Any
from database.database_manager import DatabaseManager
from models.product import Product
from PySide6.QtCore import QTimer
from utils.validation.validators import validate_string, validate_integer
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import NotFoundException, ValidationException, DatabaseException, UIException
from utils.system.logger import logger
from utils.system.event_system import event_system
from functools import lru_cache

class ProductService:
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def create_product(self, product_data: Dict[str, Any]) -> Optional[int]:
        validated_data = self._validate_product_data(product_data, is_create=True)
        
        if 'barcode' not in validated_data:
            validated_data['barcode'] = None

        try:
            DatabaseManager.begin_transaction()

            query = """
            INSERT INTO products (
                name, description, category_id, cost_price, sell_price, barcode
            ) VALUES (
                :name, :description, :category_id, :cost_price, :sell_price, :barcode
            )
            """
            cursor = DatabaseManager.execute_query(query, validated_data)
            product_id = cursor.lastrowid

            if product_id:
                # Initialize inventory with 0 quantity
                inventory_query = """
                INSERT INTO inventory (product_id, quantity) 
                VALUES (?, 0.000)
                """
                DatabaseManager.execute_query(inventory_query, (product_id,))
                DatabaseManager.commit_transaction()
                
                # Clear caches
                self.clear_cache()
                
                logger.info("Product created with inventory initialized", extra={
                    "product_id": product_id,
                    "name": validated_data['name']
                })

                # Emit events with a small delay to ensure database operations complete
                QTimer.singleShot(50, lambda: event_system.product_added.emit(product_id))
                QTimer.singleShot(100, lambda: event_system.inventory_changed.emit(product_id))
                
                return product_id
            else:
                DatabaseManager.rollback_transaction()
                raise DatabaseException("Failed to create product: No product ID returned")

        except Exception as e:
            DatabaseManager.rollback_transaction()
            logger.error("Failed to create product", extra={
                "error": str(e),
                "data": validated_data
            })
            raise DatabaseException(f"Failed to create product: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_product(self, product_id: int) -> Optional[Product]:
        """
        Get a product by ID.

        Args:
            product_id: The product ID.

        Returns:
            Optional[Product]: The product if found.

        Raises:
            NotFoundException: If product not found.
            DatabaseException: If database operation fails.
        """
        product_id = validate_integer(product_id, min_value=1)
        query = """
        SELECT p.*, c.name as category_name 
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        WHERE p.id = :product_id
        """
        row = DatabaseManager.fetch_one(query, {"product_id": product_id})
        if row:
            logger.info("Product retrieved", extra={"product_id": product_id})
            return Product.from_db_row(row)
        else:
            logger.warning("Product not found", extra={"product_id": product_id})
            raise NotFoundException(f"Product with ID {product_id} not found")

    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_all_products(self) -> List[Product]:
        """Get all products with fresh data."""
        query = """
        SELECT DISTINCT p.*, c.name as category_name 
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        ORDER BY p.id
        """
        try:
            rows = DatabaseManager.fetch_all(query)
            products = [Product.from_db_row(row) for row in rows]
            logger.info(f"Retrieved {len(products)} products")
            return products
        except Exception as e:
            logger.error(f"Error retrieving products: {str(e)}")
            raise DatabaseException(f"Failed to retrieve products: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, ValidationException, DatabaseException, show_dialog=True)
    def update_product(self, product_id: int, update_data: Dict[str, Any]) -> None:
        """
        Update a product.

        Args:
            product_id: The product ID.
            update_data: Dictionary containing fields to update.

        Raises:
            NotFoundException: If product not found.
            ValidationException: If validation fails.
            DatabaseException: If database operation fails.
        """
        product_id = validate_integer(product_id, min_value=1)
        
        # Fetch current product to ensure it exists
        current_product = self.get_product(product_id)
        if not current_product:
            raise NotFoundException(f"No product found with ID: {product_id}")

        # Validate barcode if provided
        if 'barcode' in update_data and update_data['barcode'] != current_product.barcode:
            self._validate_barcode_unique(update_data['barcode'])

        # Validate and prepare update data
        validated_data = self._validate_product_data(update_data, is_create=False)
        
        if not validated_data:
            logger.warning("No valid fields to update", extra={"product_id": product_id})
            return

        # Prepare SQL query
        set_clause = ", ".join(f"{key} = :{key}" for key in validated_data.keys())
        query = f"UPDATE products SET {set_clause} WHERE id = :product_id"
        validated_data['product_id'] = product_id

        try:
            DatabaseManager.execute_query(query, validated_data)
            logger.info("Product updated", extra={
                "product_id": product_id,
                "updated_fields": list(validated_data.keys())
            })
            self.clear_cache()
            event_system.product_updated.emit(product_id)
        except Exception as e:
            logger.error("Failed to update product", extra={
                "error": str(e),
                "product_id": product_id
            })
            raise DatabaseException(f"Failed to update product: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def delete_product(self, product_id: int) -> None:
        """Delete a product and clear caches."""
        product_id = validate_integer(product_id, min_value=1)
        
        try:
            DatabaseManager.begin_transaction()
            
            # First delete related records
            DatabaseManager.execute_query(
                "DELETE FROM sale_items WHERE product_id = ?", 
                (product_id,)
            )
            
            DatabaseManager.execute_query(
                "DELETE FROM purchase_items WHERE product_id = ?", 
                (product_id,)
            )
            
            DatabaseManager.execute_query(
                "DELETE FROM inventory WHERE product_id = ?", 
                (product_id,)
            )
            
            # Finally delete the product
            query = "DELETE FROM products WHERE id = ?"
            cursor = DatabaseManager.execute_query(query, (product_id,))
            
            if cursor.rowcount == 0:
                DatabaseManager.rollback_transaction()
                raise NotFoundException(f"Product with ID {product_id} not found")
            
            # Commit all changes
            DatabaseManager.commit_transaction()
            
            # Clear product cache
            self.clear_cache()
            
            # Emit events after successful transaction
            event_system.product_deleted.emit(product_id)
            event_system.inventory_changed.emit(product_id)
            
            logger.info(f"Product deleted successfully: ID {product_id}")
            
        except Exception as e:
            DatabaseManager.rollback_transaction()
            logger.error(f"Failed to delete product", extra={"error": str(e), "product_id": product_id})
            raise DatabaseException(f"Failed to delete product: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def search_products(self, search_term: str) -> List[Product]:
        """
        Search products by name, description, or barcode.

        Args:
            search_term: The search term.

        Returns:
            List[Product]: List of matching products.

        Raises:
            DatabaseException: If database operation fails.
        """
        search_term = validate_string(search_term, max_length=100)
        query = """
        SELECT p.*, c.name as category_name 
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        WHERE LOWER(p.name) LIKE LOWER(:search_pattern) 
           OR LOWER(COALESCE(p.description, '')) LIKE LOWER(:search_pattern)
           OR LOWER(COALESCE(p.barcode, '')) LIKE LOWER(:search_pattern)
        ORDER BY p.name
        """
        search_pattern = f"%{search_term}%"
        rows = DatabaseManager.fetch_all(query, {"search_pattern": search_pattern})
        products = [Product.from_db_row(row) for row in rows]
        logger.info("Products searched", extra={
            "search_term": search_term,
            "count": len(products)
        })
        return products

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_product_by_barcode(self, barcode: str) -> Optional[Product]:
        """Get a product by barcode."""
        logger.debug(f"Getting product by barcode: {barcode}")
        query = """
            SELECT p.*, c.name as category_name 
            FROM products p
            LEFT JOIN categories c ON p.category_id = c.id
            WHERE p.barcode = ?
        """
        try:
            row = DatabaseManager.fetch_one(query, (barcode,))
            if row:
                logger.debug(f"Found product row: {row}")
                product = Product.from_db_row(row)
                logger.debug(f"Created product object: {vars(product)}")
                return product
            return None
        except Exception as e:
            logger.error(f"Error getting product by barcode: {str(e)}")
            raise DatabaseException(f"Failed to get product: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_product_profit_margin(self, product_id: int) -> int:
        """
        Calculate product profit margin.

        Args:
            product_id: The product ID.

        Returns:
            int: The profit margin percentage.

        Raises:
            NotFoundException: If product not found.
            DatabaseException: If database operation fails.
        """
        try:
            product = self.get_product(product_id)
            if product is None:
                logger.warning(f"Product not found for ID: {product_id}")
                raise NotFoundException(f"Product with ID {product_id} not found")
            
            if product.cost_price is None or product.sell_price is None:
                logger.info(f"Unable to calculate profit margin for product {product_id}: cost_price or sell_price is None")
                return 0
            
            if product.sell_price == 0:
                logger.warning(f"Sell price is zero for product {product_id}, unable to calculate profit margin")
                return 0
            
            profit_margin = int((product.sell_price - product.cost_price) / product.sell_price * 100)
            logger.info(f"Calculated profit margin for product {product_id}: {profit_margin}%")
            return profit_margin
        except Exception as e:
            logger.error(f"Error calculating profit margin for product {product_id}: {str(e)}")
            raise

    def clear_cache(self):
        """Clear the product cache."""
        self.get_all_products.cache_clear()
        logger.debug("Product cache cleared")

    def _validate_product_data(self, data: Dict[str, Any], is_create: bool) -> Dict[str, Any]:
        """
        Validate product data.

        Args:
            data: The data to validate.
            is_create: Whether this is a create operation.

        Returns:
            Dict[str, Any]: Validated data.

        Raises:
            ValidationException: If validation fails.
        """
        validated = {}
        if 'name' in data or is_create:
            validated['name'] = validate_string(
                data.get('name', ''), min_length=1, max_length=100
            )
        
        if 'description' in data:
            validated['description'] = validate_string(
                data.get('description', ''), min_length=0, max_length=500
            )
        
        if 'category_id' in data:
            category_id = data.get('category_id')
            validated['category_id'] = validate_integer(
                category_id, min_value=1
            ) if category_id is not None else None
        
        if 'cost_price' in data:
            cost_price = data.get('cost_price')
            if cost_price is not None:
                validated['cost_price'] = validate_integer(cost_price, min_value=0)
        
        if 'sell_price' in data:
            sell_price = data.get('sell_price')
            if sell_price is not None:
                validated['sell_price'] = validate_integer(sell_price, min_value=0)

        if 'barcode' in data:
            barcode = data.get('barcode')
            if barcode is not None:
                self._validate_barcode_format(barcode)
                validated['barcode'] = barcode
        
        if is_create and 'name' not in validated:
            raise ValidationException("Product name is required when creating a product")
        
        return validated

    @staticmethod
    def _validate_barcode_format(barcode: str) -> None:
        """
        Validate barcode format.

        Args:
            barcode: The barcode to validate.

        Raises:
            ValidationException: If barcode format is invalid.
        """
        if not barcode:
            return

        if not isinstance(barcode, str):
            raise ValidationException("Barcode must be a string")
        
        # Remove any whitespace
        barcode = barcode.strip()
        
        if len(barcode) == 0:
            return
            
        # Check if barcode contains only digits
        if not barcode.isdigit():
            raise ValidationException("Barcode must contain only digits")
        
        # Validate length - accept common barcode lengths
        valid_lengths = {8, 12, 13, 14}  # EAN-8, UPC-A, EAN-13, EAN-14
        if len(barcode) not in valid_lengths:
            raise ValidationException(
                f"Invalid barcode length. Must be one of: {valid_lengths}"
            )

    def _validate_barcode_unique(self, barcode: str) -> None:
        """
        Validate barcode uniqueness.

        Args:
            barcode: The barcode to validate.

        Raises:
            ValidationException: If barcode is not unique.
        """
        if not barcode:
            return

        existing_product = self.get_product_by_barcode(barcode)
        if existing_product:
            raise ValidationException(
                f"Barcode {barcode} is already in use by product: {existing_product.name}"
            )



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/purchase_service.py:
from typing import List, Dict, Any, Optional
from database.database_manager import DatabaseManager
from models.purchase import Purchase, PurchaseItem
from services.inventory_service import InventoryService
from utils.validation.validators import validate_string, validate_date, validate_integer, validate_float_non_negative
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import ValidationException, NotFoundException, DatabaseException
from utils.system.logger import logger
from utils.system.event_system import event_system
from functools import lru_cache

class PurchaseService:
    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def create_purchase(
        supplier: str, date: str, items: List[Dict[str, Any]]
    ) -> Optional[int]:
        supplier = validate_string(supplier, max_length=100)
        date = validate_date(date)
        PurchaseService._validate_purchase_items(items)
        
        # Calculate total amount with proper integer handling for money
        total_amount = sum(
            int(round(item["quantity"] * item["cost_price"]))
            for item in items
        )

        purchase_id = PurchaseService._insert_purchase(supplier, date, total_amount)

        if purchase_id is None:
            raise ValidationException("Failed to create purchase record")

        PurchaseService._insert_purchase_items(purchase_id, items)
        PurchaseService._update_inventory(items)

        logger.info("Purchase created", extra={
            "purchase_id": purchase_id,
            "supplier": supplier,
            "total_amount": total_amount
        })
        PurchaseService.clear_cache()
        event_system.purchase_added.emit(purchase_id)
        return purchase_id

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_purchase(purchase_id: int) -> Optional[Purchase]:
        purchase_id = validate_integer(purchase_id, min_value=1)
        query = "SELECT * FROM purchases WHERE id = ?"
        row = DatabaseManager.fetch_one(query, (purchase_id,))
        if row:
            purchase = Purchase.from_db_row(row)
            purchase.items = PurchaseService.get_purchase_items(purchase_id)
            logger.info("Purchase retrieved", extra={"purchase_id": purchase_id})
            return purchase
        else:
            logger.warning("Purchase not found", extra={"purchase_id": purchase_id})
            raise NotFoundException(f"Purchase with ID {purchase_id} not found")

    @staticmethod
    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_all_purchases() -> List[Purchase]:
        query = "SELECT * FROM purchases ORDER BY date DESC"
        rows = DatabaseManager.fetch_all(query)
        purchases = [Purchase.from_db_row(row) for row in rows]
        for purchase in purchases:
            purchase.items = PurchaseService.get_purchase_items(purchase.id)
        logger.info("All purchases retrieved", extra={"count": len(purchases)})
        return purchases

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_purchase_items(purchase_id: int) -> List[PurchaseItem]:
        purchase_id = validate_integer(purchase_id, min_value=1)
        query = "SELECT * FROM purchase_items WHERE purchase_id = ?"
        rows = DatabaseManager.fetch_all(query, (purchase_id,))
        return [PurchaseItem.from_db_row(row) for row in rows]

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def delete_purchase(purchase_id: int) -> None:
        purchase_id = validate_integer(purchase_id, min_value=1)
        items = PurchaseService.get_purchase_items(purchase_id)

        for item in items:
            InventoryService.update_quantity(item.product_id, -item.quantity)

        DatabaseManager.execute_query(
            "DELETE FROM purchase_items WHERE purchase_id = ?", (purchase_id,)
        )
        DatabaseManager.execute_query(
            "DELETE FROM purchases WHERE id = ?", (purchase_id,)
        )
        logger.info("Purchase deleted", extra={"purchase_id": purchase_id})
        PurchaseService.clear_cache()
        event_system.purchase_deleted.emit(purchase_id)

    @staticmethod
    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_suppliers() -> List[str]:
        query = "SELECT DISTINCT supplier FROM purchases"
        rows = DatabaseManager.fetch_all(query)
        suppliers = [row["supplier"] for row in rows]
        logger.info("Suppliers retrieved", extra={"count": len(suppliers)})
        return suppliers

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def update_purchase(
        purchase_id: int, supplier: str, date: str, items: List[Dict[str, Any]]
    ) -> None:
        purchase_id = validate_integer(purchase_id, min_value=1)
        supplier = validate_string(supplier, max_length=100)
        date = validate_date(date)
        PurchaseService._validate_purchase_items(items)
        
        old_items = PurchaseService.get_purchase_items(purchase_id)
        PurchaseService._revert_inventory(old_items)

        # Calculate total with proper rounding for money values
        total_amount = sum(
            int(round(item["quantity"] * item["cost_price"]))
            for item in items
        )

        PurchaseService._update_purchase(purchase_id, supplier, date, total_amount)
        PurchaseService._update_purchase_items(purchase_id, items)
        PurchaseService._update_inventory(items)

        logger.info("Purchase updated", extra={
            "purchase_id": purchase_id,
            "supplier": supplier,
            "total_amount": total_amount
        })
        PurchaseService.clear_cache()
        event_system.purchase_updated.emit(purchase_id)

    @staticmethod
    def _validate_purchase_items(items: List[Dict[str, Any]]) -> None:
        """Validate purchase items with proper quantity and price handling."""
        if not items:
            raise ValidationException("Purchase must have at least one item")
        for item in items:
            try:
                # Validate quantity as float with 3 decimal places
                quantity = validate_float_non_negative(float(item.get("quantity", 0)))
                if round(quantity, 3) != quantity:
                    raise ValidationException("Quantity cannot have more than 3 decimal places")
                
                # Validate cost_price as integer (Chilean Pesos)
                cost_price = validate_integer(item.get("cost_price", 0))
                if not isinstance(cost_price, int):
                    raise ValidationException("Cost price must be an integer")
                
                if quantity <= 0 or cost_price <= 0:
                    raise ValidationException("Item quantity and cost price must be positive")
                    
            except (ValueError, TypeError):
                raise ValidationException("Invalid quantity or cost price format")

    @staticmethod
    @db_operation(show_dialog=True)
    def _insert_purchase(
        supplier: str, date: str, total_amount: int
    ) -> Optional[int]:
        query = "INSERT INTO purchases (supplier, date, total_amount) VALUES (?, ?, ?)"
        cursor = DatabaseManager.execute_query(query, (supplier, date, total_amount))
        return cursor.lastrowid

    @staticmethod
    @db_operation(show_dialog=True)
    def _insert_purchase_items(purchase_id: int, items: List[Dict[str, Any]]) -> None:
        for item in items:
            query = """
                INSERT INTO purchase_items (purchase_id, product_id, quantity, price)
                VALUES (?, ?, ?, ?)
            """
            # Store quantity with 3 decimal places precision
            quantity_str = str(round(float(item["quantity"]), 3))
            DatabaseManager.execute_query(
                query,
                (purchase_id, item["product_id"], quantity_str, item["cost_price"])
            )

            update_query = "UPDATE products SET cost_price = ? WHERE id = ?"
            DatabaseManager.execute_query(
                update_query, (item["cost_price"], item["product_id"])
            )

    @staticmethod
    def _update_inventory(items: List[Dict[str, Any]]) -> None:
        for item in items:
            quantity = round(float(item["quantity"]), 3)
            InventoryService.update_quantity(item["product_id"], quantity)

    @staticmethod
    def _revert_inventory(items: List[PurchaseItem]) -> None:
        for item in items:
            quantity = -round(float(item.quantity), 3)
            InventoryService.update_quantity(item.product_id, quantity)

    @staticmethod
    @db_operation(show_dialog=True)
    def _update_purchase(
        purchase_id: int, supplier: str, date: str, total_amount: int
    ) -> None:
        query = "UPDATE purchases SET supplier = ?, date = ?, total_amount = ? WHERE id = ?"
        DatabaseManager.execute_query(
            query, (supplier, date, total_amount, purchase_id)
        )

    @staticmethod
    @db_operation(show_dialog=True)
    def _update_purchase_items(purchase_id: int, items: List[Dict[str, Any]]) -> None:
        DatabaseManager.execute_query(
            "DELETE FROM purchase_items WHERE purchase_id = ?", (purchase_id,)
        )
        PurchaseService._insert_purchase_items(purchase_id, items)

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_purchases_by_supplier(supplier: str, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        supplier = validate_string(supplier, max_length=100)
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT id, date, total_amount
            FROM purchases
            WHERE supplier = ? AND date BETWEEN ? AND ?
            ORDER BY date DESC
        """
        rows = DatabaseManager.fetch_all(query, (supplier, start_date, end_date))
        purchases = [{"id": row["id"], 
                     "date": row["date"], 
                     "total_amount": row["total_amount"]} 
                    for row in rows]
        logger.info("Purchases by supplier retrieved", extra={
            "supplier": supplier,
            "start_date": start_date,
            "end_date": end_date,
            "count": len(purchases)
        })
        return purchases

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_purchase_trends(start_date: str, end_date: str, interval: str = 'month') -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        interval = validate_string(interval, max_length=10)
        if interval not in ['day', 'week', 'month']:
            raise ValidationException("Invalid interval. Must be 'day', 'week', or 'month'")

        date_format = {
            'day': '%Y-%m-%d',
            'week': '%Y-%W',
            'month': '%Y-%m'
        }

        query = f"""
            SELECT 
                strftime('{date_format[interval]}', date) as period,
                COUNT(*) as purchase_count,
                SUM(total_amount) as total_amount
            FROM purchases
            WHERE date BETWEEN ? AND ?
            GROUP BY period
            ORDER BY period
        """
        rows = DatabaseManager.fetch_all(query, (start_date, end_date))
        trends = [{"period": row["period"], 
                  "purchase_count": row["purchase_count"], 
                  "total_amount": row["total_amount"]} 
                 for row in rows]
        logger.info("Purchase trends retrieved", extra={
            "start_date": start_date,
            "end_date": end_date,
            "interval": interval,
            "count": len(trends)
        })
        return trends

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_top_suppliers(start_date: str, end_date: str, limit: int = 10) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        limit = validate_integer(limit, min_value=1)
        query = """
            SELECT supplier, 
                   COUNT(*) as purchase_count, 
                   SUM(total_amount) as total_amount
            FROM purchases
            WHERE date BETWEEN ? AND ?
            GROUP BY supplier
            ORDER BY total_amount DESC
            LIMIT ?
        """
        rows = DatabaseManager.fetch_all(query, (start_date, end_date, limit))
        top_suppliers = [{
            "supplier": row["supplier"],
            "purchase_count": row["purchase_count"],
            "total_amount": row["total_amount"]
        } for row in rows]
        logger.info("Top suppliers retrieved", extra={
            "start_date": start_date,
            "end_date": end_date,
            "limit": limit,
            "count": len(top_suppliers)
        })
        return top_suppliers

    @staticmethod
    def clear_cache():
        PurchaseService.get_all_purchases.cache_clear()
        PurchaseService.get_suppliers.cache_clear()
        logger.debug("Purchase cache cleared")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/sale_service.py:
from typing import List, Dict, Any, Optional
from database.database_manager import DatabaseManager
from models.sale import Sale, SaleItem
from services.inventory_service import InventoryService
from services.customer_service import CustomerService
from services.product_service import ProductService
from utils.validation.validators import validate_integer, validate_string, validate_date, validate_float
from utils.decorators import db_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, NotFoundException
from utils.system.logger import logger
from utils.system.event_system import event_system
from functools import lru_cache
from datetime import datetime, timedelta
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter


class SaleService:
    def __init__(self):
        self.inventory_service = InventoryService()
        self.customer_service = CustomerService()
        self.product_service = ProductService()

    @staticmethod
    @db_operation(show_dialog=True)
    def diagnose_sales_data():
        query = "SELECT * FROM sales"
        rows = DatabaseManager.fetch_all(query)
        for row in rows:
            print(f"Sale ID: {row['id']}")
            print(f"  customer_id: {row['customer_id']}")
            print(f"  date: {row['date']}")
            print(f"  total_amount: {row['total_amount']}")
            print(f"  total_profit: {row['total_profit']}")
            print(f"  receipt_id: {row['receipt_id']}")
            print("---")

        query = "SELECT * FROM sale_items"
        rows = DatabaseManager.fetch_all(query)
        for row in rows:
            print(f"Sale Item ID: {row['id']}")
            print(f"  sale_id: {row['sale_id']}")
            print(f"  product_id: {row['product_id']}")
            print(f"  quantity: {row['quantity']}")
            print(f"  price: {row['price']}")
            print(f"  profit: {row['profit']}")
            print("---")

    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def create_sale(self, customer_id: int, date: str, items: List[Dict[str, Any]]) -> int:
        """
        1) Insert a new 'sales' row with zero placeholders for total_amount / total_profit.
        2) Insert sale_items for this sale.
        3) Calculate final totals, generate receipt_id, and update 'sales' row.
        4) Emit sale_added event so UI (Sales Tab) refreshes automatically.
        """
        try:
            # If no date was provided, use today's date in "YYYY-MM-DD" format
            sale_date_str = date or datetime.now().strftime("%Y-%m-%d")

            # 1) Create the sale row with placeholders
            insert_query = """
                INSERT INTO sales (customer_id, date, total_amount, total_profit)
                VALUES (?, ?, 0, 0)
            """
            cursor = DatabaseManager.execute_query(insert_query, (customer_id, sale_date_str))
            sale_id = cursor.lastrowid
            if sale_id is None:
                raise DatabaseException("Failed to get new sale ID after insert.")

            # 2) Insert all sale items referencing this sale_id
            items_query = """
                INSERT INTO sale_items (sale_id, product_id, quantity, price, profit)
                VALUES (?, ?, ?, ?, ?)
            """
            # Convert your 'items' list into the parameters needed
            batch_params = []
            for item in items:
                # item might look like:
                # { "product_id": 123, "quantity": 2.0, "sell_price": 1000, "profit": 300 }
                batch_params.append((
                    sale_id,
                    int(item["product_id"]),
                    float(item["quantity"]),
                    int(item["sell_price"]),
                    int(item["profit"])
                ))
            DatabaseManager.executemany(items_query, batch_params)

            # 3) Compute final totals + receipt ID
            total_amount = 0
            total_profit = 0
            for item in items:
                qty = float(item["quantity"])
                unit_price = int(item["sell_price"])
                line_profit = int(item["profit"])
                total_amount += int(round(qty * unit_price))
                total_profit += int(round(qty * line_profit))

            # generate receipt ID from date
            sale_date_obj = datetime.strptime(sale_date_str, "%Y-%m-%d")
            receipt_id = self.generate_receipt_id(sale_date_obj)

            # 4) Update the 'sales' row with correct totals & receipt_id
            update_query = """
                UPDATE sales
                SET total_amount = ?, total_profit = ?, receipt_id = ?
                WHERE id = ?
            """
            DatabaseManager.execute_query(
                update_query,
                (total_amount, total_profit, receipt_id, sale_id)
            )

            # 5) Emit the event => the UI's Sales Tab is presumably listening for this
            event_system.sale_added.emit(sale_id)

            return sale_id

        except Exception as e:
            logger.error(f"Error in create_sale: {str(e)}", extra={"exc_info": True})
            raise DatabaseException(f"Failed to create sale: {str(e)}")


    @db_operation(show_dialog=True)
    @handle_exceptions(NotFoundException, DatabaseException, show_dialog=True)
    def get_sale(self, sale_id: int) -> Optional[Sale]:
        sale_id = validate_integer(sale_id, min_value=1)
        query = """
        SELECT s.*, 
            COALESCE(s.receipt_id, '') as receipt_id
        FROM sales s
        WHERE s.id = ?
        """
        row = DatabaseManager.fetch_one(query, (sale_id,))
        if row:
            sale = Sale.from_db_row(row)
            sale.items = self.get_sale_items(sale_id)
            logger.info("Sale retrieved", extra={"sale_id": sale_id})
            return sale
        else:
            logger.warning("Sale not found", extra={"sale_id": sale_id})
            raise NotFoundException(f"Sale with ID {sale_id} not found")

    @staticmethod
    @lru_cache(maxsize=1)
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_all_sales() -> List[Sale]:
        logger.info("Starting get_all_sales method")
        query = """
        SELECT s.*, 
               COALESCE(s.total_amount, 0) as total_amount,
               COALESCE(s.total_profit, 0) as total_profit
        FROM sales s
        ORDER BY s.date DESC
        """
        try:
            rows = DatabaseManager.fetch_all(query)
            logger.info(f"Fetched {len(rows)} rows from database")
        except Exception as e:
            logger.error(f"Error fetching rows: {str(e)}")
            raise

        sales = []
        for row in rows:
            try:
                logger.debug(f"Processing row: {row}")
                sale = Sale.from_db_row(row)
                logger.debug(f"Created Sale object: {sale}")
                sale.items = SaleService.get_sale_items(sale.id)
                logger.debug(f"Fetched items for sale {sale.id}: {len(sale.items)} items")
                sales.append(sale)
            except Exception as e:
                logger.error(f"Error processing sale {row.get('id', 'Unknown')}: {str(e)}")
                logger.error(f"Problematic row data: {row}")

        logger.info(f"All sales retrieved: {len(sales)}")
        return sales

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_sale_items(sale_id: int) -> List[SaleItem]:
        logger.debug(f"Fetching items for sale {sale_id}")
        query = """
        SELECT si.*,
               COALESCE(si.quantity, 0) as quantity,
               COALESCE(si.price, 0) as price,
               COALESCE(si.profit, 0) as profit
        FROM sale_items si
        WHERE si.sale_id = ?
        """
        rows = DatabaseManager.fetch_all(query, (sale_id,))
        items = []
        for row in rows:
            try:
                item = SaleItem.from_db_row(row)
                items.append(item)
            except Exception as e:
                logger.error(f"Error processing sale item for sale {sale_id}: {str(e)}")
                logger.error(f"Problematic row data: {row}")
        return items

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def delete_sale(self, sale_id: int) -> None:
        sale_id = validate_integer(sale_id, min_value=1)
        items = self.get_sale_items(sale_id)

        self._revert_inventory(items)

        try:
            DatabaseManager.execute_query("DELETE FROM sale_items WHERE sale_id = ?", (sale_id,))
            DatabaseManager.execute_query("DELETE FROM sales WHERE id = ?", (sale_id,))
            logger.info("Sale deleted", extra={"sale_id": sale_id})
            event_system.sale_deleted.emit(sale_id)
            self.clear_cache()
        except Exception as e:
            logger.error("Failed to delete sale", extra={"error": str(e), "sale_id": sale_id})
            raise DatabaseException(f"Failed to delete sale: {str(e)}")

    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def update_sale(self, sale_id: int, customer_id: int, date: str, items: List[Dict[str, Any]]) -> None:
        sale_id = validate_integer(sale_id, min_value=1)
        customer_id = validate_integer(customer_id, min_value=1)
        date = validate_date(date)
        self._validate_sale_items(items)

        sale = self.get_sale(sale_id)
        if not sale:
            raise ValidationException(f"Sale with ID {sale_id} not found.")

        sale_datetime = datetime.fromisoformat(sale.date.isoformat())
        if datetime.now() - sale_datetime > timedelta(hours=96):
            raise ValidationException("Sales can only be edited within 96 hours of creation.")

        old_items = self.get_sale_items(sale_id)

        # Revert previous inventory changes
        self._revert_inventory(old_items)

        total_amount = 0
        total_profit = 0
        for item in items:
            product = self.product_service.get_product(item["product_id"])
            if product is None:
                raise ValidationException(f"Product with ID {item['product_id']} not found")
            if product.cost_price is None or product.sell_price is None:
                raise ValidationException(f"Cost/Sell price not set for product '{product.name}'")
            
            item_total = round(item["quantity"] * item["sell_price"])
            item_profit = round(item["quantity"] * (item["sell_price"] - product.cost_price))
            
            total_amount += item_total
            total_profit += item_profit

        self._update_sale(sale_id, customer_id, date, total_amount, total_profit)
        self._update_sale_items(sale_id, items)
        self._update_inventory(items)

        logger.info("Sale updated", extra={"sale_id": sale_id, "customer_id": customer_id})
        event_system.sale_updated.emit(sale_id)
        #self.clear_cache()

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_total_sales(start_date: str, end_date: str) -> int:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT COALESCE(SUM(total_amount), 0) as total
            FROM sales
            WHERE date BETWEEN ? AND ?
        """
        result = DatabaseManager.fetch_one(query, (start_date, end_date))
        total_sales = int(result["total"] if result else 0)
        logger.info("Total sales retrieved", extra={"start_date": start_date, "end_date": end_date, "total_sales": total_sales})
        return total_sales

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_total_profits(start_date: str, end_date: str) -> int:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT COALESCE(SUM(total_profit), 0) as total
            FROM sales
            WHERE date BETWEEN ? AND ?
        """
        result = DatabaseManager.fetch_one(query, (start_date, end_date))
        total_profits = int(result["total"] if result else 0)
        logger.info("Total profits retrieved", extra={"start_date": start_date, "end_date": end_date, "total_profits": total_profits})
        return total_profits

    @staticmethod
    def generate_receipt_id(sale_date: datetime) -> str:
        date_part = sale_date.strftime("%y%m%d")
        
        query = """
            SELECT MAX(SUBSTR(receipt_id, 7)) as last_number
            FROM sales
            WHERE receipt_id LIKE ?
        """
        result = DatabaseManager.fetch_one(query, (f"{date_part}%",))
        
        last_number = int(result['last_number']) if result and result['last_number'] is not None else 0
        new_number = last_number + 1
        
        return f"{date_part}{new_number:03d}"

    @db_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def generate_receipt(self, sale_id: int) -> str:
        sale_id = validate_integer(sale_id, min_value=1)
        sale = self.get_sale(sale_id)
        if not sale:
            raise ValidationException(f"Sale with ID {sale_id} not found.")

        if not sale.receipt_id:
            receipt_id = self.generate_receipt_id(sale.date)
            self._update_sale_receipt_id(sale_id, receipt_id)
            sale.receipt_id = receipt_id
        else:
            receipt_id = sale.receipt_id

        logger.info("Receipt generated", extra={"sale_id": sale_id, "receipt_id": receipt_id})
        return receipt_id

    @db_operation(show_dialog=True)
    def _update_sale_receipt_id(self, sale_id: int, receipt_id: str) -> None:
        sale_id = validate_integer(sale_id, min_value=1)
        receipt_id = validate_string(receipt_id, max_length=20)
        query = "UPDATE sales SET receipt_id = ? WHERE id = ?"
        DatabaseManager.execute_query(query, (receipt_id, sale_id))

    @handle_exceptions(ValidationException, DatabaseException, show_dialog=True)
    def save_receipt_as_pdf(self, sale_id: int, filepath: str) -> None:
        sale_id = validate_integer(sale_id, min_value=1)
        filepath = validate_string(filepath, max_length=255)
        sale = self.get_sale(sale_id)
        if not sale:
            raise ValidationException(f"Sale with ID {sale_id} not found.")

        items = self.get_sale_items(sale_id)
        
        c = canvas.Canvas(filepath, pagesize=letter)
        width, height = letter

        # Set up the document
        c.setFont("Helvetica-Bold", 16)
        c.drawString(50, height - 50, f"Receipt #{sale.receipt_id}")
        
        c.setFont("Helvetica", 12)
        c.drawString(50, height - 80, f"Date: {sale.date.strftime('%Y-%m-%d')}")
        c.drawString(50, height - 100, f"Customer ID: {sale.customer_id}")

        # Draw items
        y = height - 150
        c.drawString(50, y, "Product")
        c.drawString(250, y, "Quantity")
        c.drawString(350, y, "Price")
        c.drawString(450, y, "Total")

        y -= 20
        for item in items:
            c.drawString(50, y, item.product_name or f"Product ID: {item.product_id}")
            c.drawString(250, y, str(item.quantity))
            c.drawString(350, y, f"${item.unit_price:,}".replace(',', '.'))
            c.drawString(450, y, f"${item.total_price():,}".replace(',', '.'))
            y -= 20

        c.drawString(350, y - 20, "Total:")
        c.drawString(450, y - 20, f"${sale.total_amount:,}".replace(',', '.'))

        c.drawString(350, y - 40, "Profit:")
        c.drawString(450, y - 40, f"${sale.total_profit:,}".replace(',', '.'))

        c.save()
        logger.info("Receipt saved as PDF", extra={"sale_id": sale_id, "filepath": filepath})

    @handle_exceptions(DatabaseException, show_dialog=True)
    def send_receipt_via_whatsapp(self, sale_id: int, phone_number: str) -> None:
        sale_id = validate_integer(sale_id, min_value=1)
        phone_number = validate_string(phone_number, max_length=20)
        # This is a placeholder. You'll need to implement the actual WhatsApp API integration.
        logger.info("Sending receipt via WhatsApp", extra={"sale_id": sale_id, "phone_number": phone_number})

    def clear_cache(self):
        """Clear the sale cache."""
        SaleService.get_all_sales.cache_clear()
        logger.debug("Sale cache cleared")

    def _validate_sale_items(self, items: List[Dict[str, Any]]) -> None:
        if not items:
            raise ValidationException("Sale must have at least one item")
        for item in items:
            try:
                # Validate quantity as float with 3 decimal places
                quantity = validate_float(float(item["quantity"]), min_value=0.001)
                if round(quantity, 3) != quantity:
                    raise ValidationException("Quantity cannot have more than 3 decimal places")
                
                # Validate price as integer
                sell_price = validate_integer(item["sell_price"], min_value=1)
                if not isinstance(sell_price, int):
                    raise ValidationException("Item sell price must be an integer")
                
            except (ValueError, TypeError):
                raise ValidationException("Invalid quantity or price format")

    @staticmethod
    @db_operation(show_dialog=True)
    def _insert_sale_items(sale_id: int, items: List[Dict[str, Any]]) -> None:
        for item in items:
            # Convert float quantity to string for storage
            quantity_str = str(round(float(item["quantity"]), 3))  # Ensure 3 decimal places
            query = """
                INSERT INTO sale_items (sale_id, product_id, quantity, price, profit)
                VALUES (?, ?, ?, ?, ?)
            """
            DatabaseManager.execute_query(
                query,
                (sale_id, item["product_id"], quantity_str, item["sell_price"], item["profit"])
            )

    def _update_inventory(self, items: List[Dict[str, Any]]) -> None:
        for item in items:
            quantity_change = -abs(float(item["quantity"]))  # Ensure float for quantity
            self.inventory_service.update_quantity(item["product_id"], quantity_change)
            logger.debug(f"Updating inventory for product {item['product_id']}, change: {quantity_change}")

    @staticmethod
    def _revert_inventory(items: List[SaleItem]) -> None:
        for item in items:
            InventoryService.update_quantity(item.product_id, item.quantity)

    @staticmethod
    @db_operation(show_dialog=True)
    def _update_sale(sale_id: int, customer_id: int, date: str, total_amount: int, total_profit: int) -> None:
        query = "UPDATE sales SET customer_id = ?, date = ?, total_amount = ?, total_profit = ? WHERE id = ?"
        DatabaseManager.execute_query(query, (customer_id, date, total_amount, total_profit, sale_id))

    @staticmethod
    @db_operation(show_dialog=True)
    def _update_sale_items(sale_id: int, items: List[Dict[str, Any]]) -> None:
        DatabaseManager.execute_query("DELETE FROM sale_items WHERE sale_id = ?", (sale_id,))
        SaleService._insert_sale_items(sale_id, items)

    @staticmethod
    @db_operation(show_dialog=True)
    def get_top_selling_products(
        start_date: str, end_date: str, limit: int = 10
    ) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        limit = validate_integer(limit, min_value=1)
        query = """
            SELECT p.id, p.name, SUM(si.quantity) as total_quantity, SUM(si.quantity * si.price) as total_revenue
            FROM products p
            JOIN sale_items si ON p.id = si.product_id
            JOIN sales s ON si.sale_id = s.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY p.id
            ORDER BY total_quantity DESC
            LIMIT ?
        """
        result = DatabaseManager.fetch_all(query, (start_date, end_date, limit))
        logger.info("Top selling products retrieved", extra={"start_date": start_date, "end_date": end_date, "limit": limit, "count": len(result)})
        return result

    @staticmethod
    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_total_sales_by_customer(customer_id: int) -> int:
        customer_id = validate_integer(customer_id, min_value=1)
        query = """
            SELECT COALESCE(SUM(total_amount), 0) as total
            FROM sales
            WHERE customer_id = ?
        """
        result = DatabaseManager.fetch_one(query, (customer_id,))
        total_sales = int(result["total"] if result else 0)
        logger.info("Total sales by customer retrieved", extra={"customer_id": customer_id, "total_sales": total_sales})
        return total_sales

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_sales_by_date_range(self, start_date: str, end_date: str) -> List[Sale]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT * FROM sales
            WHERE date BETWEEN ? AND ?
            ORDER BY date DESC
        """
        rows = DatabaseManager.fetch_all(query, (start_date, end_date))
        sales = [Sale.from_db_row(row) for row in rows]
        for sale in sales:
            sale.items = self.get_sale_items(sale.id)
        logger.info("Sales by date range retrieved", extra={"start_date": start_date, "end_date": end_date, "count": len(sales)})
        return sales

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_daily_sales_report(self, date: str) -> Dict[str, Any]:
        date = validate_date(date)
        query = """
            SELECT 
                COUNT(*) as total_sales,
                COALESCE(SUM(total_amount), 0) as total_revenue,
                COALESCE(AVG(total_amount), 0) as average_sale_amount,
                COALESCE(SUM(total_profit), 0) as total_profit
            FROM sales
            WHERE date = ?
        """
        result = DatabaseManager.fetch_one(query, (date,))
        report = {
            "date": date,
            "total_sales": 0,
            "total_revenue": 0,
            "average_sale_amount": 0,
            "total_profit": 0
        }
        if result:
            report.update({
                "total_sales": result.get("total_sales", 0),
                "total_revenue": int(result.get("total_revenue", 0)),
                "average_sale_amount": int(result.get("average_sale_amount", 0)),
                "total_profit": int(result.get("total_profit", 0))
            })
        logger.info("Daily sales report generated", extra={"date": date, "report": report})
        return report

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_sales_by_product(self, product_id: int, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        product_id = validate_integer(product_id, min_value=1)
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT s.date, si.quantity, si.price, si.profit
            FROM sale_items si
            JOIN sales s ON si.sale_id = s.id
            WHERE si.product_id = ? AND s.date BETWEEN ? AND ?
            ORDER BY s.date
        """
        rows = DatabaseManager.fetch_all(query, (product_id, start_date, end_date))
        sales = [{"date": row["date"], "quantity": row["quantity"], "price": row["price"], "profit": row["profit"]} for row in rows]
        logger.info("Sales by product retrieved", extra={"product_id": product_id, "start_date": start_date, "end_date": end_date, "count": len(sales)})
        return sales

    @db_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, show_dialog=True)
    def get_sales_distribution_by_category(self, start_date: str, end_date: str) -> List[Dict[str, Any]]:
        start_date = validate_date(start_date)
        end_date = validate_date(end_date)
        query = """
            SELECT 
                c.name as category_name,
                COUNT(DISTINCT s.id) as sale_count,
                SUM(si.quantity * si.price) as total_revenue,
                SUM(si.profit) as total_profit
            FROM sales s
            JOIN sale_items si ON s.id = si.sale_id
            JOIN products p ON si.product_id = p.id
            LEFT JOIN categories c ON p.category_id = c.id
            WHERE s.date BETWEEN ? AND ?
            GROUP BY c.id
            ORDER BY total_revenue DESC
        """
        rows = DatabaseManager.fetch_all(query, (start_date, end_date))
        distribution = [{
            "category_name": row["category_name"] or "Uncategorized", 
            "sale_count": row["sale_count"], 
            "total_revenue": int(row["total_revenue"]),
            "total_profit": int(row["total_profit"])
        } for row in rows]
        logger.info("Sales distribution by category retrieved", extra={"start_date": start_date, "end_date": end_date, "count": len(distribution)})
        return distribution

    @lru_cache(maxsize=100)
    def get_product_details(self, product_id: int) -> Optional[Dict[str, Any]]:
        product = self.product_service.get_product(product_id)
        return product.to_dict() if product else None

    def calculate_total_amount(self, items: List[Dict[str, Any]]) -> int:
        """Calculate total amount for a sale."""
        return sum(int(item['quantity'] * item['sell_price']) for item in items)

    def calculate_total_profit(self, items: List[Dict[str, Any]]) -> int:
        """Calculate total profit for a sale."""
        return sum(int(item['profit']) for item in items)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/services/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/analytics_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QSpinBox, QTableWidgetItem,
    QDateEdit, QComboBox, QLineEdit, QFormLayout, QProgressBar, QApplication,
)
from PySide6.QtCore import Qt, QDate, QTimer
from PySide6.QtGui import QPainter, QAction, QKeySequence
from PySide6.QtCharts import (
    QChart, QChartView, QBarSeries, QBarSet, QValueAxis, QBarCategoryAxis,
    QLineSeries, QDateTimeAxis, QPieSeries,
)
from services.analytics_service import AnalyticsService
from utils.helpers import create_table,  format_price
from utils.ui.table_items import (
    NumericTableWidgetItem, PriceTableWidgetItem, PercentageTableWidgetItem,
)
from typing import List, Dict, Any
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_date, validate_integer
from utils.system.logger import logger

class AnalyticsView(QWidget):
    def __init__(self):
        super().__init__()
        self.analytics_service = AnalyticsService()
        self.setup_ui()
        self.setup_update_timer()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Date range selection
        date_layout = QHBoxLayout()
        self.start_date = QDateEdit()
        self.start_date.setDate(QDate.currentDate().addDays(-30))
        self.start_date.setCalendarPopup(True)
        self.end_date = QDateEdit()
        self.end_date.setDate(QDate.currentDate())
        self.end_date.setCalendarPopup(True)
        date_layout.addWidget(QLabel("Start Date:"))
        date_layout.addWidget(self.start_date)
        date_layout.addWidget(QLabel("End Date:"))
        date_layout.addWidget(self.end_date)
        layout.addLayout(date_layout)

        # Analytics type selection
        self.analytics_type = QComboBox()
        self.analytics_type.addItems([
            "Sales by Weekday",
            "Top Selling Products",
            "Sales Trend",
            "Category Performance",
            "Profit by Product",
            "Profit Trend",
            "Profit Margin Distribution",
        ])
        layout.addWidget(QLabel("Select Analysis:"))
        layout.addWidget(self.analytics_type)

        # Additional parameters
        self.params_layout = QFormLayout()
        self.top_n_spinbox = QSpinBox()
        self.top_n_spinbox.setRange(1, 100)
        self.top_n_spinbox.setValue(10)
        self.params_layout.addRow("Top N:", self.top_n_spinbox)
        layout.addLayout(self.params_layout)

        # Generate button
        generate_btn = QPushButton("Generate Analytics")
        generate_btn.clicked.connect(self.generate_analytics)
        layout.addWidget(generate_btn)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)

        # Table for displaying results
        self.result_table = create_table([])
        layout.addWidget(self.result_table)

        # Chart view
        self.chart_view = QChartView()
        self.chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)
        layout.addWidget(self.chart_view)

        # Summary text
        self.summary_text = QLineEdit()
        self.summary_text.setReadOnly(True)
        layout.addWidget(self.summary_text)

        # Set up shortcuts
        self.setup_shortcuts()

    def setup_shortcuts(self):
        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.generate_analytics)
        self.addAction(refresh_shortcut)

    def setup_update_timer(self):
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self.update_analytics)
        self.update_timer.start(300000)  # Update every 5 minutes

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def generate_analytics(self):
        self.progress_bar.setValue(0)
        analytics_type = self.analytics_type.currentText()
        start_date = validate_date(self.start_date.date().toString("yyyy-MM-dd"))
        end_date = validate_date(self.end_date.date().toString("yyyy-MM-dd"))
        top_n = validate_integer(self.top_n_spinbox.value(), min_value=1, max_value=100)

        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            analytics_functions = {
                "Sales by Weekday": lambda: self.show_sales_by_weekday(start_date, end_date),
                "Top Selling Products": lambda: self.show_top_selling_products(start_date, end_date, top_n),
                "Sales Trend": lambda: self.show_sales_trend(start_date, end_date),
                "Category Performance": lambda: self.show_category_performance(start_date, end_date),
                "Profit by Product": lambda: self.show_profit_by_product(start_date, end_date, top_n),
                "Profit Trend": lambda: self.show_profit_trend(start_date, end_date),
                "Profit Margin Distribution": lambda: self.show_profit_margin_distribution(start_date, end_date),
            }

            if analytics_type in analytics_functions:
                QTimer.singleShot(0, analytics_functions[analytics_type])
            else:
                raise ValidationException(f"Unknown analytics type: {analytics_type}")
        except Exception as e:
            logger.error(f"Error generating analytics: {str(e)}")
            raise UIException(f"Failed to generate analytics: {str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

        self.progress_bar.setValue(100)

    def update_analytics(self):
        self.generate_analytics()

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_sales_by_weekday(self, start_date: str, end_date: str):
        try:
            sales_by_weekday = self.analytics_service.get_sales_by_weekday(start_date, end_date)
            self._populate_table_and_chart(
                sales_by_weekday,
                ["Weekday", "Total Sales"],
                "weekday",
                "total_sales",
                "Sales by Weekday",
            )
            total_sales = sum(day["total_sales"] for day in sales_by_weekday)
            avg_daily_sales = total_sales / 7 if len(sales_by_weekday) == 7 else 0
            self.summary_text.setText(
                f"Total sales: {format_price(total_sales)}, Average daily sales: {format_price(avg_daily_sales)}"
            )
            logger.info(f"Displayed sales by weekday analysis: {len(sales_by_weekday)} days")
        except Exception as e:
            logger.error(f"Error showing sales by weekday: {str(e)}")
            raise DatabaseException(f"Failed to show sales by weekday: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_top_selling_products(self, start_date: str, end_date: str, top_n: int):
        try:
            top_products = self.analytics_service.get_top_selling_products(start_date, end_date, top_n)
            self._populate_table_and_chart(
                top_products,
                ["Product ID", "Product Name", "Total Quantity", "Total Revenue"],
                "name",
                "total_quantity",
                "Top Selling Products",
            )
            total_quantity = sum(p["total_quantity"] for p in top_products)
            total_revenue = sum(p["total_revenue"] for p in top_products)
            self.summary_text.setText(
                f"Total quantity sold: {total_quantity}, Total revenue: ${total_revenue:.0f}"
            )
            logger.info(f"Displayed top selling products analysis: {len(top_products)} products")
        except Exception as e:
            logger.error(f"Error showing top selling products: {str(e)}")
            raise DatabaseException(f"Failed to show top selling products: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_sales_trend(self, start_date: str, end_date: str):
        try:
            sales_trend = self.analytics_service.get_sales_trend(start_date, end_date)
            self._populate_table_and_chart(
                sales_trend,
                ["Date", "Daily Sales"],
                "date",
                "daily_sales",
                "Sales Trend",
                chart_type="line",
            )
            total_sales = sum(day["daily_sales"] for day in sales_trend)
            avg_daily_sales = total_sales / len(sales_trend) if sales_trend else 0
            self.summary_text.setText(
                f"Total sales: ${total_sales}, Average daily sales: ${avg_daily_sales:.0f}"
            )
            logger.info(f"Displayed sales trend analysis: {len(sales_trend)} days")
        except Exception as e:
            logger.error(f"Error showing sales trend: {str(e)}")
            raise DatabaseException(f"Failed to show sales trend: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_category_performance(self, start_date: str, end_date: str):
        try:
            category_performance = self.analytics_service.get_category_performance(start_date, end_date)
            self._populate_table_and_chart(
                category_performance,
                ["Category", "Total Sales", "Number of Products Sold"],
                "category",
                "total_sales",
                "Category Performance",
            )
            total_sales = sum(c["total_sales"] for c in category_performance)
            total_products_sold = sum(c["number_of_products_sold"] for c in category_performance)
            self.summary_text.setText(
                f"Total sales: ${total_sales:.0f}, Total products sold: {total_products_sold}"
            )
            logger.info(f"Displayed category performance analysis: {len(category_performance)} categories")
        except Exception as e:
            logger.error(f"Error showing category performance: {str(e)}")
            raise DatabaseException(f"Failed to show category performance: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_profit_by_product(self, start_date: str, end_date: str, top_n: int):
        try:
            profit_by_product = self.analytics_service.get_profit_by_product(start_date, end_date, top_n)
            self._populate_table_and_chart(
                profit_by_product,
                ["Product ID", "Product Name", "Total Revenue", "Total Cost", "Total Profit"],
                "name",
                "total_profit",
                "Profit by Product",
            )
            total_revenue = sum(p["total_revenue"] for p in profit_by_product)
            total_profit = sum(p["total_profit"] for p in profit_by_product)
            self.summary_text.setText(
                f"Total revenue: ${total_revenue:.0f}, Total profit: ${total_profit:.0f}"
            )
            logger.info(f"Displayed profit by product analysis: {len(profit_by_product)} products")
        except Exception as e:
            logger.error(f"Error showing profit by product: {str(e)}")
            raise DatabaseException(f"Failed to show profit by product: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_profit_trend(self, start_date: str, end_date: str):
        try:
            profit_trend = self.analytics_service.get_profit_trend(start_date, end_date)
            self._populate_table_and_chart(
                profit_trend,
                ["Date", "Daily Revenue", "Daily Profit"],
                "date",
                "daily_profit",
                "Profit Trend",
                chart_type="line",
            )
            total_revenue = sum(day["daily_revenue"] for day in profit_trend)
            total_profit = sum(day["daily_profit"] for day in profit_trend)
            self.summary_text.setText(
                f"Total revenue: ${total_revenue:.0f}, Total profit: ${total_profit:.0f}"
            )
            logger.info(f"Displayed profit trend analysis: {len(profit_trend)} days")
        except Exception as e:
            logger.error(f"Error showing profit trend: {str(e)}")
            raise DatabaseException(f"Failed to show profit trend: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def show_profit_margin_distribution(self, start_date: str, end_date: str):
        try:
            margin_distribution = self.analytics_service.get_profit_margin_distribution(start_date, end_date)
            self._populate_table_and_chart(
                margin_distribution,
                ["Margin Range", "Product Count", "Average Margin"],
                "margin_range",
                "product_count",
                "Profit Margin Distribution",
                chart_type="pie",
            )
            total_products = sum(d["product_count"] for d in margin_distribution)
            weighted_avg_margin = sum(d["product_count"] * d["average_margin"] for d in margin_distribution) / total_products if total_products > 0 else 0
            self.summary_text.setText(
                f"Total products: {total_products}, Weighted average profit margin: {weighted_avg_margin:.2f}%"
            )
            logger.info(f"Displayed profit margin distribution analysis: {len(margin_distribution)} ranges")
        except Exception as e:
            logger.error(f"Error showing profit margin distribution: {str(e)}")
            raise DatabaseException(f"Failed to show profit margin distribution: {str(e)}")

    def _populate_table_and_chart(
        self,
        data: List[Dict[str, Any]],
        headers: List[str],
        x_key: str,
        y_key: str,
        title: str,
        chart_type: str = "bar",
    ):
        # Populate table
        self.result_table.setColumnCount(len(headers))
        self.result_table.setHorizontalHeaderLabels(headers)
        self.result_table.setRowCount(len(data))
        for row, item in enumerate(data):
            for col, header in enumerate(headers):
                key = header.lower().replace(" ", "_")
                value = item.get(key, "")
                if isinstance(value, (int, float)):
                    if header.lower().endswith("price") or header.lower().endswith("revenue") or header.lower().endswith("sales") or header.lower().endswith("profit"):
                        self.result_table.setItem(row, col, PriceTableWidgetItem(value, format_price))
                    elif header.lower().endswith("margin"):
                        self.result_table.setItem(row, col, PercentageTableWidgetItem(value))
                    else:
                        self.result_table.setItem(row, col, NumericTableWidgetItem(value))
                else:
                    self.result_table.setItem(row, col, QTableWidgetItem(str(value)))

        # Create chart
        chart = QChart()
        if chart_type == "bar":
            series = QBarSeries()
            bar_set = QBarSet("")
            categories = []
            for item in data:
                bar_set.append(item[y_key])
                categories.append(str(item[x_key]))
            series.append(bar_set)
            chart.addSeries(series)
            axis_x = QBarCategoryAxis()
            axis_x.append(categories)
            chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
            series.attachAxis(axis_x)
        elif chart_type == "line":
            series = QLineSeries()
            for item in data:
                date = QDate.fromString(item[x_key], "yyyy-MM-dd")
                series.append(date.startOfDay().toMSecsSinceEpoch(), item[y_key])
            chart.addSeries(series)

            axis_x = QDateTimeAxis()
            axis_x.setFormat("MMM dd")
            axis_x.setTickCount(5)
            min_date = QDate.fromString(data[0][x_key], "yyyy-MM-dd")
            max_date = QDate.fromString(data[-1][x_key], "yyyy-MM-dd")
            axis_x.setRange(min_date.startOfDay(), max_date.startOfDay())
            chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
            series.attachAxis(axis_x)
        elif chart_type == "pie":
            series = QPieSeries()
            for item in data:
                series.append(f"{item[x_key]}: {item[y_key]}", item[y_key])
            chart.addSeries(series)

        axis_y = QValueAxis()
        chart.addAxis(axis_y, Qt.AlignmentFlag.AlignLeft)
        if chart_type != "pie":
            series.attachAxis(axis_y)

        chart.setTitle(title)
        self.chart_view.setChart(chart)

    def refresh(self):
        self.generate_analytics()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_F5:
            self.refresh()
        else:
            super().keyPressEvent(event)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/category_management_dialog.py:
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QPushButton, QMessageBox,
    QLineEdit, QFormLayout, QDialogButtonBox, QLabel,
)
from PySide6.QtCore import Qt
from services.category_service import CategoryService
from utils.system.logger import logger
from utils.helpers import show_info_message
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_string
from utils.system.event_system import event_system

class AddEditCategoryDialog(QDialog):
    def __init__(self, parent=None, category=None):
        super().__init__(parent)
        self.category = category
        self.category_service = CategoryService()
        self.setWindowTitle("Add Category" if category is None else "Edit Category")
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit(self.category.name if self.category else "")
        layout.addRow("Category Name:", self.name_input)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def accept(self):
        name = validate_string(self.name_input.text().strip(), min_length=1, max_length=50)
        if self.category:
            self.category_service.update_category(self.category.id, name)
            logger.info(f"Category updated: ID {self.category.id}, Name: {name}")
        else:
            category_id = self.category_service.create_category(name)
            logger.info(f"Category created: ID {category_id}, Name: {name}")
        super().accept()

class CategoryManagementDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.category_service = CategoryService()
        self.setup_ui()
        self.setWindowTitle("Category Management")

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Search bar
        search_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search categories...")
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_categories)
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(search_button)
        layout.addLayout(search_layout)

        # Category list
        self.category_list = QListWidget()
        layout.addWidget(self.category_list)

        # Buttons
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Category")
        add_button.clicked.connect(self.add_category)
        edit_button = QPushButton("Edit Category")
        edit_button.clicked.connect(self.edit_category)
        delete_button = QPushButton("Delete Category")
        delete_button.clicked.connect(self.delete_category)

        button_layout.addWidget(add_button)
        button_layout.addWidget(edit_button)
        button_layout.addWidget(delete_button)

        layout.addLayout(button_layout)

        # Status label
        self.status_label = QLabel()
        layout.addWidget(self.status_label)

        self.load_categories()

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_categories(self):
        try:
            self.category_list.clear()
            categories = self.category_service.get_all_categories()
            for category in categories:
                self.category_list.addItem(category.name)
            self.update_status(f"Loaded {len(categories)} categories")
            logger.info(f"Loaded {len(categories)} categories")
        except Exception as e:
            logger.error(f"Error loading categories: {str(e)}")
            raise DatabaseException(f"Failed to load categories: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def add_category(self):
        dialog = AddEditCategoryDialog(self)
        if dialog.exec():
            self.load_categories()
            show_info_message("Success", "Category added successfully.")
            event_system.category_added.emit()
            logger.info("New category added")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_category(self):
        current_item = self.category_list.currentItem()
        if current_item:
            category = self.category_service.get_category_by_name(current_item.text())
            if category:
                dialog = AddEditCategoryDialog(self, category)
                if dialog.exec():
                    self.load_categories()
                    show_info_message("Success", "Category updated successfully.")
                    event_system.category_updated.emit(category.id)
                    logger.info(f"Category updated: ID {category.id}")
            else:
                raise ValidationException(f"Category '{current_item.text()}' not found")
        else:
            raise ValidationException("Please select a category to edit.")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_category(self):
        current_item = self.category_list.currentItem()
        if current_item:
            reply = QMessageBox.question(
                self,
                "Delete Category",
                f"Are you sure you want to delete the category '{current_item.text()}'?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            if reply == QMessageBox.StandardButton.Yes:
                category = self.category_service.get_category_by_name(current_item.text())
                if category:
                    self.category_service.delete_category(category.id)
                    self.load_categories()
                    show_info_message("Success", "Category deleted successfully.")
                    event_system.category_deleted.emit(category.id)
                    logger.info(f"Category deleted: ID {category.id}")
                else:
                    raise ValidationException(f"Category '{current_item.text()}' not found")
        else:
            raise ValidationException("Please select a category to delete.")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def search_categories(self):
        search_term = validate_string(self.search_input.text().strip(), max_length=50)
        if search_term:
            categories = self.category_service.search_categories(search_term)
            self.category_list.clear()
            for category in categories:
                self.category_list.addItem(category.name)
            self.update_status(f"Found {len(categories)} categories matching '{search_term}'")
            logger.info(f"Searched categories: {len(categories)} results")
        else:
            self.load_categories()

    def update_status(self, message: str):
        self.status_label.setText(message)
        logger.info(message)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/customer_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
    QTableWidget, QTableWidgetItem, QMessageBox, QDialog, QDialogButtonBox, 
    QFormLayout, QHeaderView, QMenu, QApplication
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QKeySequence
from services.customer_service import CustomerService
from utils.helpers import create_table, show_error_message, show_info_message, format_price
from utils.system.event_system import event_system
from utils.ui.table_items import NumericTableWidgetItem, PriceTableWidgetItem, DepartmentIdentifierTableWidgetItem
from typing import Optional, List
from models.customer import Customer
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_string
from utils.system.logger import logger

class EditCustomerDialog(QDialog):
    def __init__(self, customer: Optional[Customer], parent=None):
        super().__init__(parent)
        self.customer = customer
        self.setWindowTitle("Edit Customer" if customer else "Add Customer")
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)

        # 9-digit identifier
        self.identifier_9_input = QLineEdit(
            self.customer.identifier_9 if self.customer else ""
        )
        self.identifier_9_input.setPlaceholderText("Enter 9-digit identifier")
        layout.addRow("9-digit Identifier:", self.identifier_9_input)

        # 3 or 4-digit identifier
        self.identifier_3or4_input = QLineEdit(
            self.customer.identifier_3or4 or "" if self.customer else ""
        )
        self.identifier_3or4_input.setPlaceholderText("Enter 3 or 4-digit identifier (optional)")
        layout.addRow("3 or 4-digit Identifier:", self.identifier_3or4_input)

        # Name field
        self.name_input = QLineEdit(
            self.customer.name or "" if self.customer else ""
        )
        self.name_input.setPlaceholderText("Enter customer name (optional)")
        layout.addRow("Name:", self.name_input)

        # Add help text for name requirements
        name_help = QLabel("Name can contain letters, accented characters, and spaces (max 50 chars)")
        name_help.setStyleSheet("color: gray; font-size: 10px;")
        layout.addRow("", name_help)

        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, show_dialog=True)
    def validate_and_accept(self):
        try:
            # Create a temporary customer to validate the input
            temp_customer = Customer(
                id=0,
                identifier_9=self.identifier_9_input.text().strip(),
                identifier_3or4=self.identifier_3or4_input.text().strip() or None,
                name=self.name_input.text().strip() or None
            )
            self.accept()
        except ValidationException as e:
            raise ValidationException(str(e))

class CustomerView(QWidget):
    customer_updated = Signal()

    def __init__(self):
        super().__init__()
        self.customer_service = CustomerService()
        self.setup_ui()
        # Connect signals
        event_system.customer_added.connect(self.load_customers)

    def cleanup(self):
        """Cleanup method to properly disconnect signals."""
        try:
            event_system.customer_added.disconnect(self.load_customers)
        except Exception:
            pass  # Ignore disconnection errors during cleanup

    def closeEvent(self, event):
        """Handle widget close event."""
        self.cleanup()
        super().closeEvent(event)

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Search field
        search_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search by ID or name...")
        self.search_input.returnPressed.connect(self.search_customers)
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_customers)
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(search_button)
        layout.addLayout(search_layout)

        # Customer table
        self.customer_table = create_table(
            [
                "ID",
                "9-digit Identifier",
                "3 or 4-digit Identifier",
                "Name",
                "Total Purchases",
                "Total Amount",
                "Actions",
            ]
        )
        self.customer_table.setSelectionBehavior(
            QTableWidget.SelectionBehavior.SelectRows
        )
        self.customer_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.customer_table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )
        self.customer_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customer_table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.customer_table)

        # Add customer button
        add_button = QPushButton("Add Customer")
        add_button.clicked.connect(self.add_customer)
        add_button.setToolTip("Add a new customer (Ctrl+N)")
        layout.addWidget(add_button)

        self.load_customers()

        # Set up shortcuts
        self.setup_shortcuts()

        # Connect to event system
        event_system.customer_added.connect(self.load_customers)
        event_system.customer_updated.connect(self.load_customers)
        event_system.customer_deleted.connect(self.load_customers)

    def setup_shortcuts(self):
        add_shortcut = QAction("Add Customer", self)
        add_shortcut.setShortcut(QKeySequence("Ctrl+N"))
        add_shortcut.triggered.connect(self.add_customer)
        self.addAction(add_shortcut)

        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.load_customers)
        self.addAction(refresh_shortcut)

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_customers(self, _ignored_id=None) -> None:
        """
        Load all customers into the table (re-fetch from the DB).
        _ignored_id is an unused parameter (emitted by the signal).
        """
        logger.debug(f"(load_customers) Called with _ignored_id={_ignored_id}")

        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            # Force a fresh read from DB
            self.customer_service.clear_cache()
            customers = self.customer_service.get_all_customers()
            logger.debug(f"(load_customers) Fetched {len(customers)} customers from DB")

            # Now populate the table
            self.populate_customer_table(customers)

        except Exception as e:
            logger.error(f"(load_customers) Error loading customers: {str(e)}")
            show_error_message("Error", f"Failed to load customers: {str(e)}")

        finally:
            QApplication.restoreOverrideCursor()


        """
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)

            # [New Log 2] Log that we're about to force cache clear (if you do that)
            self.customer_service.clear_cache()
            logger.debug("(load_customers) Cache cleared before fetching all customers")

            # [New Log 3] Log the call to get all customers
            logger.debug("(load_customers) Calling get_all_customers() now")
            customers = self.customer_service.get_all_customers()

            # [New Log 4] Log how many customers were fetched
            logger.debug(f"(load_customers) Received {len(customers)} customers from DB")

            # 1) Clear the table first (in case it was partially populated)
            self.customer_table.setRowCount(0)

            # 2) Populate
            logger.debug("(load_customers) About to populate_customer_table(...)")
            self.populate_customer_table(customers)
            logger.debug("(load_customers) Finished populate_customer_table(...)")

        except Exception as e:
            logger.error(f"(load_customers) Error loading customers: {str(e)}", exc_info=True)
            raise UIException(f"Failed to load customers: {str(e)}")

        finally:
            QApplication.restoreOverrideCursor()
        """


    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def populate_customer_table(self, customers: List[Customer]) -> None:
        """
        Populate the customer table with a list of Customer objects,
        ensuring stable row→customer_id mapping and preserving any pre-existing sort.
        """
        try:
            logger.debug(f"(populate_customer_table) Starting with {len(customers)} raw customers")

            # 1) Capture the current sorting state (column + order) if any
            prev_col = self.customer_table.horizontalHeader().sortIndicatorSection()
            prev_order = self.customer_table.horizontalHeader().sortIndicatorOrder()

            # 2) Disable sorting while we repopulate rows
            self.customer_table.setSortingEnabled(False)

            # 3) Deduplicate or transform as needed
            displayed_ids = set()
            unique_customers = []
            for cust in customers:
                if cust.id not in displayed_ids:
                    unique_customers.append(cust)
                    displayed_ids.add(cust.id)
                else:
                    logger.warning(f"Skipping duplicate customer ID: {cust.id}")

            logger.debug(f"(populate_customer_table) Unique customers count: {len(unique_customers)}")

            # 4) Clear old rows, set to new count
            self.customer_table.setRowCount(0)
            self.customer_table.setRowCount(len(unique_customers))

            # 5) Fill each row
            for row, cust in enumerate(unique_customers):
                try:
                    total_purchases, total_amount = self.customer_service.get_customer_stats(cust.id)

                    # Column 0: Customer ID
                    self.customer_table.setItem(row, 0, NumericTableWidgetItem(cust.id))

                    # Column 1: 9-digit Identifier
                    self.customer_table.setItem(row, 1, QTableWidgetItem(cust.identifier_9))

                    # Column 2: 3 or 4-digit Identifier
                    identifier_item = DepartmentIdentifierTableWidgetItem(cust.identifier_3or4 or "N/A")
                    self.customer_table.setItem(row, 2, identifier_item)

                    # Column 3: Name
                    name_item = QTableWidgetItem(cust.name or "")
                    name_item.setToolTip(cust.name if cust.name else "No name provided")
                    self.customer_table.setItem(row, 3, name_item)

                    # Column 4: Total Purchases
                    self.customer_table.setItem(row, 4, NumericTableWidgetItem(total_purchases))

                    # Column 5: Total Amount
                    self.customer_table.setItem(
                        row, 5, PriceTableWidgetItem(total_amount, format_price)
                    )

                    # Column 6: Actions (Edit / Delete)
                    actions_widget = QWidget()
                    actions_layout = QHBoxLayout(actions_widget)
                    actions_layout.setContentsMargins(0, 0, 0, 0)

                    edit_button = QPushButton("Edit")
                    edit_button.setFixedWidth(50)
                    edit_button.clicked.connect(lambda _, cid=cust.id: self.edit_customer_by_id(cid))

                    delete_button = QPushButton("Delete")
                    delete_button.setFixedWidth(50)
                    delete_button.clicked.connect(lambda _, cid=cust.id: self.delete_customer_by_id(cid))

                    actions_layout.addWidget(edit_button)
                    actions_layout.addWidget(delete_button)
                    self.customer_table.setCellWidget(row, 6, actions_widget)

                except Exception as row_error:
                    logger.error(f"Error filling row {row} for customer {cust.id}: {row_error}")
                    continue

            # 6) Resize columns for a neat look
            self.customer_table.resizeColumnsToContents()

            # 7) Re-enable sorting
            self.customer_table.setSortingEnabled(True)

            # 8) Restore the previous sort (column + order), so if the user
            #    had it sorted by column #2 descending, it stays that way.
            self.customer_table.sortItems(prev_col, prev_order)

            logger.debug(f"(populate_customer_table) Finished with {len(unique_customers)} rows")

        except Exception as e:
            logger.error(f"Error populating customer table: {str(e)}")
            raise UIException(f"Failed to populate customer table: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_customer_by_id(self, customer_id: int):
        """
        Edit a customer identified by customer_id.
        This approach always re-fetches from DB, ensuring correct data
        even if the table was sorted or partially re-drawn.
        """
        logger.debug(f"[edit_customer_by_id] Editing customer with ID={customer_id}")
        try:
            customer = self.customer_service.get_customer(customer_id)
            if not customer:
                show_error_message("Error", f"No customer found with ID={customer_id}")
                return

            dialog = EditCustomerDialog(customer, self)
            if dialog.exec():
                # Get the new values
                new_identifier_9 = dialog.identifier_9_input.text().strip()
                new_identifier_3or4 = dialog.identifier_3or4_input.text().strip() or None
                new_name = dialog.name_input.text().strip() or None  # Changed to handle empty string case

                # Validate the name before updating
                if new_name:
                    try:
                        validate_string(new_name, max_length=50)
                    except ValidationException as e:
                        show_error_message("Validation Error", str(e))
                        return

                # Update the customer
                self.customer_service.update_customer(
                    customer.id,
                    identifier_9=new_identifier_9,
                    name=new_name,
                    identifier_3or4=new_identifier_3or4
                )
                
                self.load_customers()
                show_info_message("Success", "Customer updated successfully.")
                event_system.customer_updated.emit(customer.id)
                self.customer_updated.emit()
                logger.info(f"Customer updated successfully: ID {customer.id}")
        except Exception as e:
            logger.error(f"[edit_customer_by_id] Error updating customer ID={customer_id}: {str(e)}")
            raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_customer_by_id(self, customer_id: int):
        """
        Delete a customer identified by customer_id.
        """
        logger.debug(f"[delete_customer_by_id] Deleting customer with ID={customer_id}")
        try:
            customer = self.customer_service.get_customer(customer_id)
            if not customer:
                raise ValidationException(f"Customer with ID {customer_id} not found.")

            display_name = customer.get_display_name()
            reply = QMessageBox.question(
                self,
                "Delete Customer",
                f"Are you sure you want to delete customer {display_name}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.customer_service.delete_customer(customer_id)
                self.load_customers()
                show_info_message("Success", "Customer deleted successfully.")
                event_system.customer_deleted.emit(customer_id)
                self.customer_updated.emit()
                logger.info(f"Customer deleted successfully: ID {customer_id}")
        except Exception as e:
            logger.error(f"[delete_customer_by_id] Error deleting customer ID={customer_id}: {str(e)}")
            raise


    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def add_customer(self):
        dialog = EditCustomerDialog(None, self)
        if dialog.exec():
            try:
                customer_id = self.customer_service.create_customer(
                    identifier_9=dialog.identifier_9_input.text().strip(),
                    name=dialog.name_input.text().strip() or None,
                    identifier_3or4=dialog.identifier_3or4_input.text().strip() or None
                )
                if customer_id is not None:
                    self.load_customers()
                    show_info_message("Success", "Customer added successfully.")
                    event_system.customer_added.emit(customer_id)
                    self.customer_updated.emit()
                    logger.info(f"Customer added successfully: ID {customer_id}")
                else:
                    raise DatabaseException("Failed to add customer.")
            except Exception as e:
                logger.error(f"Error adding customer: {str(e)}")
                raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_customer(self, customer: Optional[Customer]):
        """
        Edit a customer's info (9-digit, 3/4-digit, name).
        Updates DB, then reloads the table.
        """
        if customer is None:
            raise ValidationException("No customer selected for editing.")

        # *** new log statement ***
        logger.debug(f"[edit_customer] Starting edit for Customer ID={customer.id}, current name='{customer.name}'")

        dialog = EditCustomerDialog(customer, self)
        if dialog.exec():
            try:
                new_name = dialog.name_input.text().strip()
                # If user typed nothing, keep old name
                if not new_name:
                    new_name = customer.name
                    # *** new log statement ***
                    logger.debug(f"[edit_customer] User left name blank; reusing old name='{new_name}'")

                self.customer_service.update_customer(
                    customer.id,
                    identifier_9=dialog.identifier_9_input.text().strip(),
                    name=new_name,
                    identifier_3or4=dialog.identifier_3or4_input.text().strip() or None
                )

                # *** new log statement ***
                logger.debug(f"[edit_customer] Done updating DB for ID={customer.id}, calling load_customers() next")

                self.load_customers()

                show_info_message("Success", "Customer updated successfully.")
                event_system.customer_updated.emit(customer.id)
                self.customer_updated.emit()
                logger.info(f"Customer updated successfully: ID {customer.id}")

            except Exception as e:
                logger.error(f"[edit_customer] Error updating customer ID={customer.id}: {str(e)}")
                raise


    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_customer(self, customer: Optional[Customer]):
        if customer is None:
            raise ValidationException("No customer selected for deletion.")

        display_name = customer.get_display_name()
        reply = QMessageBox.question(
            self,
            "Delete Customer",
            f"Are you sure you want to delete customer {display_name}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )
        if reply == QMessageBox.StandardButton.Yes:
            try:
                self.customer_service.delete_customer(customer.id)
                self.load_customers()
                show_info_message("Success", "Customer deleted successfully.")
                event_system.customer_deleted.emit(customer.id)
                self.customer_updated.emit()
                logger.info(f"Customer deleted successfully: ID {customer.id}")
            except Exception as e:
                logger.error(f"Error deleting customer: {str(e)}")
                raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def search_customers(self):
        search_term = self.search_input.text().strip()
        search_term = validate_string(search_term, max_length=50)
        if search_term:
            try:
                customers = self.customer_service.search_customers(search_term)
                self.populate_customer_table(customers)
                logger.info(f"Customer search performed: '{search_term}'")
            except Exception as e:
                logger.error(f"Error searching customers: {str(e)}")
                raise
        else:
            self.load_customers()

    def show_context_menu(self, position):
        menu = QMenu()
        edit_action = menu.addAction("Edit")
        delete_action = menu.addAction("Delete")

        action = menu.exec(self.customer_table.mapToGlobal(position))
        if action:
            row = self.customer_table.rowAt(position.y())
            customer_id = self.customer_table.item(row, 0).text()
            customer = self.customer_service.get_customer(int(customer_id))

            if customer is not None:
                if action == edit_action:
                    self.edit_customer(customer)
                elif action == delete_action:
                    self.delete_customer(customer)
            else:
                show_error_message(
                    "Error", f"Customer with ID {customer_id} not found."
                )

    def refresh(self):
        self.load_customers()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Delete:
            selected_rows = self.customer_table.selectionModel().selectedRows()
            if selected_rows:
                row = selected_rows[0].row()
                customer_id = int(self.customer_table.item(row, 0).text())
                customer = self.customer_service.get_customer(customer_id)
                if customer:
                    self.delete_customer(customer)
        else:
            super().keyPressEvent(event)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/dashboard_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QFrame, QSizePolicy
)
from PySide6.QtCore import Qt, QTimer, QDate, QMargins
from PySide6.QtGui import QPainter
from PySide6.QtCharts import (
    QChart, QChartView, QBarSeries, QBarSet, QBarCategoryAxis, QValueAxis
)
from services.sale_service import SaleService
from services.purchase_service import PurchaseService
from services.inventory_service import InventoryService
from services.customer_service import CustomerService
from services.analytics_service import AnalyticsService
from datetime import datetime, timedelta
from utils.system.event_system import event_system
from utils.system.logger import logger
from utils.decorators import ui_operation
from typing import Callable, Union
from math import ceil
from utils.exceptions import UIException

class MetricWidget(QFrame):
    def __init__(self, label: str, value_func: Callable[[], Union[str, int, float]]):
        super().__init__()
        self.value_func = value_func
        self.setFrameShape(QFrame.Shape.Box)
        self.setStyleSheet("QFrame { border: 1px solid #cccccc; border-radius: 5px; }")

        layout = QVBoxLayout(self)
        self.label_widget = QLabel(label)
        self.label_widget.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.value_widget = QLabel()
        self.value_widget.setAlignment(Qt.AlignmentFlag.AlignCenter)

        layout.addWidget(self.label_widget)
        layout.addWidget(self.value_widget)

        self.update_value()
        self.setup_event_connections()

    def setup_event_connections(self):
        event_system.sale_added.connect(self.update_value)
        event_system.purchase_added.connect(self.update_value)
        event_system.inventory_changed.connect(self.update_value)

    @ui_operation()
    def update_value(self, *args):
        value = self.value_func()
        self.value_widget.setText(str(value))

class DashboardView(QWidget):
    def __init__(self):
        super().__init__()
        self.sale_service = SaleService()
        self.purchase_service = PurchaseService()
        self.inventory_service = InventoryService()
        self.customer_service = CustomerService()
        self.analytics_service = AnalyticsService()
        
        self.end_date = datetime.now()
        self.start_date = self.end_date - timedelta(days=28)  # Last 4 weeks
        
        logger.debug("Dashboard view initialized")
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Top row with key metrics
        metrics_layout = QHBoxLayout()
        metrics_layout.addWidget(MetricWidget("Total Sales", self.get_total_sales))
        metrics_layout.addWidget(MetricWidget("Total Profits", self.get_total_profits))
        metrics_layout.addWidget(MetricWidget("Inventory Value", self.get_inventory_value))
        metrics_layout.addWidget(MetricWidget("Profit Margin", self.get_profit_margin))
        layout.addLayout(metrics_layout)

        # Charts row
        self.charts_layout = QHBoxLayout()
        self.profit_trend_chart_view = self.create_profit_trend_chart()
        self.top_products_chart_view = self.create_top_products_chart()

        # Set fixed size policies for both charts
        self.profit_trend_chart_view.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.top_products_chart_view.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # Add charts to the layout with a 1:1 ratio
        self.charts_layout.addWidget(self.profit_trend_chart_view, 1)
        self.charts_layout.addWidget(self.top_products_chart_view, 1)

        layout.addLayout(self.charts_layout)
        self.setLayout(layout)

    def update_dashboard(self):
        try:
            # Update metrics
            for widget in self.findChildren(MetricWidget):
                if isinstance(widget, MetricWidget):
                    widget.update_value()

            # Recreate charts
            new_profit_trend_chart = self.create_profit_trend_chart()
            new_top_products_chart = self.create_top_products_chart()

            # Replace old charts
            self.charts_layout.replaceWidget(self.profit_trend_chart_view, new_profit_trend_chart)
            self.charts_layout.replaceWidget(self.top_products_chart_view, new_top_products_chart)

            self.profit_trend_chart_view.deleteLater()
            self.top_products_chart_view.deleteLater()

            self.profit_trend_chart_view = new_profit_trend_chart
            self.top_products_chart_view = new_top_products_chart

            logger.info("Dashboard updated successfully")
        except Exception as e:
            logger.error("Failed to update dashboard", extra={"error": str(e)})
            raise UIException(f"Dashboard update failed: {str(e)}")

    def refresh(self):
        try:
            self.update_dashboard()
            logger.debug("Dashboard refresh completed")
        except Exception as e:
            logger.error("Dashboard refresh failed", extra={"error": str(e)})

    @ui_operation()
    def get_total_sales(self) -> str:
        total_sales_value = self.sale_service.get_total_sales(
            self.start_date.strftime('%Y-%m-%d'),
            self.end_date.strftime('%Y-%m-%d')
        )
        return f"${total_sales_value:,.0f}".replace(',', '.')

    @ui_operation()
    def get_total_profits(self) -> str:
        total_profits_value = self.sale_service.get_total_profits(
            self.start_date.strftime('%Y-%m-%d'),
            self.end_date.strftime('%Y-%m-%d')
        )
        return f"${total_profits_value:,.0f}".replace(',', '.')

    @ui_operation()
    def get_inventory_value(self) -> str:
        inv_value = self.inventory_service.get_inventory_value()
        return f"${inv_value:,.0f}".replace(',', '.')

    @ui_operation()
    def get_profit_margin(self) -> str:
        total_sales = self.sale_service.get_total_sales(
            self.start_date.strftime('%Y-%m-%d'),
            self.end_date.strftime('%Y-%m-%d')
        )
        total_profits = self.sale_service.get_total_profits(
            self.start_date.strftime('%Y-%m-%d'),
            self.end_date.strftime('%Y-%m-%d')
        )
        if total_sales > 0:
            profit_margin = (total_profits / total_sales) * 100
            return f"{profit_margin:.2f}%"
        return "0.00%"

    @ui_operation()
    def create_profit_trend_chart(self):
        chart = QChart()
        chart.setTitle("Weekly Profit Trend (Last 4 Weeks)")
        weekly_profit_trend = self.analytics_service.get_weekly_profit_trend(
            self.start_date.strftime("%Y-%m-%d"),
            self.end_date.strftime("%Y-%m-%d")
        )

        # Handle the case of empty data
        if not weekly_profit_trend:
            chart.setTitle("Weekly Profit Trend (No Data)")
            return QChartView(chart)

        series = QBarSeries()
        bar_set = QBarSet("Weekly Profit")
        axis_x = QBarCategoryAxis()
        weeks = []

        for data in weekly_profit_trend:
            bar_set.append(data['weekly_profit'])
            # Convert 'week_start' to a QDate for nice labeling
            from PySide6.QtCore import QDate
            week_start = QDate.fromString(data['week_start'], "yyyy-MM-dd")
            weeks.append(week_start.toString("MMM dd"))

        series.append(bar_set)
        chart.addSeries(series)

        axis_x.append(weeks)
        chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
        series.attachAxis(axis_x)

        axis_y = QValueAxis()
        axis_y.setMin(0)

        # Safely do max() with fallback
        max_profit = max(d['weekly_profit'] for d in weekly_profit_trend)
        # Round up
        max_y = (ceil(max_profit / 10000) * 10000) + 10000
        axis_y.setMax(max_y)

        axis_y.setTickCount(6)
        axis_y.setLabelFormat("%d")

        chart.addAxis(axis_y, Qt.AlignmentFlag.AlignLeft)
        series.attachAxis(axis_y)

        chart.legend().setVisible(True)
        chart.legend().setAlignment(Qt.AlignmentFlag.AlignBottom)

        chart.setMargins(QMargins(10, 10, 10, 10))
        chart.layout().setContentsMargins(0, 0, 0, 0)

        chart_view = QChartView(chart)
        chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)
        return chart_view

    @ui_operation()
    def create_top_products_chart(self):
        chart = QChart()
        chart.setTitle("Top 5 Profitable Products")
        top_products = self.analytics_service.get_profit_by_product(
            self.start_date.strftime("%Y-%m-%d"),
            self.end_date.strftime("%Y-%m-%d"),
            limit=5
        )

        # Handle the case of empty data
        if not top_products:
            chart.setTitle("Top 5 Profitable Products (No Data)")
            return QChartView(chart)

        series = QBarSeries()
        bar_set = QBarSet("Profit")
        categories = []

        for product in top_products:
            bar_set.append(product['total_profit'])
            categories.append(product['name'])

        series.append(bar_set)
        chart.addSeries(series)

        axis_x = QBarCategoryAxis()
        axis_x.append(categories)
        chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
        series.attachAxis(axis_x)

        axis_y = QValueAxis()
        axis_y.setMin(0)

        # Safely do max() with fallback
        max_profit = max(prod['total_profit'] for prod in top_products)
        max_y = (ceil(max_profit / 5000) * 5000) + 5000
        axis_y.setMax(max_y)

        axis_y.setTickCount(6)
        axis_y.setLabelFormat("%d")

        chart.addAxis(axis_y, Qt.AlignmentFlag.AlignLeft)
        series.attachAxis(axis_y)

        chart.legend().setVisible(True)
        chart.legend().setAlignment(Qt.AlignmentFlag.AlignBottom)

        chart.setMargins(QMargins(10, 10, 10, 10))
        chart.layout().setContentsMargins(0, 0, 0, 0)

        chart_view = QChartView(chart)
        chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)
        return chart_view



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/inventory_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
    QTableWidgetItem, QDialog, QFormLayout, QProgressBar, QMenu, QApplication,
    QComboBox, QDoubleSpinBox
)
from PySide6.QtCore import Qt, QTimer, Signal
from PySide6.QtGui import QAction, QKeySequence, QShortcut
from services.inventory_service import InventoryService
from services.product_service import ProductService
from services.category_service import CategoryService
from utils.helpers import (
    create_table, show_error_message, show_info_message
)
from utils.system.event_system import event_system
from utils.ui.table_items import NumericTableWidgetItem
from typing import List, Dict, Any
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_string
from utils.system.logger import logger
from utils.ui.sound import SoundEffect
import string
import random

class EditInventoryDialog(QDialog):
    def __init__(self, item: Dict[str, Any], parent=None):
        super().__init__(parent)
        self.item = item
        self.setWindowTitle(f"Edit {item['product_name']}")
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)

        # Show barcode if exists
        if self.item.get('barcode'):
            barcode_label = QLabel(self.item['barcode'])
            layout.addRow("Barcode:", barcode_label)

        # Quantity input
        self.quantity_input = QDoubleSpinBox()
        self.quantity_input.setMinimum(0)
        self.quantity_input.setMaximum(1000000)
        self.quantity_input.setDecimals(3)
        self.quantity_input.setValue(self.item["quantity"])
        layout.addRow("Quantity:", self.quantity_input)

        # Adjustment input
        self.adjustment_input = QDoubleSpinBox()
        self.adjustment_input.setMinimum(-1000000)
        self.adjustment_input.setMaximum(1000000)
        self.adjustment_input.setDecimals(3)
        self.adjustment_input.setValue(0)
        layout.addRow("Adjust Quantity (+ or -):", self.adjustment_input)

        # Reason for adjustment
        self.reason_input = QLineEdit()
        layout.addRow("Reason for Adjustment:", self.reason_input)

        # Keyboard shortcuts
        QShortcut(QKeySequence(Qt.Key.Key_Return), self, self.validate_and_accept)
        QShortcut(QKeySequence(Qt.Key.Key_Enter), self, self.validate_and_accept)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, show_dialog=True)
    def validate_and_accept(self):
        if self.adjustment_input.value() != 0 and not self.reason_input.text().strip():
            raise ValidationException("Please provide a reason for the adjustment.")
        self.accept()

    def get_new_quantity(self) -> float:
        return self.quantity_input.value()

    def get_adjustment(self) -> float:
        return self.adjustment_input.value()

    def get_reason(self) -> str:
        return self.reason_input.text().strip()


class InventoryView(QWidget):
    inventory_updated = Signal()

    def __init__(self):
        super().__init__()
        self.inventory_service = InventoryService()
        self.product_service = ProductService()
        self.category_service = CategoryService()
        self.current_inventory = []
        self.setup_ui()
        self.setup_scan_sound()
        self.connect_signals()
        event_system.inventory_updated.connect(self.on_inventory_updated)

    def connect_signals(self):
        """Set up event connections."""
        event_system.product_added.connect(self.handle_product_change)
        event_system.product_updated.connect(self.handle_product_change)
        event_system.product_deleted.connect(self.handle_product_change)
        event_system.inventory_changed.connect(self.handle_product_change)
        event_system.inventory_updated.connect(self.load_inventory)

    def handle_product_change(self, product_id: int) -> None:
        """Handle product changes with a small delay to ensure DB operations complete."""
        logger.debug(f"Received product change event for product {product_id}")
        # Use QTimer to add a small delay before reloading
        QTimer.singleShot(100, self.refresh)

    def setup_scan_sound(self) -> None:
        """Initialize the sound system."""
        self.scan_sound = SoundEffect("scan.wav")

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Input fields
        input_layout = QHBoxLayout()

        # Barcode and search section
        barcode_layout = QHBoxLayout()
        
        # Barcode input
        self.barcode_input = QLineEdit()
        self.barcode_input.setPlaceholderText("Scan barcode...")
        self.barcode_input.returnPressed.connect(self.handle_barcode_scan)
        self.barcode_input.textChanged.connect(self.handle_barcode_input)
        
        # Manual search
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search products...")
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_products)
        
        barcode_layout.addWidget(QLabel("Barcode:"))
        barcode_layout.addWidget(self.barcode_input)
        barcode_layout.addWidget(QLabel("Manual Search:"))
        barcode_layout.addWidget(self.search_input)
        barcode_layout.addWidget(search_button)

        # Category filter
        filter_layout = QHBoxLayout()
        self.category_filter = QComboBox()
        self.category_filter.addItem("All Categories", None)
        self.load_categories()
        # Add connection to filter triggering
        self.category_filter.currentIndexChanged.connect(lambda _: self.filter_inventory())

        # Barcode filter
        self.barcode_filter = QComboBox()
        self.barcode_filter.addItems(["All Products", "With Barcode", "Without Barcode"])
        self.barcode_filter.currentIndexChanged.connect(self.filter_inventory)

        layout.addLayout(input_layout)
        layout.addLayout(barcode_layout)

        # Add category and barcode filters
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Category:"))
        filter_layout.addWidget(self.category_filter)
        filter_layout.addWidget(QLabel("Barcode:"))
        filter_layout.addWidget(self.barcode_filter)
        layout.addLayout(filter_layout)

        # Inventory table
        self.inventory_table = create_table(
            ["Product ID", "Product Name", "Category", "Barcode", "Quantity", "Actions"]
        )
        self.inventory_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.inventory_table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.inventory_table)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        self.current_inventory = []
        self.load_inventory()
        
        # Connect to event system
        event_system.product_added.connect(self.load_inventory)
        event_system.product_updated.connect(self.load_inventory)
        event_system.product_deleted.connect(self.load_inventory)
        event_system.inventory_changed.connect(self.load_inventory)

    def handle_barcode_scan(self) -> None:
        """Handle barcode scan completion."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return

        try:
            # Find product by barcode
            product = self.product_service.get_product_by_barcode(barcode)
            if product:
                # Play success sound
                self.scan_sound.play()
                
                # Filter inventory to show only this product
                filtered_items = [
                    item for item in self.current_inventory 
                    if item['product_id'] == product.id
                ]
                self.update_inventory_table(filtered_items)
            else:
                # Visual feedback for error
                self.barcode_input.setStyleSheet("background-color: #ffebee;")
                QTimer.singleShot(1000, lambda: self.barcode_input.setStyleSheet(""))
                show_error_message("Error", f"No product found with barcode: {barcode}")
        except Exception as e:
            logger.error(f"Error processing barcode: {str(e)}")
            show_error_message("Error", f"Failed to process barcode: {str(e)}")
        finally:
            self.barcode_input.clear()

    def handle_barcode_input(self, text: str) -> None:
        """Handle barcode input changes."""
        # If text is longer than typical barcode, clear it
        if len(text) > 14:  # EAN-14 is the longest common barcode
            self.barcode_input.clear()

    def search_products(self) -> None:
        """Search for products manually."""
        search_term = self.search_input.text().strip()
        if not search_term:
            return

        try:
            # Filter current inventory based on search term
            filtered_items = [
                item for item in self.current_inventory 
                if search_term.lower() in item['product_name'].lower() or
                search_term.lower() in str(item['product_id']).lower() or
                (item.get('barcode') and search_term in item['barcode']) or
                search_term.lower() in item['category_name'].lower()
            ]
            
            self.update_inventory_table(filtered_items)
            if not filtered_items:
                show_error_message("Not Found", "No products found matching the search term")
                
        except Exception as e:
            logger.error(f"Error searching products: {str(e)}")
            show_error_message("Error", str(e))

    def setup_shortcuts(self):
        # Barcode field focus (Ctrl+B)
        barcode_shortcut = QShortcut(QKeySequence("Ctrl+B"), self)
        barcode_shortcut.activated.connect(lambda: self.barcode_input.setFocus())
        
        # Refresh (F5)
        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.load_inventory)
        self.addAction(refresh_shortcut)

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_categories(self):
        try:
            categories = self.category_service.get_all_categories()
            self.category_filter.clear()
            self.category_filter.addItem("All Categories", None)
            for category in categories:
                self.category_filter.addItem(category.name, category.id)
            logger.info(f"Loaded {len(categories)} categories")
        except Exception as e:
            logger.error(f"Error loading categories: {str(e)}")
            raise DatabaseException(f"Failed to load categories: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_inventory(self, _: Any = None) -> None:
        """Load all inventory items."""
        try:
            self.current_inventory = self.inventory_service.get_all_inventory()
            self.update_inventory_table(self.current_inventory)
        except Exception as e:
            logger.error(f"Error loading inventory: {str(e)}")
            show_error_message("Error", f"Failed to load inventory: {str(e)}")

    def update_inventory_table(self, inventory_items: List[Dict[str, Any]]) -> None:
        """Update the inventory table with the given items."""
        self.inventory_table.setRowCount(0)
        
        for row, item in enumerate(inventory_items):
            self.inventory_table.insertRow(row)
            try:
                # Basic info
                self.inventory_table.setItem(row, 0, QTableWidgetItem(str(item['product_id'])))
                self.inventory_table.setItem(row, 1, QTableWidgetItem(item['product_name']))
                self.inventory_table.setItem(row, 2, QTableWidgetItem(item['category_name']))
                self.inventory_table.setItem(row, 3, NumericTableWidgetItem(float(item['quantity'])))
                self.inventory_table.setItem(row, 4, QTableWidgetItem(item['barcode']))
                
                # Add edit button
                actions_widget = QWidget()
                actions_layout = QHBoxLayout(actions_widget)
                actions_layout.setContentsMargins(0, 0, 0, 0)
                
                edit_button = QPushButton("Edit")
                edit_button.clicked.connect(lambda _, i=item: self.edit_inventory(i))
                edit_button.setMaximumWidth(60)
                actions_layout.addWidget(edit_button)
                
                self.inventory_table.setCellWidget(row, 5, actions_widget)
                
            except Exception as e:
                logger.error(f"Error updating row {row}: {str(e)}", extra={"item": item})
                continue

    def generate_barcode(self, item: Dict[str, Any]) -> None:
        """Generate a new barcode for a product."""
        try:
            # Generate a unique 12-digit barcode
            while True:
                barcode = ''.join(random.choices(string.digits, k=12))
                if not self.product_service.get_product_by_barcode(barcode):
                    break
            
            # Update product with new barcode
            product_id = item['product_id']
            self.product_service.update_product(product_id, {'barcode': barcode})
            self.scan_sound.play()
            show_info_message("Success", f"Generated barcode: {barcode}")
            self.load_inventory()
        except Exception as e:
            logger.error(f"Error generating barcode: {str(e)}")
            show_error_message("Error", str(e))

    def handle_barcode_search(self):
        """Handle barcode search."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return

        try:
            product = self.product_service.get_product_by_barcode(barcode)
            if product:
                self.scan_sound.play()
                # Filter inventory to show only this product
                filtered_items = [
                    item for item in self.current_inventory 
                    if str(item['product_id']) == str(product.id)  # Convert both to strings for comparison
                ]
                if filtered_items:
                    self.update_inventory_table(filtered_items)
                else:
                    show_error_message("Not Found", "Product exists but has no inventory")
            else:
                self.barcode_input.setStyleSheet("background-color: #ffebee;")
                QTimer.singleShot(1000, lambda: self.barcode_input.setStyleSheet(""))
                show_error_message("Error", f"No product found with barcode: {barcode}")
        except Exception as e:
            logger.error(f"Error searching by barcode: {str(e)}")
            show_error_message("Error", str(e))
        finally:
            self.barcode_input.clear()
            self.barcode_input.setFocus()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_inventory(self, item: Dict[str, Any]) -> None:
        """Edit inventory item."""
        try:
            # Convert dictionary to expected format
            edit_item = {
                'product_id': item['product_id'],
                'product_name': item['product_name'],
                'category_name': item['category_name'],
                'quantity': item['quantity'],
                'barcode': item['barcode']
            }
            
            dialog = EditInventoryDialog(edit_item, self)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_inventory()
        except Exception as e:
            logger.error(f"Error editing inventory: {str(e)}")
            show_error_message("Error", str(e))

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def search_inventory(self):
        """Search inventory items."""
        search_term = validate_string(self.search_input.text().strip(), max_length=100)
        self.filter_inventory()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def filter_inventory(self):
        """Filter inventory based on category and barcode status."""
        logger.debug("Starting filter_inventory")  # DEBUG - Entry point
        try:
            category_id = self.category_filter.currentData()
            barcode_filter = self.barcode_filter.currentText()
            search_term = self.search_input.text().strip().lower()

            filtered_items = self.current_inventory
            logger.debug(f"Initial items to filter (first item): {filtered_items[:1]}")  # DEBUG - Pre-filter
            
            # Filter by category
            if category_id is not None:
                filtered_items = [
                    item for item in filtered_items
                    if item.get("category_id") == category_id
                ]
                logger.debug(f"After category filter (first item): {filtered_items[:1]}")  # DEBUG - Post category filter
            
            # Filter by barcode status
            if barcode_filter != "All Products":
                filtered_items = [
                    item for item in filtered_items
                    if (barcode_filter == "With Barcode" and item.get("barcode")) or
                       (barcode_filter == "Without Barcode" and not item.get("barcode"))
                ]
            
            # Filter by search term
            if search_term:
                filtered_items = [
                    item for item in filtered_items
                    if search_term in str(item.get("product_name", "")).lower() or
                       search_term in str(item.get("product_id", "")).lower() or
                       search_term in str(item.get("category_name", "")).lower() or
                       (item.get("barcode") and search_term in item["barcode"].lower())
                ]

            self.update_inventory_table(filtered_items)
            logger.info(f"Filtered inventory: {len(filtered_items)} items")
        except Exception as e:
            logger.error(f"Error filtering inventory: {str(e)}")
            raise DatabaseException(f"Failed to filter inventory: {str(e)}")

    def show_context_menu(self, position):
        """Show context menu for inventory table."""
        menu = QMenu()
        edit_action = menu.addAction("Edit")
        generate_action = None
        
        row = self.inventory_table.rowAt(position.y())
        if row >= 0:
            barcode = self.inventory_table.item(row, 3).text()
            if barcode == "No barcode":
                generate_action = menu.addAction("Generate Barcode")

        action = menu.exec(self.inventory_table.mapToGlobal(position))
        if action:
            if row >= 0:
                product_id = int(self.inventory_table.item(row, 0).text())
                item = next((item for item in self.current_inventory if item["product_id"] == product_id), None)
                
                if item:
                    if action == edit_action:
                        self.edit_inventory(item)
                    elif action == generate_action:
                        self.generate_barcode(item)
                else:
                    show_error_message("Error", f"Inventory item for product ID {product_id} not found")

    def refresh(self):
        """Refresh the inventory view with cache clearing."""
        try:
            logger.debug("Refreshing inventory view")
            # Clear the cache before loading
            self.inventory_service.clear_cache()
            self.load_inventory()
            self.barcode_input.setFocus()
        except Exception as e:
            logger.error(f"Error refreshing inventory: {str(e)}")
            show_error_message("Error", f"Failed to refresh inventory: {str(e)}")

    def keyPressEvent(self, event):
        """Handle key press events."""
        if event.key() == Qt.Key.Key_F5:
            self.refresh()
        elif event.key() == Qt.Key.Key_Escape:
            self.barcode_input.clear()
            self.search_input.clear()
            self.category_filter.setCurrentIndex(0)
            self.barcode_filter.setCurrentIndex(0)
            self.load_inventory()
        else:
            super().keyPressEvent(event)

    def on_inventory_updated(self, product_id):
        self.load_inventory()  # Refresh the entire inventory table


C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/main_window.py:
from PySide6.QtWidgets import (
    QMainWindow, QTabWidget, QVBoxLayout, QWidget, QMessageBox, QStatusBar, QMenuBar, QMenu
)
from PySide6.QtCore import Qt, QSettings, QSize, QPoint
from PySide6.QtGui import QAction, QKeySequence
from ui.customer_view import CustomerView
from ui.dashboard_view import DashboardView
from ui.product_view import ProductView
from ui.sale_view import SaleView
from ui.purchase_view import PurchaseView
from ui.inventory_view import InventoryView
from ui.analytics_view import AnalyticsView
from typing import Protocol, Dict, Type, cast
from utils.system.logger import logger
from config import config, APP_NAME, APP_VERSION, COMPANY_NAME
from utils.system.event_system import event_system
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import UIException

class RefreshableWidget(Protocol):
    def refresh(self) -> None: ...

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"{APP_NAME} - v{APP_VERSION}")
        self.settings = QSettings(COMPANY_NAME, APP_NAME)
        self.setup_ui()

    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def setup_ui(self):
        try:
            # Handle window size
            size = self.settings.value("WindowSize")
            if isinstance(size, QSize):
                self.resize(size)
            else:
                self.resize(QSize(1200, 800))

            # Handle window position
            pos = self.settings.value("WindowPosition")
            if isinstance(pos, QPoint):
                self.move(pos)
            else:
                self.move(QPoint(100, 100))

            self.setup_menu_bar()
            self.setup_status_bar()

            central_widget = QWidget()
            self.setCentralWidget(central_widget)

            layout = QVBoxLayout(central_widget)

            self.tab_widget = QTabWidget()
            layout.addWidget(self.tab_widget)

            self.create_tabs()
            logger.info("Main window UI setup completed successfully")
        except Exception as e:
            logger.error(f"Error setting up main window UI: {str(e)}")
            raise UIException(f"Failed to set up main window UI: {str(e)}")

    def setup_menu_bar(self):
        menu_bar = QMenuBar(self)
        self.setMenuBar(menu_bar)

        file_menu = self.create_menu(
            "&File",
            [
                ("&Export Data", "Ctrl+E", self.export_data),
                ("&Import Data", "Ctrl+I", self.import_data),
                ("E&xit", QKeySequence.StandardKey.Quit, self.close),
            ],
        )
        view_menu = self.create_menu(
            "&View",
            [("&Refresh", QKeySequence.StandardKey.Refresh, self.refresh_current_tab)],
        )
        help_menu = self.create_menu(
            "&Help",
            [
                (
                    "&User Guide",
                    QKeySequence.StandardKey.HelpContents,
                    self.show_user_guide,
                ),
                ("&About", None, self.show_about_dialog),
            ],
        )

        menu_bar.addMenu(file_menu)
        menu_bar.addMenu(view_menu)
        menu_bar.addMenu(help_menu)

    def setup_status_bar(self):
        self.status_bar = QStatusBar(self)
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")

    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def create_tabs(self):
        try:
            tabs: Dict[str, Type[QWidget]] = {
                "Dashboard": DashboardView,
                "Customers": CustomerView,
                "Products": ProductView,
                "Sales": SaleView,
                "Purchases": PurchaseView,
                "Inventory": InventoryView,
                "Analytics": AnalyticsView,
            }

            for tab_name, view_class in tabs.items():
                view = view_class()
                self.tab_widget.addTab(view, tab_name)
                logger.info(f"Added {tab_name} tab successfully")

            self.restore_last_tab()
            self.tab_widget.currentChanged.connect(self.on_tab_changed)

            self.connect_to_events()
        except Exception as e:
            logger.error(f"Error creating tabs: {str(e)}")
            raise UIException(f"Failed to create tabs: {str(e)}")

    def restore_last_tab(self):
        last_tab_index = self.settings.value("LastTabIndex", 0)
        if (
            isinstance(last_tab_index, int)
            and 0 <= last_tab_index < self.tab_widget.count()
        ):
            self.tab_widget.setCurrentIndex(last_tab_index)
        else:
            self.tab_widget.setCurrentIndex(0)

    def connect_to_events(self):
        event_system.product_added.connect(self.on_product_added)
        event_system.product_updated.connect(self.on_product_updated)
        event_system.product_deleted.connect(self.on_product_deleted)
        event_system.sale_added.connect(self.on_sale_added)
        event_system.purchase_added.connect(self.on_purchase_added)

    @ui_operation(show_dialog=True)
    def on_tab_changed(self, index):
        self.settings.setValue("LastTabIndex", index)
        tab_name = self.tab_widget.tabText(index)
        self.status_bar.showMessage(f"Current view: {tab_name}")

    @ui_operation(show_dialog=True)
    def show_about_dialog(self):
        QMessageBox.about(
            self,
            "About",
            f"{APP_NAME} v{APP_VERSION}\n\n"
            f"Developed by {COMPANY_NAME}\n\n"
            "An inventory and billing management system.",
        )

    @ui_operation(show_dialog=True)
    def closeEvent(self, event):
        reply = QMessageBox.question(
            self,
            "Exit",
            "Are you sure you want to exit?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.settings.setValue("WindowSize", self.size())
            self.settings.setValue("WindowPosition", self.pos())

            logger.info("Application closed by user")
            event.accept()
        else:
            event.ignore()

    def show_status_message(self, message: str, timeout: int = 5000):
        self.status_bar.showMessage(message, timeout)

    @ui_operation(show_dialog=True)
    def on_product_added(self, product_id: int):
        self.show_status_message(f"Product added (ID: {product_id})")
        self.refresh_relevant_views()

    @ui_operation(show_dialog=True)
    def on_product_updated(self, product_id: int):
        self.show_status_message(f"Product updated (ID: {product_id})")
        self.refresh_relevant_views()

    @ui_operation(show_dialog=True)
    def on_product_deleted(self, product_id: int):
        self.show_status_message(f"Product deleted (ID: {product_id})")
        self.refresh_relevant_views()

    @ui_operation(show_dialog=True)
    def on_sale_added(self, sale_id: int):
        self.show_status_message(f"Sale added (ID: {sale_id})")
        self.refresh_relevant_views()

    @ui_operation(show_dialog=True)
    def on_purchase_added(self, purchase_id: int):
        self.show_status_message(f"Purchase added (ID: {purchase_id})")
        self.refresh_relevant_views()

    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def refresh_relevant_views(self):
        try:
            for i in range(self.tab_widget.count()):
                widget = self.tab_widget.widget(i)
                if hasattr(widget, "refresh") and callable(getattr(widget, "refresh")):
                    refreshable_widget = cast(RefreshableWidget, widget)
                    refreshable_widget.refresh()
        except Exception as e:
            logger.error(f"Error refreshing views: {str(e)}")
            raise UIException(f"Failed to refresh views: {str(e)}")

    def create_menu(self, name: str, actions: list) -> QMenu:
        menu = QMenu(name, self)
        for action_name, shortcut, callback in actions:
            action = QAction(action_name, self)
            if shortcut:
                if isinstance(shortcut, QKeySequence.StandardKey):
                    action.setShortcut(QKeySequence(shortcut))
                else:
                    action.setShortcut(shortcut)
            action.triggered.connect(callback)
            menu.addAction(action)
        return menu

    @ui_operation(show_dialog=True)
    def export_data(self):
        self.show_status_message("Data export initiated")
        # TODO: Implement actual data export logic

    @ui_operation(show_dialog=True)
    def import_data(self):
        self.show_status_message("Data import initiated")
        # TODO: Implement actual data import logic

    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def refresh_current_tab(self):
        try:
            current_widget = self.tab_widget.currentWidget()
            if hasattr(current_widget, "refresh") and callable(
                getattr(current_widget, "refresh")
            ):
                refreshable_widget = cast(RefreshableWidget, current_widget)
                refreshable_widget.refresh()
            self.show_status_message("View refreshed")
        except Exception as e:
            logger.error(f"Error refreshing current tab: {str(e)}")
            raise UIException(f"Failed to refresh current tab: {str(e)}")

    @ui_operation(show_dialog=True)
    def show_user_guide(self):
        QMessageBox.information(self, "User Guide", "User guide content goes here.")
        # TODO: Implement actual user guide content or link to documentation



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/product_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
    QTableWidgetItem, QMessageBox, QDoubleSpinBox, QDialog, QDialogButtonBox, 
    QComboBox, QFormLayout, QHeaderView, QAbstractItemView, QProgressBar, 
    QMenu, QApplication
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QAction, QKeySequence
from services.product_service import ProductService
from services.category_service import CategoryService
from utils.helpers import create_table, show_info_message, show_error_message, format_price
from utils.system.event_system import event_system
from ui.category_management_dialog import CategoryManagementDialog
from utils.ui.table_items import NumericTableWidgetItem, PercentageTableWidgetItem, PriceTableWidgetItem
from typing import Optional, List, Any
from models.product import Product
from models.category import Category
from utils.decorators import ui_operation, handle_exceptions
from utils.validation.validators import validate_string, validate_float, validate_integer
from utils.exceptions import ValidationException, DatabaseException, UIException, NotFoundException
from utils.system.logger import logger

class EditProductDialog(QDialog):
    def __init__(self, product: Optional[Product], categories: List[Category], parent=None):
        super().__init__(parent)
        self.product = product
        self.categories = categories
        self.setWindowTitle("Edit Product" if product else "Add Product")
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)

        self.name_input = QLineEdit(self.product.name if self.product else "")
        self.description_input = QLineEdit(self.product.description or "" if self.product else "")
        self.barcode_input = QLineEdit(self.product.barcode or "" if self.product else "")

        self.category_combo = QComboBox()
        self.category_combo.addItem("Uncategorized", None)
        for category in self.categories:
            self.category_combo.addItem(category.name, category.id)
        if self.product and self.product.category_id:
            index = self.category_combo.findData(self.product.category_id)
            if index >= 0:
                self.category_combo.setCurrentIndex(index)

        self.cost_price_input = QDoubleSpinBox()
        self.cost_price_input.setMaximum(1000000000)
        self.cost_price_input.setValue(float(self.product.cost_price) if self.product and self.product.cost_price else 0)

        self.sell_price_input = QDoubleSpinBox()
        self.sell_price_input.setMaximum(1000000000)
        self.sell_price_input.setValue(float(self.product.sell_price) if self.product and self.product.sell_price else 0)

        layout.addRow("Name:", self.name_input)
        layout.addRow("Description:", self.description_input)
        layout.addRow("Barcode:", self.barcode_input)
        layout.addRow("Category:", self.category_combo)
        layout.addRow("Cost Price:", self.cost_price_input)
        layout.addRow("Sell Price:", self.sell_price_input)

        # Add help text for barcode
        barcode_help = QLabel("Optional - Must be 8, 12, 13, or 14 digits if provided")
        barcode_help.setStyleSheet("color: gray; font-size: 10px;")
        layout.addRow("", barcode_help)

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, show_dialog=True)
    def validate_and_accept(self):
        name = validate_string(self.name_input.text().strip(), min_length=1, max_length=100)
        description = validate_string(self.description_input.text().strip(), min_length=0, max_length=500)
        category_id = self.category_combo.currentData()
        cost_price = validate_float(self.cost_price_input.value(), min_value=0)
        sell_price = validate_float(self.sell_price_input.value(), min_value=0)
        
        # Get barcode value and validate if not empty
        barcode = self.barcode_input.text().strip()
        if barcode:
            try:
                Product.validate_barcode(barcode)
            except ValidationException as e:
                raise ValidationException(str(e))

        self.product_data = {
            "name": name,
            "description": description,
            "category_id": category_id,
            "cost_price": cost_price,
            "sell_price": sell_price,
            "barcode": barcode if barcode else None
        }
        self.accept()


class ProductView(QWidget):
    product_updated = Signal()

    def __init__(self):
        super().__init__()
        self.product_service = ProductService()
        self.category_service = CategoryService()
        self.current_category_id = None
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Search bar
        search_layout = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search products...")
        self.search_input.returnPressed.connect(self.search_products)
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_products)
        search_layout.addWidget(self.search_input)
        search_layout.addWidget(search_button)
        layout.addLayout(search_layout)

        # Category filter
        filter_layout = QHBoxLayout()
        self.category_filter = QComboBox()
        self.category_filter.addItem("All Categories", None)
        self.load_categories()
        self.category_filter.currentIndexChanged.connect(self.on_category_changed)
        filter_layout.addWidget(QLabel("Filter by Category:"))
        filter_layout.addWidget(self.category_filter)
        layout.addLayout(filter_layout)

        # Product table
        self.product_table = create_table(
            [
                "ID",
                "Name",
                "Description",
                "Category",
                "Cost Price",
                "Sell Price",
                "Profit Margin",
                "Actions",
            ]
        )
        self.product_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        self.product_table.setSortingEnabled(True)
        self.product_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.product_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.product_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.product_table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.product_table)

        # Buttons
        button_layout = QHBoxLayout()
        add_button = QPushButton("Add Product")
        add_button.clicked.connect(self.add_product)
        add_button.setToolTip("Add a new product (Ctrl+N)")
        manage_categories_button = QPushButton("Manage Categories")
        manage_categories_button.clicked.connect(self.manage_categories)
        button_layout.addWidget(add_button)
        button_layout.addWidget(manage_categories_button)
        layout.addLayout(button_layout)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Set up shortcuts
        self.setup_shortcuts()

        self.load_products()

        # Connect to event system
        event_system.product_added.connect(self.load_products)
        event_system.product_updated.connect(self.load_products)
        event_system.product_deleted.connect(self.load_products)

    def setup_shortcuts(self):
        add_shortcut = QAction("Add Product", self)
        add_shortcut.setShortcut(QKeySequence("Ctrl+N"))
        add_shortcut.triggered.connect(self.add_product)
        self.addAction(add_shortcut)

        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.load_products)
        self.addAction(refresh_shortcut)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def on_category_changed(self, index):
        try:
            self.current_category_id = self.category_filter.itemData(index)
            # Get fresh data and apply new filter
            fresh_products = self.product_service.get_all_products()
            self.filter_products(products=fresh_products)
        except Exception as e:
            logger.error(f"Error changing category: {str(e)}")
            raise UIException(f"Failed to change category: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_categories(self):
        try:
            categories = self.category_service.get_all_categories()
            self.category_filter.clear()
            self.category_filter.addItem("All Categories", None)
            for category in categories:
                self.category_filter.addItem(category.name, category.id)
            logger.info("Categories loaded successfully")
        except Exception as e:
            logger.error(f"Error loading categories: {str(e)}")
            raise DatabaseException(f"Failed to load categories: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_products(self, _: Any = None) -> None:
        """Load all products and maintain current filters."""
        logger.debug("Loading products list")
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            fresh_products = self.product_service.get_all_products()
            logger.debug(f"Loaded {len(fresh_products)} products")
            # Use filter_products to maintain current filters
            self.filter_products(products=fresh_products)
            logger.info("Products loaded successfully")
        except Exception as e:
            logger.error(f"Error loading products: {str(e)}")
            raise DatabaseException(f"Failed to load products: {str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

    @ui_operation(show_dialog=True)
    @handle_exceptions(UIException, show_dialog=True)
    def update_product_table(self, products: List[Product]):
        """Update the product table display."""
        logger.debug(f"Updating product table with {len(products)} products")
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            
            # Clear existing rows
            self.product_table.setRowCount(0)
            self.product_table.setRowCount(len(products))

            for row, product in enumerate(products):
                logger.debug(f"Adding row {row}: Product ID={product.id}")
                
                try:
                    self.product_table.setItem(row, 0, NumericTableWidgetItem(product.id))
                    self.product_table.setItem(row, 1, QTableWidgetItem(product.name))
                    self.product_table.setItem(row, 2, QTableWidgetItem(product.description or ""))
                    self.product_table.setItem(row, 3, QTableWidgetItem(product.category_name or "Uncategorized"))
                    self.product_table.setItem(row, 4, PriceTableWidgetItem(
                        float(product.cost_price) if product.cost_price else 0, format_price))
                    self.product_table.setItem(row, 5, PriceTableWidgetItem(
                        float(product.sell_price) if product.sell_price else 0, format_price))
                    self.product_table.setItem(row, 6, PercentageTableWidgetItem(
                        float(product.calculate_profit_margin())))

                    # Create action buttons
                    actions_widget = QWidget()
                    actions_layout = QHBoxLayout(actions_widget)
                    actions_layout.setContentsMargins(0, 0, 0, 0)

                    edit_button = QPushButton("Edit")
                    edit_button.setFixedWidth(80)
                    edit_button.clicked.connect(lambda _, p=product: self.edit_product(p))
                    
                    delete_button = QPushButton("Delete")
                    delete_button.setFixedWidth(80)
                    delete_button.clicked.connect(lambda _, p=product: self.delete_product(p))

                    actions_layout.addWidget(edit_button)
                    actions_layout.addWidget(delete_button)
                    self.product_table.setCellWidget(row, 7, actions_widget)
                except Exception as e:
                    logger.error(f"Error updating row {row}: {str(e)}")
                    continue

            # Adjust table display
            self.product_table.resizeColumnsToContents()
            self.product_table.horizontalHeader().setSectionResizeMode(
                7, QHeaderView.ResizeMode.Stretch)
            
            logger.info("Product table updated successfully")
        except Exception as e:
            logger.error(f"Error updating product table: {str(e)}")
            raise UIException(f"Failed to update product table: {str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def add_product(self):
        try:
            categories = self.category_service.get_all_categories()
            dialog = EditProductDialog(None, categories, self)
            if dialog.exec():
                product_data = dialog.product_data
                logger.debug("Creating new product", extra={"data": product_data})
                product_id = self.product_service.create_product(product_data)
                logger.debug(f"Product created with ID: {product_id}")
                
                if product_id is not None:
                    # Get fresh data but maintain filters
                    fresh_products = self.product_service.get_all_products()
                    self.filter_products(products=fresh_products)
                    
                    show_info_message("Success", "Product added successfully.")
                    event_system.product_added.emit(product_id)
                    self.product_updated.emit()
                    logger.info(f"Product added successfully: ID {product_id}")
                else:
                    raise DatabaseException("Failed to add product.")
        except Exception as e:
            logger.error(f"Error adding product: {str(e)}")
            raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_product(self, product: Optional[Product] = None):
        if product is None:
            selected_rows = self.product_table.selectionModel().selectedRows()
            if not selected_rows:
                raise ValidationException("No product selected for editing.")
            row = selected_rows[0].row()
            product_id = int(self.product_table.item(row, 0).text())
            product = self.product_service.get_product(product_id)

        if product:
            categories = self.category_service.get_all_categories()
            dialog = EditProductDialog(product, categories, self)
            if dialog.exec():
                product_data = dialog.product_data
                try:
                    self.product_service.update_product(product.id, product_data)
                    
                    # Get fresh data but maintain current filter
                    fresh_products = self.product_service.get_all_products()
                    self.filter_products(products=fresh_products)
                    
                    show_info_message("Success", "Product updated successfully.")
                    event_system.product_updated.emit(product.id)
                    self.product_updated.emit()
                    logger.info(f"Product updated successfully: ID {product.id}")
                except Exception as e:
                    logger.error(f"Error updating product: {str(e)}")
                    raise
        else:
            raise ValidationException(f"Product with ID {product_id} not found.")


    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_product(self, product: Product):
        try:
            reply = QMessageBox.question(
                self,
                "Delete Product",
                f"Are you sure you want to delete product {product.name}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No,
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
                try:
                    self.product_service.delete_product(product.id)
                    
                    # Get fresh data but maintain filters
                    fresh_products = self.product_service.get_all_products()
                    self.filter_products(products=fresh_products)
                    
                    show_info_message("Success", "Product deleted successfully.")
                    event_system.product_deleted.emit(product.id)
                    self.product_updated.emit()
                    logger.info(f"Product deleted successfully: ID {product.id}")
                finally:
                    QApplication.restoreOverrideCursor()
        except Exception as e:
            logger.error(f"Error deleting product: {str(e)}")
            raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def search_products(self):
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            search_term = self.search_input.text().strip()
            search_term = validate_string(search_term, max_length=100)
            # Get fresh data and apply new search
            fresh_products = self.product_service.get_all_products()
            self.filter_products(products=fresh_products, search_term=search_term)
        finally:
            QApplication.restoreOverrideCursor()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def filter_products(self, products: Optional[List[Product]] = None, search_term: Optional[str] = None):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            # Store current search term if none provided
            if search_term is None:
                search_term = self.search_input.text().strip()

            # Only fetch all products if no products were provided
            if products is None:
                products = self.product_service.get_all_products() or []

            search_term = search_term.lower()
            
            # First apply category filter
            if self.current_category_id is not None:
                products = [p for p in products if p.category_id == self.current_category_id]

            # Then apply search filter
            if search_term:
                products = [
                    p for p in products
                    if search_term in p.name.lower() or 
                    (p.description and search_term in p.description.lower())
                ]

            self.update_product_table(products)
            logger.info(f"Products filtered: {len(products)} results")
        finally:
            QApplication.restoreOverrideCursor()

    def refresh(self):
        """Refresh the product view while maintaining current filters."""
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            fresh_products = self.product_service.get_all_products()
            self.filter_products(products=fresh_products)
        except Exception as e:
            logger.error(f"Error in refresh: {str(e)}")
            show_error_message("Error", "Failed to refresh products")
        finally:
            QApplication.restoreOverrideCursor()

    def on_product_deleted(self, product_id: int):
        """Handle product deleted event gracefully."""
        try:
            logger.info(f"Product deleted event received: {product_id}")
            # Simply refresh the view - don't try to access the deleted product
            self.refresh()
        except Exception as e:
            logger.error(f"Error handling product deletion: {str(e)}")
            # Don't raise the exception - just log it

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def manage_categories(self):
        dialog = CategoryManagementDialog(self)
        if dialog.exec():
            self.load_categories()
            self.load_products()
            logger.info("Categories managed successfully")

    def show_context_menu(self, position):
        try:
            row = self.product_table.rowAt(position.y())
            if row < 0:  # No valid row selected
                return

            menu = QMenu()
            edit_action = menu.addAction("Edit")
            delete_action = menu.addAction("Delete")
            refresh_action = menu.addAction("Refresh")

            action = menu.exec(self.product_table.mapToGlobal(position))
            if action:
                product_id = int(self.product_table.item(row, 0).text())
                try:
                    product = self.product_service.get_product(product_id)
                    if product is None:
                        raise NotFoundException(f"Product with ID {product_id} not found.")

                    if action == edit_action:
                        self.edit_product(product)
                    elif action == delete_action:
                        if product:
                            self.delete_product(product)
                    elif action == refresh_action:
                        self.filter_products()
                except Exception as e:
                    logger.error(f"Error in context menu action: {str(e)}")
                    show_error_message("Error", str(e))
        except Exception as e:
            logger.error(f"Error showing context menu: {str(e)}")
            show_error_message("Error", "Failed to show context menu")
            if action:
                if action == edit_action:
                    self.edit_product(product)
                elif action == delete_action and product:
                    self.delete_product(product)
                elif action == refresh_action:
                    self.filter_products()
                else:
                    show_error_message("Error", f"Product with ID {product_id} not found.")

    @ui_operation(show_dialog=True)
    def export_products(self):
        # TODO: Implement export functionality
        show_info_message("Info", "Export functionality not implemented yet.")
        logger.info("Export products functionality not implemented")

    @ui_operation(show_dialog=True)
    def import_products(self):
        # TODO: Implement import functionality
        show_info_message("Info", "Import functionality not implemented yet.")
        logger.info("Import products functionality not implemented")

    def keyPressEvent(self, event):
        """Handle keyboard events."""
        try:
            if event.key() == Qt.Key.Key_Delete:
                selected_rows = self.product_table.selectionModel().selectedRows()
                if selected_rows:
                    row = selected_rows[0].row()
                    product_id = int(self.product_table.item(row, 0).text())
                    try:
                        product = self.product_service.get_product(product_id)
                        if product:
                            self.delete_product(product)
                    except Exception as e:
                        logger.error(f"Error handling delete key event: {str(e)}")
                        show_error_message("Error", f"Failed to delete product: {str(e)}")
            else:
                super().keyPressEvent(event)
        except Exception as e:
            logger.error(f"Error in keyPressEvent: {str(e)}")
            super().keyPressEvent(event)

    def cleanup(self):
        """Cleanup resources when the widget is being destroyed."""
        try:
            # Disconnect from event system
            event_system.product_added.disconnect(self.load_products)
            event_system.product_updated.disconnect(self.load_products)
            event_system.product_deleted.disconnect(self.load_products)
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/purchase_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
    QTableWidget, QTableWidgetItem, QMessageBox, QDialog, QDialogButtonBox, 
    QFormLayout, QDateEdit, QComboBox, QDoubleSpinBox, QHeaderView,
    QAbstractItemView, QProgressBar, QMenu, QApplication
)
from PySide6.QtMultimedia import QSoundEffect
from PySide6.QtCore import Qt, QDate, QTimer, Signal, QUrl
from PySide6.QtGui import QAction, QKeySequence, QShortcut
from services.purchase_service import PurchaseService
from services.product_service import ProductService
from models.purchase import Purchase
from utils.helpers import (
    create_table, show_info_message, show_error_message, format_price
)
from utils.system.event_system import event_system
from utils.ui.table_items import NumericTableWidgetItem, PriceTableWidgetItem
from typing import List, Dict, Any, Optional
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_string, validate_float
from utils.system.logger import logger
import os

class PurchaseItemDialog(QDialog):
    def __init__(self, product, parent=None):
        super().__init__(parent)
        self.product = product
        self.setWindowTitle(f"Add {product.name}")
        self.setup_ui()
        
        # Focus quantity input by default
        self.quantity_input.setFocus()
        self.quantity_input.selectAll()

    def setup_ui(self):
        layout = QFormLayout(self)

        # Product info
        product_info = QLabel(f"{self.product.name}")
        if self.product.barcode:
            product_info.setToolTip(f"Barcode: {self.product.barcode}")
        layout.addRow("Product:", product_info)

        # Quantity input
        self.quantity_input = QDoubleSpinBox()
        self.quantity_input.setMinimum(0.001)
        self.quantity_input.setMaximum(1000000.000)
        self.quantity_input.setDecimals(3)
        self.quantity_input.setValue(1.00)
        self.quantity_input.valueChanged.connect(self.update_total)
        layout.addRow("Quantity:", self.quantity_input)

        # Cost price input
        self.cost_price_input = QDoubleSpinBox()
        self.cost_price_input.setMinimum(1)
        self.cost_price_input.setMaximum(1000000)
        self.cost_price_input.setDecimals(0)
        if self.product.cost_price:
            self.cost_price_input.setValue(self.product.cost_price)
        self.cost_price_input.valueChanged.connect(self.update_total)
        layout.addRow("Cost Price:", self.cost_price_input)

        # Total preview
        self.total_label = QLabel("0")
        layout.addRow("Total:", self.total_label)

        # Buttons
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

        # Initial calculations
        self.update_total()

        # Keyboard shortcuts
        QShortcut(QKeySequence(Qt.Key.Key_Return), self, self.validate_and_accept)
        QShortcut(QKeySequence(Qt.Key.Key_Enter), self, self.validate_and_accept)

    def update_total(self):
        quantity = self.quantity_input.value()
        price = self.cost_price_input.value()
        total = round(quantity * price)
        self.total_label.setText(format_price(total))

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, show_dialog=True)
    def validate_and_accept(self):
        try:
            quantity = validate_float(self.quantity_input.value(), min_value=0.001)
            price = validate_float(self.cost_price_input.value(), min_value=1)
            self.accept()
        except ValidationException as e:
            raise ValidationException(str(e))

    def get_item_data(self):
        return {
            "product_id": self.product.id,
            "product_name": self.product.name,
            "quantity": self.quantity_input.value(),
            "cost_price": round(self.cost_price_input.value()),
        }

class PurchaseView(QWidget):
    purchase_updated = Signal()

    def __init__(self):
        super().__init__()
        self.purchase_service = PurchaseService()
        self.product_service = ProductService()
        self.setup_ui()
        self.setup_scan_sound()

    def setup_scan_sound(self):
        self.scan_sound = QSoundEffect()
        sound_file = os.path.join(os.path.dirname(__file__), "resources", "scan.wav")
        self.scan_sound.setSource(QUrl.fromLocalFile(sound_file))
        self.scan_sound.setVolume(0.5)

    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Input fields
        input_layout = QHBoxLayout()
        self.supplier_input = QLineEdit()
        self.supplier_input.setPlaceholderText("Enter supplier name")
        
        self.date_input = QDateEdit()
        self.date_input.setDate(QDate.currentDate())
        self.date_input.setCalendarPopup(True)

        # Barcode and search section
        barcode_layout = QHBoxLayout()
        
        # Barcode input
        self.barcode_input = QLineEdit()
        self.barcode_input.setPlaceholderText("Scan barcode...")
        self.barcode_input.returnPressed.connect(self.handle_barcode_scan)
        self.barcode_input.textChanged.connect(self.handle_barcode_input)
        
        # Manual search
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search products...")
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_products)
        
        barcode_layout.addWidget(QLabel("Barcode:"))
        barcode_layout.addWidget(self.barcode_input)
        barcode_layout.addWidget(QLabel("Manual Search:"))
        barcode_layout.addWidget(self.search_input)
        barcode_layout.addWidget(search_button)

        input_layout.addWidget(QLabel("Supplier:"))
        input_layout.addWidget(self.supplier_input)
        input_layout.addWidget(QLabel("Date:"))
        input_layout.addWidget(self.date_input)

        layout.addLayout(input_layout)
        layout.addLayout(barcode_layout)

        # Purchase items table
        self.purchase_items_table = create_table(
            ["Product ID", "Product Name", "Quantity", "Cost Price", "Total", "Actions"]
        )
        self.purchase_items_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.purchase_items_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        layout.addWidget(self.purchase_items_table)

        # Total amount display
        total_layout = QHBoxLayout()
        self.total_amount_label = QLabel("Total: $0")
        self.total_amount_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        total_layout.addStretch()
        total_layout.addWidget(self.total_amount_label)
        layout.addLayout(total_layout)

        # Action buttons
        button_layout = QHBoxLayout()
        complete_button = QPushButton("Complete Purchase")
        complete_button.clicked.connect(self.complete_purchase)
        complete_button.setStyleSheet("background-color: #4CAF50; color: white;")
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.clear_purchase)
        cancel_button.setStyleSheet("background-color: #f44336; color: white;")
        button_layout.addWidget(complete_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        # Purchase history table
        self.purchase_table = create_table(
            ["ID", "Supplier", "Date", "Total Amount", "Actions"]
        )
        self.purchase_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.purchase_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.purchase_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.purchase_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.purchase_table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.purchase_table)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Set up shortcuts
        self.setup_shortcuts()

        # Load initial data
        self.load_purchases()
        self.purchase_items = []
        
        # Focus barcode input
        self.barcode_input.setFocus()

    def setup_shortcuts(self):
        # Barcode field focus (Ctrl+B)
        barcode_shortcut = QShortcut(QKeySequence("Ctrl+B"), self)
        barcode_shortcut.activated.connect(lambda: self.barcode_input.setFocus())
        
        # Clear purchase (Esc)
        clear_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Escape), self)
        clear_shortcut.activated.connect(self.clear_purchase)
        
        # Complete purchase (Ctrl+Enter)
        complete_shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        complete_shortcut.activated.connect(self.complete_purchase)
        
        # Refresh (F5)
        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.load_purchases)
        self.addAction(refresh_shortcut)

    def handle_barcode_input(self, text: str):
        """Handle barcode input changes."""
        # If text is longer than typical barcode, clear it
        if len(text) > 14:  # EAN-14 is the longest common barcode
            self.barcode_input.clear()

    def handle_barcode_scan(self):
        """Handle barcode scan completion."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return

        try:
            # Find product by barcode
            product = self.find_product_by_barcode(barcode)
            if product:
                # Play success sound
                self.scan_sound.play()
                
                # Show product dialog
                dialog = PurchaseItemDialog(product, self)
                if dialog.exec():
                    self.add_purchase_item(dialog.get_item_data())
                
                # Clear and refocus barcode input
                self.barcode_input.clear()
                self.barcode_input.setFocus()
            else:
                # Visual feedback for error
                self.barcode_input.setStyleSheet("background-color: #ffebee;")
                QTimer.singleShot(1000, lambda: self.barcode_input.setStyleSheet(""))
                show_error_message("Error", f"No product found with barcode: {barcode}")
        except Exception as e:
            logger.error(f"Error processing barcode: {str(e)}")
            show_error_message("Error", f"Failed to process barcode: {str(e)}")
        finally:
            self.barcode_input.clear()

    def find_product_by_barcode(self, barcode: str) -> Optional[Any]:
        """Find a product by its barcode."""
        products = self.product_service.get_all_products()
        return next((p for p in products if p.barcode == barcode), None)

    def update_purchase_items_table(self):
        """Update the purchase items table."""
        self.purchase_items_table.setRowCount(len(self.purchase_items))
        total_amount = 0

        for row, item in enumerate(self.purchase_items):
            self.purchase_items_table.setItem(row, 0, NumericTableWidgetItem(item["product_id"]))
            self.purchase_items_table.setItem(row, 1, QTableWidgetItem(item["product_name"]))
            self.purchase_items_table.setItem(row, 2, NumericTableWidgetItem(item["quantity"]))
            self.purchase_items_table.setItem(row, 3, PriceTableWidgetItem(item["cost_price"], format_price))
            
            item_total = round(item["quantity"] * item["cost_price"])
            total_amount += item_total
            self.purchase_items_table.setItem(row, 4, PriceTableWidgetItem(item_total, format_price))

            # Actions
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            actions_layout.setContentsMargins(0, 0, 0, 0)

            remove_button = QPushButton("Remove")
            remove_button.clicked.connect(lambda _, i=row: self.remove_purchase_item(i))
            remove_button.setMaximumWidth(60)
            actions_layout.addWidget(remove_button)

            self.purchase_items_table.setCellWidget(row, 5, actions_widget)

        self.total_amount_label.setText(f"Total: {format_price(total_amount)}")

    def add_purchase_item(self, item_data: dict):
        """Add an item to the purchase."""
        self.purchase_items.append(item_data)
        self.update_purchase_items_table()

    def remove_purchase_item(self, row: int):
        """Remove an item from the purchase."""
        if 0 <= row < len(self.purchase_items):
            del self.purchase_items[row]
            self.update_purchase_items_table()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def complete_purchase(self):
        """Complete the current purchase."""
        supplier = validate_string(self.supplier_input.text().strip(), min_length=1, max_length=100)
        if not supplier:
            raise ValidationException("Please enter a supplier name")

        if not self.purchase_items:
            raise ValidationException("Please add at least one item to the purchase")

        try:
            date_str = self.date_input.date().toString("yyyy-MM-dd")
            purchase_id = self.purchase_service.create_purchase(
                supplier, 
                date_str,
                self.purchase_items
            )

            if purchase_id:
                self.load_purchases()
                self.clear_purchase()
                show_info_message("Success", "Purchase completed successfully")
                event_system.purchase_added.emit(purchase_id)
                self.purchase_updated.emit()
            else:
                raise DatabaseException("Failed to create purchase")
                
        except Exception as e:
            logger.error(f"Error completing purchase: {str(e)}")
            raise

    def update_purchase_table(self, purchases: List[Purchase]):
        """Update the purchases history table."""
        self.purchase_table.setRowCount(len(purchases))
        for row, purchase in enumerate(purchases):
            self.purchase_table.setItem(row, 0, NumericTableWidgetItem(purchase.id))
            self.purchase_table.setItem(row, 1, QTableWidgetItem(purchase.supplier))
            self.purchase_table.setItem(row, 2, QTableWidgetItem(purchase.date.strftime("%Y-%m-%d")))
            self.purchase_table.setItem(row, 3, PriceTableWidgetItem(purchase.total_amount, format_price))

            # Actions
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            actions_layout.setContentsMargins(0, 0, 0, 0)

            view_button = QPushButton("View")
            view_button.clicked.connect(lambda _, p=purchase: self.view_purchase(p))
            view_button.setToolTip("View purchase details")

            delete_button = QPushButton("Delete")
            delete_button.clicked.connect(lambda _, p=purchase: self.delete_purchase(p))
            delete_button.setToolTip("Delete this purchase")

            for btn in [view_button, delete_button]:
                btn.setMaximumWidth(60)
                actions_layout.addWidget(btn)

            self.purchase_table.setCellWidget(row, 4, actions_widget)

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_purchases(self):
        """Load all purchases."""
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
        try:
            purchases = self.purchase_service.get_all_purchases()
            QTimer.singleShot(0, lambda: self.update_purchase_table(purchases))
            logger.info(f"Loaded {len(purchases)} purchases")
        except Exception as e:
            logger.error(f"Error loading purchases: {str(e)}")
            raise DatabaseException(f"Failed to load purchases: {str(e)}")
        finally:
            QApplication.restoreOverrideCursor()
            self.progress_bar.setValue(100)
            QTimer.singleShot(1000, lambda: self.progress_bar.setVisible(False))

    def search_products(self):
        """Search for products manually."""
        search_term = self.search_input.text().strip()
        if not search_term:
            return

        try:
            products = self.product_service.search_products(search_term)
            if not products:
                show_error_message("Not Found", "No products found matching the search term")
                return

            # If only one product found, show it directly
            if len(products) == 1:
                dialog = PurchaseItemDialog(products[0], self)
                if dialog.exec():
                    self.add_purchase_item(dialog.get_item_data())
                return

            # If multiple products, show selection dialog
            product = self.show_product_selection_dialog(products)
            if product:
                dialog = PurchaseItemDialog(product, self)
                if dialog.exec():
                    self.add_purchase_item(dialog.get_item_data())

        except Exception as e:
            logger.error(f"Error searching products: {str(e)}")
            show_error_message("Error", str(e))

    def show_product_selection_dialog(self, products: List[Any]) -> Optional[Any]:
        """Show dialog for selecting from multiple matching products."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Product")
        layout = QVBoxLayout(dialog)

        product_list = QComboBox()
        for product in products:
            display_text = f"{product.name}"
            if product.barcode:
                display_text += f" (Barcode: {product.barcode})"
            product_list.addItem(display_text, product)

        layout.addWidget(QLabel("Select a product:"))
        layout.addWidget(product_list)

        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            return product_list.currentData()
        return None

    def show_context_menu(self, position):
        """Show context menu for purchases table."""
        menu = QMenu()
        view_action = menu.addAction("View")
        delete_action = menu.addAction("Delete")

        action = menu.exec(self.purchase_table.mapToGlobal(position))
        if action:
            row = self.purchase_table.rowAt(position.y())
            purchase_id = int(self.purchase_table.item(row, 0).text())
            purchase = self.purchase_service.get_purchase(purchase_id)

            if purchase is not None:
                if action == view_action:
                    self.view_purchase(purchase)
                elif action == delete_action:
                    self.delete_purchase(purchase)
            else:
                show_error_message("Error", f"Purchase with ID {purchase_id} not found")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def view_purchase(self, purchase: Purchase):
        """View purchase details."""
        try:
            items = self.purchase_service.get_purchase_items(purchase.id)
            
            message = f"<pre>"
            message += f"{' Purchase Details ':=^64}\n\n"
            message += f"Supplier: {purchase.supplier}\n"
            message += f"Date: {purchase.date.strftime('%d-%m-%Y')}\n"
            message += f"{'':=^64}\n\n"
            message += f"{'Product':<30}{'Quantity':>10}{'Unit Cost':>12}{'Total':>12}\n"
            message += f"{'':-^64}\n"
            
            for item in items:
                product = self.product_service.get_product(item.product_id)
                product_name = product.name if product else "Unknown Product"
                total = item.quantity * item.price
                message += f"{product_name[:30]:<30}{item.quantity:>10.2f}{format_price(item.price):>12}{format_price(total):>12}\n"
            
            message += f"{'':-^64}\n"
            message += f"{'Total:':<45}{format_price(purchase.total_amount):>19}\n"
            message += "</pre>"

            show_info_message("Purchase Details", message)

        except Exception as e:
            logger.error(f"Error viewing purchase: {str(e)}")
            raise UIException(f"Failed to view purchase: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_purchase(self, purchase: Purchase):
        """Delete a purchase."""
        reply = QMessageBox.question(
            self,
            "Delete Purchase",
            "Are you sure you want to delete this purchase? This action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            try:
                self.purchase_service.delete_purchase(purchase.id)
                self.load_purchases()
                show_info_message("Success", "Purchase deleted successfully")
                event_system.purchase_deleted.emit(purchase.id)
                self.purchase_updated.emit()
            except Exception as e:
                logger.error(f"Error deleting purchase: {str(e)}")
                raise

    def clear_purchase(self):
        """Clear current purchase data."""
        self.supplier_input.clear()
        self.date_input.setDate(QDate.currentDate())
        self.purchase_items = []
        self.update_purchase_items_table()
        self.barcode_input.clear()
        self.barcode_input.setFocus()
        self.search_input.clear()
        self.total_amount_label.setText("Total: $0")

    def refresh(self):
        """Refresh the purchases view."""
        self.load_purchases()
        self.barcode_input.setFocus()

    def keyPressEvent(self, event):
        """Handle key press events."""
        if event.key() == Qt.Key.Key_F5:
            self.refresh()
        elif event.key() == Qt.Key.Key_Delete:
            selected_rows = self.purchase_table.selectionModel().selectedRows()
            if selected_rows:
                row = selected_rows[0].row()
                purchase_id = int(self.purchase_table.item(row, 0).text())
                purchase = self.purchase_service.get_purchase(purchase_id)
                if purchase:
                    self.delete_purchase(purchase)
        elif event.key() == Qt.Key.Key_Escape:
            self.clear_purchase()
        else:
            super().keyPressEvent(event)


C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/sale_view.py:
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, 
    QTableWidget, QTableWidgetItem, QMessageBox, QDialog, QDialogButtonBox, 
    QFormLayout, QDateEdit, QComboBox, QDoubleSpinBox, QSpinBox, QHeaderView,
    QMenu, QApplication, QFileDialog
)
from PySide6.QtMultimedia import QSoundEffect
from PySide6.QtCore import Qt, QDate, QTimer, Signal, QUrl, QPoint
from PySide6.QtGui import QAction, QKeySequence, QShortcut
from services.sale_service import SaleService
from services.customer_service import CustomerService
from services.product_service import ProductService
from models.customer import Customer
from models.sale import Sale
from models.product import Product
from utils.helpers import (
    create_table, show_error_message, show_info_message, format_price, confirm_action
)
from utils.system.event_system import event_system
from utils.ui.table_items import NumericTableWidgetItem, PriceTableWidgetItem
from typing import List, Optional, Dict, Any
from utils.decorators import ui_operation, handle_exceptions
from utils.exceptions import ValidationException, DatabaseException, UIException
from utils.validation.validators import validate_date
from utils.system.logger import logger
from utils.ui.sound import SoundEffect
from utils.validation.validators import validate_money
from datetime import datetime, timedelta


class EditSaleDialog(QDialog):
    def __init__(self, sale: Sale, sale_service: SaleService, customer_service: CustomerService, 
                 product_service: ProductService, parent=None):
        super().__init__(parent)
        self.sale = sale
        self.sale_service = sale_service
        self.customer_service = customer_service
        self.product_service = product_service
        self.sale_items = []
        self.selected_customer_id = sale.customer_id
        
        self.setWindowTitle(f"Edit Sale #{sale.id}")
        self.setup_ui()
        self.load_sale_data()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Customer info section
        customer_group = QWidget()
        customer_layout = QHBoxLayout(customer_group)
        self.customer_info_label = QLabel()
        customer_layout.addWidget(QLabel("Customer:"))
        customer_layout.addWidget(self.customer_info_label)
        layout.addWidget(customer_group)

        # Date section
        date_group = QWidget()
        date_layout = QHBoxLayout(date_group)
        self.date_input = QDateEdit()
        self.date_input.setCalendarPopup(True)
        self.date_input.setMinimumWidth(120)
        date_layout.addWidget(QLabel("Date:"))
        date_layout.addWidget(self.date_input)
        date_layout.addStretch()
        layout.addWidget(date_group)

        # Barcode and search section
        barcode_group = QWidget()
        barcode_layout = QHBoxLayout(barcode_group)
        
        self.barcode_input = QLineEdit()
        self.barcode_input.setPlaceholderText("Scan barcode...")
        self.barcode_input.returnPressed.connect(self.handle_barcode_scan)
        
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search products...")
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_products)
        
        barcode_layout.addWidget(QLabel("Barcode:"))
        barcode_layout.addWidget(self.barcode_input)
        barcode_layout.addWidget(QLabel("Search:"))
        barcode_layout.addWidget(self.search_input)
        barcode_layout.addWidget(search_button)
        layout.addWidget(barcode_group)

        # Items table
        self.items_table = create_table(
            ["Product ID", "Product Name", "Quantity", "Unit Price", "Total", "Actions"]
        )
        layout.addWidget(self.items_table)

        # Total amount
        total_layout = QHBoxLayout()
        self.total_amount_label = QLabel("Total: $ 0")
        self.total_amount_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        total_layout.addStretch()
        total_layout.addWidget(self.total_amount_label)
        layout.addLayout(total_layout)

        # Dialog buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Save | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        # Set dialog size
        self.resize(800, 600)

    def load_sale_data(self):
        try:
            # Load customer info
            customer = self.customer_service.get_customer(self.sale.customer_id)
            if customer:
                display_parts = []
                if customer.identifier_3or4:
                    display_parts.append(customer.identifier_3or4)
                if customer.name:
                    display_parts.append(customer.name)
                display_parts.append(customer.identifier_9)
                self.customer_info_label.setText(" - ".join(display_parts))

            # Set date
            qdate = QDate.fromString(self.sale.date.strftime("%Y-%m-%d"), "yyyy-MM-dd")
            self.date_input.setDate(qdate)

            # Load items
            items = self.sale_service.get_sale_items(self.sale.id)
            for item in items:
                # Get the product to ensure we have the correct name
                product = self.product_service.get_product(item.product_id)
                item_data = {
                    "product_id": item.product_id,
                    "product_name": product.name if product else "Unknown Product",
                    "quantity": item.quantity,
                    "sell_price": item.unit_price,
                    "profit": item.profit
                }
                self.sale_items.append(item_data)
            
            self.update_items_table()

        except Exception as e:
            logger.error(f"Error loading sale data: {str(e)}")
            raise

    def update_items_table(self):
        """Update the items table display."""
        self.items_table.setRowCount(len(self.sale_items))
        total_amount = 0
        
        for row, item in enumerate(self.sale_items):
            self.items_table.setItem(row, 0, NumericTableWidgetItem(item["product_id"]))
            self.items_table.setItem(row, 1, QTableWidgetItem(item["product_name"]))
            self.items_table.setItem(row, 2, NumericTableWidgetItem(item["quantity"]))
            self.items_table.setItem(row, 3, PriceTableWidgetItem(item["sell_price"], format_price))
            
            # Calculate and display total for this item
            item_total = round(item["quantity"] * item["sell_price"])
            total_amount += item_total
            self.items_table.setItem(row, 4, PriceTableWidgetItem(item_total, format_price))

            # Actions
            actions_widget = QWidget()
            actions_layout = QHBoxLayout(actions_widget)
            actions_layout.setContentsMargins(0, 0, 0, 0)

            remove_button = QPushButton("Remove")
            remove_button.clicked.connect(lambda _, i=row: self.remove_item(i))
            remove_button.setMaximumWidth(60)
            actions_layout.addWidget(remove_button)

            self.items_table.setCellWidget(row, 5, actions_widget)

        self.total_amount_label.setText(f"Total: {format_price(total_amount)}")

    def handle_barcode_scan(self):
        """Handle barcode scan event."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return

        try:
            product = self.product_service.get_product_by_barcode(barcode)
            if product:
                dialog = SaleItemDialog(product, self)
                if dialog.exec():
                    self.add_item(dialog.get_item_data())
                self.barcode_input.clear()
            else:
                self.barcode_input.setStyleSheet("background-color: #ffebee;")
                QTimer.singleShot(1000, lambda: self.barcode_input.setStyleSheet(""))
                show_error_message("Error", f"No product found with barcode: {barcode}")
        except Exception as e:
            logger.error(f"Error processing barcode: {str(e)}")
            show_error_message("Error", str(e))

    def search_products(self):
        """Search for products manually."""
        search_term = self.search_input.text().strip()
        if not search_term:
            return

        try:
            products = self.product_service.search_products(search_term)
            if products:
                if len(products) == 1:
                    dialog = SaleItemDialog(products[0], self)
                    if dialog.exec():
                        self.add_item(dialog.get_item_data())
                else:
                    product = self.show_product_selection_dialog(products)
                    if product:
                        dialog = SaleItemDialog(product, self)
                        if dialog.exec():
                            self.add_item(dialog.get_item_data())
            else:
                show_error_message("Not Found", "No products found matching the search term")
        except Exception as e:
            logger.error(f"Error searching products: {str(e)}")
            show_error_message("Error", str(e))

    def add_item(self, item_data: Dict[str, Any]):
        """Add an item to the sale."""
        self.sale_items.append(item_data)
        self.update_items_table()

    def remove_item(self, row: int):
        """Remove an item from the sale."""
        if 0 <= row < len(self.sale_items):
            del self.sale_items[row]
            self.update_items_table()

    def show_product_selection_dialog(self, products: List[Product]) -> Optional[Product]:
        """Show dialog for selecting from multiple matching products."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Product")
        layout = QVBoxLayout(dialog)

        product_list = QComboBox()
        for product in products:
            display_text = f"{product.name}"
            if product.barcode:
                display_text += f" (Barcode: {product.barcode})"
            product_list.addItem(display_text, product)

        layout.addWidget(QLabel("Select a product:"))
        layout.addWidget(product_list)

        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            return product_list.currentData()
        return None

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def accept(self):
        """Handle dialog acceptance and save changes."""
        if not self.sale_items:
            raise ValidationException("Please add at least one item to the sale")

        try:
            date = self.date_input.date().toString("yyyy-MM-dd")
            
            # Update the sale
            self.sale_service.update_sale(
                sale_id=self.sale.id,
                customer_id=self.selected_customer_id,
                date=date,
                items=self.sale_items
            )
            
            super().accept()
            
        except Exception as e:
            logger.error(f"Error updating sale: {str(e)}")
            raise


class SaleItemDialog(QDialog):
    def __init__(self, product: Product, parent=None):
        super().__init__(parent)
        self.product = product
        self.setWindowTitle("Add Item")
        self.setup_ui()
        self.setup_product_details(product)

    def setup_ui(self):
        layout = QFormLayout(self)
        
        # Product name label
        self.product_name_label = QLabel()
        layout.addRow("Product:", self.product_name_label)
        
        # Quantity input - Allow 3 decimal places
        self.quantity_input = QDoubleSpinBox()
        self.quantity_input.setMinimum(0.001)
        self.quantity_input.setMaximum(1000000.000)
        self.quantity_input.setDecimals(3)
        self.quantity_input.setValue(1.000)
        self.quantity_input.valueChanged.connect(self.update_total)
        layout.addRow("Quantity:", self.quantity_input)

        # Price input (pre-filled with product price) - Integer only
        self.price_input = QSpinBox()
        self.price_input.setMinimum(1)
        self.price_input.setMaximum(1000000000)
        self.price_input.setPrefix("$ ")
        self.price_input.valueChanged.connect(self.format_price_display)
        if self.product.sell_price:
            self.price_input.setValue(int(self.product.sell_price))
        layout.addRow("Unit Price:", self.price_input)

        # Total and profit preview
        self.total_label = QLabel("$ 0")
        layout.addRow("Total:", self.total_label)
        self.profit_label = QLabel("$ 0")
        layout.addRow("Profit:", self.profit_label)

        # Buttons
        self.button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        self.button_box.accepted.connect(self.validate_and_accept)
        self.button_box.rejected.connect(self.reject)
        layout.addRow(self.button_box)

        # Initial calculations
        self.update_total()

        # Keyboard shortcuts
        QShortcut(QKeySequence(Qt.Key.Key_Return), self, self.validate_and_accept)
        QShortcut(QKeySequence(Qt.Key.Key_Enter), self, self.validate_and_accept)

    def format_price_display(self, value: int) -> None:
        """Format the price display with dots as thousand separators."""
        formatted = f"$ {value:,}".replace(",", ".")
        self.price_input.setSpecialValueText("")  # Prevents "$ 0" from showing when empty
        self.price_input.setPrefix("")  # Clear prefix temporarily
        self.price_input.setSuffix(f" ({formatted})")  # Show formatted value as suffix

    def update_total(self) -> None:
        """Calculate total and profit with proper rounding for Chilean Pesos."""
        try:
            quantity = self.quantity_input.value()
            unit_price = self.price_input.value()
            total = int(quantity * unit_price)
            
            # Calculate profit
            if self.product.cost_price is not None:
                profit = int(round(quantity * (unit_price - self.product.cost_price)))
                self.profit_label.setText(f"$ {profit:,}".replace(",", "."))
            else:
                profit = 0
            
            self.total_label.setText(format_price(total))
            self.profit_label.setText(format_price(profit))
        except Exception as e:
            logger.error(f"Error updating totals: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, show_dialog=True)
    def validate_and_accept(self):
        try:
            # Validate quantity (3 decimal places)
            quantity = round(self.quantity_input.value(), 3)
            if quantity <= 0:
                raise ValidationException("Quantity must be positive")
            
            # Validate price (integer)
            price = int(self.price_input.value())
            if price <= 0:
                raise ValidationException("Price must be positive")
            
            self.accept()
            
        except (ValueError, TypeError) as e:
            raise ValidationException(f"Invalid input: {str(e)}")

    def get_item_data(self) -> Dict[str, Any]:
        """Get the sale item data with proper types."""
        try:
            quantity = round(self.quantity_input.value(), 3)
            sell_price = int(self.price_input.value())
            
            # Calculate profit with proper rounding
            if self.product.cost_price is not None:
                cost_price = int(self.product.cost_price)
                profit = int(round(quantity * (sell_price - cost_price)))
            else:
                profit = 0

            return {
                "product_id": self.product.id,
                "product_name": self.product.name,
                "quantity": quantity,
                "sell_price": sell_price,
                "profit": profit
            }
        except (ValueError, TypeError) as e:
            logger.error(f"Error preparing item data: {str(e)}")
            raise ValidationException("Invalid item data")

    def setup_product_details(self, product: Product):
        """Set up product details in the form."""
        try:
            self.product = product
            self.product_name_label.setText(product.name)
            self.quantity_input.setValue(1)
            self.quantity_input.setFocus()
        except Exception as e:
            logger.error(f"Error setting up product details: {str(e)}")
            show_error_message("Error", f"Failed to set up product details: {str(e)}")


class SaleView(QWidget):
    sale_updated = Signal()

    def __init__(self):
        super().__init__()
        self.sale_service = SaleService()
        self.customer_service = CustomerService()
        self.product_service = ProductService()
        self.setup_ui()
        self.setup_scan_sound()
        event_system.sale_added.connect(self.load_sales)

    def setup_scan_sound(self) -> None:
        """Initialize the sound system."""
        self.scan_sound = SoundEffect("scan.wav")


    def setup_ui(self):
        layout = QVBoxLayout(self)

        # Customer section
        customer_layout = QHBoxLayout()
        
        self.customer_id_input = QLineEdit()
        self.customer_id_input.setPlaceholderText("Enter Department number")
        self.customer_id_input.returnPressed.connect(self.select_customer)
        
        # Single label for all customer info
        self.customer_info_label = QLabel()
        self.customer_info_label.setStyleSheet("""
            QLabel {
                color: #666;
                padding: 5px;
                background-color: #f5f5f5;
                border-radius: 4px;
            }
        """)
        
        # Add input section to main customer layout
        customer_layout.addWidget(QLabel("Customer:"))
        customer_layout.addWidget(self.customer_id_input, stretch=1)  # Give input field more space
        customer_layout.addWidget(self.customer_info_label, stretch=2)  # Give info label even more space
        
        # Add select button
        select_button = QPushButton("Select")
        select_button.clicked.connect(self.select_customer)
        select_button.setFixedWidth(80)
        select_button.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                border-radius: 4px;
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        customer_layout.addWidget(select_button)
        
        layout.addLayout(customer_layout)

        # Barcode and search section
        barcode_layout = QHBoxLayout()
        
        # Barcode input
        self.barcode_input = QLineEdit()
        self.barcode_input.setPlaceholderText("Scan barcode...")
        self.barcode_input.returnPressed.connect(self.handle_barcode_scan)
        self.barcode_input.textChanged.connect(self.handle_barcode_input)
        
        # Manual search
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search products...")
        search_button = QPushButton("Search")
        search_button.clicked.connect(self.search_products)
        
        barcode_layout.addWidget(QLabel("Barcode:"))
        barcode_layout.addWidget(self.barcode_input)
        barcode_layout.addWidget(QLabel("Manual Search:"))
        barcode_layout.addWidget(self.search_input)
        barcode_layout.addWidget(search_button)
        layout.addLayout(barcode_layout)

        # Date selection
        date_layout = QHBoxLayout()
        self.date_input = QDateEdit()
        self.date_input.setDate(QDate.currentDate())
        self.date_input.setCalendarPopup(True)
        self.date_input.setMinimumWidth(120)
        date_layout.addWidget(QLabel("Date:"))
        date_layout.addWidget(self.date_input)
        date_layout.addStretch()
        layout.addLayout(date_layout)

        # Sale items table
        self.sale_items_table = create_table(
            ["Product ID", "Product Name", "Quantity", "Unit Price", "Total", "Actions"]
        )
        self.sale_items_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        layout.addWidget(self.sale_items_table)

        # Total amount display
        total_layout = QHBoxLayout()
        self.total_amount_label = QLabel("Total: $ 0")
        self.total_amount_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        total_layout.addStretch()
        total_layout.addWidget(self.total_amount_label)
        layout.addLayout(total_layout)

        # Action buttons
        button_layout = QHBoxLayout()
        complete_sale_button = QPushButton("Complete Sale")
        complete_sale_button.clicked.connect(self.complete_sale)
        complete_sale_button.setStyleSheet("background-color: #4CAF50; color: white;")
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.clear_sale)
        cancel_button.setStyleSheet("background-color: #f44336; color: white;")
        button_layout.addWidget(complete_sale_button)
        button_layout.addWidget(cancel_button)
        layout.addLayout(button_layout)

        # Sales history table
        self.sale_table = create_table(
            ["ID", "Customer ID-9", "Department", "Customer Name", "Date", 
             "Total Amount", "Total Profit", "Receipt ID", "Actions"]
        )
        self.sale_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.sale_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.sale_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.sale_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.sale_table.customContextMenuRequested.connect(self.show_context_menu)
        layout.addWidget(self.sale_table)

        # Set up shortcuts
        self.setup_shortcuts()

        # Load initial data
        self.load_sales()
        self.sale_items = []
        
        # Focus barcode input
        self.barcode_input.setFocus()

    def setup_shortcuts(self):
        # Barcode field focus (Ctrl+B)
        barcode_shortcut = QShortcut(QKeySequence("Ctrl+B"), self)
        barcode_shortcut.activated.connect(lambda: self.barcode_input.setFocus())
        
        # Clear sale (Esc)
        clear_shortcut = QShortcut(QKeySequence(Qt.Key.Key_Escape), self)
        clear_shortcut.activated.connect(self.clear_sale)
        
        # Complete sale (Ctrl+Enter)
        complete_shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        complete_shortcut.activated.connect(self.complete_sale)
        
        # Refresh (F5)
        refresh_shortcut = QAction("Refresh", self)
        refresh_shortcut.setShortcut(QKeySequence("F5"))
        refresh_shortcut.triggered.connect(self.load_sales)
        self.addAction(refresh_shortcut)

    def handle_barcode_input(self, text: str):
        """Handle barcode input changes."""
        # If text is longer than typical barcode, clear it
        if len(text) > 14:  # EAN-14 is the longest common barcode
            self.barcode_input.clear()

    def handle_barcode_scan(self):
        """Handle barcode scan completion."""
        barcode = self.barcode_input.text().strip()
        if not barcode:
            return

        try:
            # Find product by barcode
            product = self.product_service.get_product_by_barcode(barcode)
            if product:
                self.scan_sound.play()
                
                # Show product dialog
                dialog = SaleItemDialog(product, self)
                if dialog.exec():
                    self.add_sale_item(dialog.get_item_data())
                
                # Clear and refocus barcode input
                self.barcode_input.clear()
                self.barcode_input.setFocus()
            else:
                # Visual feedback for error
                self.barcode_input.setStyleSheet("background-color: #ffebee;")
                QTimer.singleShot(1000, lambda: self.barcode_input.setStyleSheet(""))
                show_error_message("Error", f"No product found with barcode: {barcode}")
        except Exception as e:
            logger.error(f"Error processing barcode: {str(e)}")
            show_error_message("Error", f"Failed to process barcode: {str(e)}")
        finally:
            self.barcode_input.clear()

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def select_customer(self):
        """Handle customer selection."""
        identifier = self.customer_id_input.text().strip()
        if not identifier:
            show_error_message("Error", "Please enter a customer identifier")
            return

        try:
            customer = None
            if len(identifier) == 9:
                # Try 9-digit identifier first
                customer = self.customer_service.get_customer_by_identifier_9(identifier)
            elif len(identifier) in (3, 4):
                # Try 3/4-digit identifier
                customers = self.customer_service.get_customers_by_identifier_3or4(identifier)
                
                # Add logging to check for duplicates
                logger.debug(f"Found {len(customers)} customers for identifier {identifier}")
                for c in customers:
                    logger.debug(f"Customer found: ID={c.id}, identifier_9={c.identifier_9}, identifier_3or4={c.identifier_3or4}")
                
                # Remove duplicates based on identifier_9 (phone number)
                unique_customers = []
                seen_phones = set()
                for c in customers:
                    if c.identifier_9 not in seen_phones:
                        unique_customers.append(c)
                        seen_phones.add(c.identifier_9)
                    else:
                        logger.warning(f"Duplicate customer found with phone {c.identifier_9} for department {identifier}")
                
                if len(unique_customers) == 1:
                    customer = unique_customers[0]
                elif len(unique_customers) > 1:
                    customer = self.show_customer_selection_dialog(unique_customers)
                
            else:
                show_error_message("Error", "Please enter a 3/4-digit or 9-digit identifier")
                return

            if customer:
                self.selected_customer_id = customer.id
                # Format customer info in the requested format: "3/4 digits id - Name - 9 digits id"
                display_parts = []
                if customer.identifier_3or4:
                    display_parts.append(customer.identifier_3or4)
                if customer.name:
                    display_parts.append(customer.name)
                display_parts.append(customer.identifier_9)
                
                customer_info = " - ".join(display_parts)
                self.customer_info_label.setText(customer_info)
                self.customer_id_input.clear()  # Clear the input field
                self.barcode_input.setFocus()  # Move focus to barcode input
            else:
                show_error_message("Error", "No customer found with the given identifier")
                self.customer_info_label.clear()

        except Exception as e:
            logger.error(f"Error selecting customer: {str(e)}")
            show_error_message("Error", str(e))

    def show_customer_selection_dialog(self, customers: List[Customer]) -> Optional[Customer]:
        """Show dialog for selecting from multiple matching customers."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Customer")
        layout = QVBoxLayout(dialog)

        customer_list = QComboBox()
        for customer in customers:
            # Format display text with all available information
            display_parts = []
            if customer.identifier_3or4:
                display_parts.append(f"Dept: {customer.identifier_3or4}")
            if customer.name:
                display_parts.append(f"Name: {customer.name}")
            display_parts.append(f"Phone: {customer.identifier_9}")
            display_text = " | ".join(display_parts)
            customer_list.addItem(display_text, customer)

        layout.addWidget(QLabel("Multiple customers found. Please select one:"))
        layout.addWidget(customer_list)

        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            return customer_list.currentData()
        return None

    def add_sale_item(self, item_data: Dict[str, Any]):
        """Add an item to the sale."""
        self.sale_items.append(item_data)
        self.update_sale_items_table()

    def remove_sale_item(self, row: int):
        """Remove an item from the sale."""
        if 0 <= row < len(self.sale_items):
            del self.sale_items[row]
            self.update_sale_items_table()

    def update_sale_items_table(self):
        """Update the sale items table display."""
        self.sale_items_table.setRowCount(len(self.sale_items))
        for row, item in enumerate(self.sale_items):
            # Create display for the row
            self.create_item_display(item, row)
        self.update_totals_display()

    def create_item_display(self, item: Dict[str, Any], row: int):
        """Create display widgets for a sale item row with proper formatting."""
        # Product ID and Name (unchanged)
        self.sale_items_table.setItem(row, 0, NumericTableWidgetItem(item["product_id"]))
        self.sale_items_table.setItem(row, 1, QTableWidgetItem(item["product_name"]))
        
        # Quantity with 3 decimal places
        quantity_item = NumericTableWidgetItem(round(item["quantity"], 3))
        quantity_item.setTextAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.sale_items_table.setItem(row, 2, quantity_item)
        
        # Unit price as integer with thousands separator
        price_item = PriceTableWidgetItem(item["sell_price"], format_price)
        self.sale_items_table.setItem(row, 3, price_item)
        
        # Total as integer with thousands separator
        total = int(round(item["quantity"] * item["sell_price"]))
        total_item = PriceTableWidgetItem(total, format_price)
        self.sale_items_table.setItem(row, 4, total_item)

        # Actions
        actions_widget = QWidget()
        actions_layout = QHBoxLayout(actions_widget)
        actions_layout.setContentsMargins(0, 0, 0, 0)

        remove_button = QPushButton("Remove")
        remove_button.clicked.connect(lambda _, i=row: self.remove_sale_item(i))
        remove_button.setMaximumWidth(60)
        actions_layout.addWidget(remove_button)

        self.sale_items_table.setCellWidget(row, 5, actions_widget)

    def update_totals_display(self):
        """Update the total amount display with proper Chilean Peso formatting."""
        total_amount = 0
        for item in self.sale_items:
            # Calculate total with proper rounding
            item_total = int(round(item["quantity"] * item["sell_price"]))
            total_amount += item_total
        
        # Format with thousands separator
        formatted_total = f"Total: {format_price(total_amount)}"
        self.total_amount_label.setText(formatted_total)

    def search_products(self):
        """Search for products manually."""
        search_term = self.search_input.text().strip()
        if not search_term:
            return

        try:
            products = self.product_service.search_products(search_term)
            if not products:
                show_error_message("Not Found", "No products found matching the search term")
                return

            # If only one product found, show it directly
            if len(products) == 1:
                dialog = SaleItemDialog(products[0], self)
                if dialog.exec():
                    self.add_sale_item(dialog.get_item_data())
                return

            # If multiple products, show selection dialog
            product = self.show_product_selection_dialog(products)
            if product:
                dialog = SaleItemDialog(product, self)
                if dialog.exec():
                    self.add_sale_item(dialog.get_item_data())

        except Exception as e:
            logger.error(f"Error searching products: {str(e)}")
            show_error_message("Error", str(e))

    def show_product_selection_dialog(self, products: List[Product]) -> Optional[Product]:
        """Show dialog for selecting from multiple matching products."""
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Product")
        layout = QVBoxLayout(dialog)

        product_list = QComboBox()
        for product in products:
            display_text = f"{product.name}"
            if product.barcode:
                display_text += f" (Barcode: {product.barcode})"
            product_list.addItem(display_text, product)

        layout.addWidget(QLabel("Select a product:"))
        layout.addWidget(product_list)

        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        if dialog.exec() == QDialog.DialogCode.Accepted:
            return product_list.currentData()
        return None

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def complete_sale(self):
        """Complete the current sale with proper money handling."""
        if not hasattr(self, "selected_customer_id"):
            raise ValidationException("Please select a customer first")

        if not self.sale_items:
            raise ValidationException("Please add at least one item to the sale")

        try:
            date = validate_date(self.date_input.date().toString("yyyy-MM-dd"))
            
            # Process items to ensure proper types
            processed_items = []
            for item in self.sale_items:
                processed_item = {
                    "product_id": int(item["product_id"]),
                    "product_name": str(item["product_name"]),
                    "quantity": round(float(item["quantity"]), 3),  # 3 decimal places
                    "sell_price": int(item["sell_price"]),  # Integer Chilean Pesos
                    "profit": int(item["profit"])  # Integer Chilean Pesos
                }
                processed_items.append(processed_item)

            sale_id = self.sale_service.create_sale(
                self.selected_customer_id,
                date,
                processed_items
            )

            if sale_id:
                self.load_sales()
                self.clear_sale()
                show_info_message("Success", "Sale completed successfully")
                
                # Ask about printing receipt
                reply = QMessageBox.question(
                    self,
                    "Print Receipt",
                    "Would you like to print the receipt?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes
                )
                
                if reply == QMessageBox.StandardButton.Yes:
                    sale = self.sale_service.get_sale(sale_id)
                    if sale:
                        self.print_receipt(sale)
                    else:
                        raise ValidationException(f"Sale with ID {sale_id} not found")
            else:
                raise DatabaseException("Failed to create sale")
                
        except Exception as e:
            logger.error(f"Error completing sale: {str(e)}")
            raise

    @ui_operation(show_dialog=True)
    @handle_exceptions(DatabaseException, UIException, show_dialog=True)
    def load_sales(self, sale_id=None):
        """Load all sales."""
        try:
            QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)
            sales = self.sale_service.get_all_sales()
            QTimer.singleShot(0, lambda: self.update_sale_table(sales))
            logger.info(f"Loaded {len(sales)} sales")
        except Exception as e:
            logger.error(f"Error loading sales: {str(e)}")
            raise DatabaseException(f"Failed to load sales: {str(e)}")
        finally:
            QApplication.restoreOverrideCursor()

    def update_sale_table(self, sales: List[Sale]):
        """Update the sales history table with proper formatting."""
        self.sale_table.setRowCount(len(sales))
        for row, sale in enumerate(sales):
            customer = self.customer_service.get_customer(sale.customer_id)
            
            # Basic sale information
            self.sale_table.setItem(row, 0, NumericTableWidgetItem(sale.id))
            
            # Customer information
            if customer:
                self.sale_table.setItem(row, 1, QTableWidgetItem(customer.identifier_9))
                self.sale_table.setItem(row, 2, QTableWidgetItem(customer.identifier_3or4 or "N/A"))
                self.sale_table.setItem(row, 3, QTableWidgetItem(customer.name or ""))
            else:
                self.sale_table.setItem(row, 1, QTableWidgetItem("Unknown"))
                self.sale_table.setItem(row, 2, QTableWidgetItem("N/A"))
                self.sale_table.setItem(row, 3, QTableWidgetItem(""))
            
            # Date
            date_item = QTableWidgetItem(sale.date.strftime("%Y-%m-%d"))
            date_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.sale_table.setItem(row, 4, date_item)
            
            # Money values with proper formatting
            self.sale_table.setItem(row, 5, PriceTableWidgetItem(sale.total_amount, format_price))
            self.sale_table.setItem(row, 6, PriceTableWidgetItem(sale.total_profit, format_price))
            
            # Receipt ID
            receipt_item = QTableWidgetItem(sale.receipt_id or "")
            receipt_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.sale_table.setItem(row, 7, receipt_item)

            # Actions
            self.create_sale_actions(row, sale)

    def create_sale_actions(self, row: int, sale: Sale) -> None:
        actions_widget = QWidget()
        actions_layout = QHBoxLayout(actions_widget)
        actions_layout.setContentsMargins(0, 0, 0, 0)

        view_button = QPushButton("View")
        view_button.clicked.connect(lambda: self._safe_view_sale(sale))
        view_button.setToolTip("View sale details")
        view_button.setMaximumWidth(60)

        edit_button = QPushButton("Edit")
        edit_button.clicked.connect(lambda: self._safe_edit_sale(sale))
        edit_button.setToolTip("Edit sale")
        edit_button.setMaximumWidth(60)

        print_button = QPushButton("Print")
        print_button.clicked.connect(lambda: self._safe_print_receipt(sale))
        print_button.setToolTip("Print receipt")
        print_button.setMaximumWidth(60)

        delete_button = QPushButton("Delete")
        delete_button.clicked.connect(lambda: self._safe_delete_sale(sale))
        delete_button.setToolTip("Delete this sale")
        delete_button.setMaximumWidth(60)
        
        if (sale.date is not None and 
            datetime.now() - sale.date > timedelta(hours=96)):
            edit_button.setEnabled(False)
            edit_button.setToolTip("Sales can only be edited within 96 hours")
            delete_button.setEnabled(False)
            delete_button.setToolTip("Sales can only be deleted within 96 hours")

        for btn in [view_button, edit_button, print_button, delete_button]:
            actions_layout.addWidget(btn)

        self.sale_table.setCellWidget(row, 8, actions_widget)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def edit_sale(self, sale: Sale) -> None:
        """Edit an existing sale."""
        if sale is None:
            raise ValidationException("No sale selected for editing")

        if datetime.now() - sale.date > timedelta(hours=96):
            raise ValidationException("Sales can only be edited within 96 hours of creation")

        try:
            dialog = EditSaleDialog(
                sale=sale,
                sale_service=self.sale_service,
                customer_service=self.customer_service,
                product_service=self.product_service,
                parent=self
            )
            
            if dialog.exec() == QDialog.DialogCode.Accepted:
                self.load_sales()
                show_info_message("Success", "Sale updated successfully")
                
        except Exception as e:
            logger.error(f"Error editing sale: {str(e)}")
            raise

    def _safe_edit_sale(self, sale: Optional[Sale]) -> None:
        """Safely handle edit sale action with null check."""
        if sale is None:
            show_error_message("Error", "No sale selected")
            return
        self.edit_sale(sale)

    def _safe_view_sale(self, sale: Optional[Sale]) -> None:
        """Safely handle view sale action with null check."""
        if sale is None:
            show_error_message("Error", "No sale selected")
            return
        self.view_sale(sale)

    def _safe_print_receipt(self, sale: Optional[Sale]) -> None:
        """Safely handle print receipt action with null check."""
        if sale is None:
            show_error_message("Error", "No sale selected")
            return
        self.print_receipt(sale)

    def _safe_delete_sale(self, sale: Optional[Sale]) -> None:
        """Safely handle delete sale action with null check."""
        if sale is None:
            show_error_message("Error", "No sale selected")
            return
        self.delete_sale(sale)

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def delete_sale(self, sale: Optional[Sale]) -> None:
        """Delete a sale with validation."""
        if sale is None:
            raise ValidationException("No sale selected for deletion")

        """
        if datetime.now() - sale.date > timedelta(hours=96):
            raise ValidationException("Sales can only be deleted within 96 hours of creation")
        """

        if not confirm_action(
            self,
            "Delete Sale",
            f"Are you sure you want to delete sale {sale.receipt_id or sale.id}?\n"
            f"Total amount: {format_price(sale.total_amount)}"
        ):
            return

        try:
            self.sale_service.delete_sale(sale.id)
            self.load_sales()
            show_info_message("Success", "Sale deleted successfully")
        except Exception as e:
            logger.error(f"Error deleting sale: {str(e)}")
            raise

    def clear_sale(self):
        """Clear current sale data."""
        self.sale_items = []
        self.update_sale_items_table()
        self.customer_id_input.clear()
        self.customer_info_label.clear()
        if hasattr(self, 'selected_customer_id'):
            del self.selected_customer_id
        self.barcode_input.clear()
        self.barcode_input.setFocus()
        self.search_input.clear()
        self.total_amount_label.setText("Total: $ 0")

    def show_context_menu(self, position: QPoint) -> None:
        menu = QMenu()
        view_action = menu.addAction("View")
        edit_action = menu.addAction("Edit")
        print_action = menu.addAction("Print")
        delete_action = menu.addAction("Delete")

        row = self.sale_table.rowAt(position.y())
        if row >= 0:
            sale_id = int(self.sale_table.item(row, 0).text())
            try:
                sale = self.sale_service.get_sale(sale_id)
                if sale is None:
                    show_error_message("Error", "Sale not found")
                    return
                
                # Disable edit/delete actions for old sales
                if sale.date and datetime.now() - sale.date > timedelta(hours=96):
                    edit_action.setEnabled(False)
                    delete_action.setEnabled(False)
                
                action = menu.exec(self.sale_table.mapToGlobal(position))
                if action:
                    if action == view_action:
                        self._safe_view_sale(sale)
                    elif action == edit_action and action.isEnabled():
                        self._safe_edit_sale(sale)
                    elif action == print_action:
                        self._safe_print_receipt(sale)
                    elif action == delete_action and action.isEnabled():
                        self._safe_delete_sale(sale)
                        
            except Exception as e:
                show_error_message("Error", str(e))

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def print_receipt(self, sale: Sale) -> None:
        """Print a sale receipt with proper money formatting."""
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save Receipt",
                f"receipt_{sale.id}.pdf",
                "PDF Files (*.pdf)"
            )
            
            if file_path:
                self.sale_service.save_receipt_as_pdf(sale.id, file_path)
                show_info_message("Success", f"Receipt saved to {file_path}")
                
                # Optional: preview receipt
                preview = self.generate_receipt_preview(sale)
                show_info_message("Receipt Preview", preview)
                
        except Exception as e:
            logger.error(f"Error printing receipt: {str(e)}")
            show_error_message("Error", f"Failed to print receipt: {str(e)}")

    @ui_operation(show_dialog=True)
    @handle_exceptions(ValidationException, DatabaseException, UIException, show_dialog=True)
    def view_sale(self, sale: Sale) -> None:
        """View sale details with proper money formatting."""
        try:
            items = self.sale_service.get_sale_items(sale.id)
            customer = self.customer_service.get_customer(sale.customer_id)
            
            receipt_id = sale.receipt_id or self.sale_service.generate_receipt(sale.id)

            # Format customer display
            if customer:
                customer_text = customer.identifier_9
                if customer.identifier_3or4:
                    customer_text += f" ({customer.identifier_3or4})"
                if customer.name:
                    customer_text += f" - {customer.name}"
            else:
                customer_text = "Unknown Customer"

            message = f"<pre>"
            message += f"{'Recibo #' + receipt_id:^64}\n\n"
            message += f"{' Detalles de venta ':=^64}\n\n"
            message += f"Cliente: {customer_text}\n"
            message += f"Fecha: {sale.date.strftime('%d-%m-%Y')}\n"
            message += f"{'':=^64}\n\n"
            message += f"{'Producto':<30}{'Cantidad':>10}{'P.Unit.':>12}{'Total':>12}\n"
            message += f"{'':-^64}\n"
            
            for item in items:
                product = self.product_service.get_product(item.product_id)
                product_name = product.name if product else "Unknown Product"
                message += (
                    f"{product_name[:30]:<30}"
                    f"{item.quantity:>10.3f}"
                    f"{format_price(item.unit_price):>12}"
                    f"{format_price(item.total_price()):>12}\n"
                )
            
            message += f"{'':-^64}\n"
            message += f"{'Total:':<45}{format_price(sale.total_amount):>19}\n"
            message += "</pre>"

            show_info_message("Sale Details", message)

            # Offer to print receipt
            reply = QMessageBox.question(
                self,
                "Print Receipt",
                "Would you like to print this receipt?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.print_receipt(sale)

        except Exception as e:
            logger.error(f"Error viewing sale: {str(e)}")
            raise UIException(f"Failed to view sale: {str(e)}")

    def generate_receipt_preview(self, sale: Sale) -> str:
        """Generate a text preview of the receipt with proper formatting."""
        try:
            customer = self.customer_service.get_customer(sale.customer_id)
            items = self.sale_service.get_sale_items(sale.id)
            
            receipt = []
            receipt.append(f"{'Recibo #' + str(sale.receipt_id or sale.id):^64}")
            receipt.append("\n")
            
            # Customer info
            if customer:
                customer_text = f"{customer.identifier_9}"
                if customer.identifier_3or4:
                    customer_text += f" ({customer.identifier_3or4})"
                if customer.name:
                    customer_text += f" - {customer.name}"
            else:
                customer_text = "Cliente no identificado"
            receipt.append(f"Cliente: {customer_text}")
            
            # Date
            if sale.date:
                receipt.append(f"Fecha: {sale.date.strftime('%d-%m-%Y')}")
            receipt.append("=" * 64)
            
            # Headers
            headers = "{:<30}{:>10}{:>12}{:>12}".format(
                "Producto", "Cantidad", "P.Unit.", "Total")
            receipt.append(headers)
            receipt.append("-" * 64)
            
            # Items with proper formatting
            for item in items:
                name = item.product_name if item.product_name else "Unknown Product"
                line = "{:<30}{:>10.3f}{:>12}{:>12}".format(
                    name[:30],
                    item.quantity,
                    format_price(item.unit_price),
                    format_price(item.total_price())
                )
                receipt.append(line)
            
            # Totals
            receipt.append("-" * 64)
            receipt.append("{:<52}{:>12}".format(
                "Total:",
                format_price(sale.total_amount)
            ))
            
            return "\n".join(receipt)
        except Exception as e:
            logger.error(f"Error generating receipt preview: {str(e)}")
            return "Error generating receipt preview"

    def refresh(self):
        """Refresh the sales view."""
        self.load_sales()
        self.barcode_input.setFocus()

    def keyPressEvent(self, event):
        """Handle key press events."""
        if event.key() == Qt.Key.Key_F5:
            self.refresh()
        elif event.key() == Qt.Key.Key_Delete:
            selected_rows = self.sale_table.selectionModel().selectedRows()
            if selected_rows:
                row = selected_rows[0].row()
                sale_id = int(self.sale_table.item(row, 0).text())
                try:
                    sale = self.sale_service.get_sale(sale_id)
                    if sale:
                        self.delete_sale(sale)
                except Exception as e:
                    show_error_message("Error", str(e))
        elif event.key() == Qt.Key.Key_Escape:
            self.clear_sale()
        else:
            super().keyPressEvent(event)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/resources/README.md:
# Resources Directory

This directory contains static resources used by the application UI.

## Contents

- scan.wav: Sound effect for barcode scanning

## Notes

- Sound files must be in WAV format
- Place any additional UI resources in this directory



C:/Users/corte/VS Code Projects/billing_inventory_system_new/ui/resources/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/decorators.py:
import functools
from typing import Callable, Type, Optional, TypeVar, ParamSpec, List, Any
from PySide6.QtWidgets import QMessageBox, QWidget, QApplication
from .exceptions import *
from utils.system.logger import logger
from utils.validation.validators import validate
import time

T = TypeVar("T")
P = ParamSpec("P")

def log_exception(exc: Exception, func_name: str, error_message: str) -> None:
    """Helper function to log exceptions."""
    logger.error(f"{error_message} in {func_name}", extra={"error": str(exc), "function": func_name})

def show_error_dialog(
    title: str, message: str, parent: Optional[QWidget] = None
) -> None:
    """Helper function to show error dialog to the user."""
    if parent is None:
        parent = QApplication.activeWindow()
    QMessageBox.critical(parent, title, message)

def handle_exceptions(
    *exception_types: Type[Exception], show_dialog: bool = False
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    A decorator to handle specified exception types.

    Args:
    - *exception_types: Exception types to be caught
    - show_dialog: Whether to show an error dialog to the user
    """

    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            try:
                return func(*args, **kwargs)
            except exception_types as e:
                error_message = f"Error in {func.__name__}: {str(e)}"
                log_exception(e, func.__name__, error_message)
                if show_dialog:
                    # Assuming the first argument might be self or cls in a class method
                    parent = args[0] if args and isinstance(args[0], QWidget) else None
                    show_error_dialog("Operation Failed", str(e), parent)
                raise

        return wrapper

    return decorator

def db_operation(
    show_dialog: bool = False,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for database operations."""
    return handle_exceptions(
        DatabaseException, NotFoundException, show_dialog=show_dialog
    )

def validate_input(
    validators: List[Callable[[Any], bool]], error_message: str,
    show_dialog: bool = False,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for input validation."""
    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            try:
                # Validate the first argument after 'self'
                if len(args) > 1:
                    validate(args[1], validators, error_message)
                return func(*args, **kwargs)
            except ValidationException as e:
                log_exception(e, func.__name__, "Validation error")
                if show_dialog:
                    parent = args[0] if args and isinstance(args[0], QWidget) else None
                    show_error_dialog("Validation Error", str(e), parent)
                raise
        return wrapper
    return decorator

def require_authorization(
    show_dialog: bool = True,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for operations requiring authorization."""
    return handle_exceptions(AuthorizationException, show_dialog=show_dialog)

def handle_external_service(
    show_dialog: bool = False,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for external service interactions."""
    return handle_exceptions(ExternalServiceException, show_dialog=show_dialog)

def handle_concurrency(
    show_dialog: bool = False,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for concurrency-sensitive operations."""
    return handle_exceptions(ConcurrencyException, show_dialog=show_dialog)

def enforce_business_logic(
    show_dialog: bool = False,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for enforcing business logic rules."""
    return handle_exceptions(BusinessLogicException, show_dialog=show_dialog)

def ui_operation(
    show_dialog: bool = True,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """Decorator for UI operations."""
    return handle_exceptions(UIException, show_dialog=show_dialog)

def retry(
    max_attempts: int = 3, delay: float = 1.0
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    A decorator that retries the function execution on failure.

    Args:
    - max_attempts: Maximum number of retry attempts
    - delay: Delay between retries in seconds
    """

    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            attempts = 0
            last_exception: Optional[Exception] = None
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    last_exception = e
                    if attempts < max_attempts:
                        time.sleep(delay)
                    else:
                        log_exception(
                            e, func.__name__, f"Failed after {max_attempts} attempts"
                        )

            if last_exception:
                raise last_exception
            else:
                raise RuntimeError(
                    f"Failed to execute {func.__name__} after {max_attempts} attempts"
                )

        return wrapper

    return decorator

def measure_performance(
    threshold: Optional[float] = None,
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    A decorator that measures the execution time of a function.

    Args:
    - threshold: If set, log a warning if execution time exceeds this value (in seconds)
    """

    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            start_time = time.time()
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.debug(f"{func.__name__} executed in {execution_time:.2f} seconds")
            if threshold and execution_time > threshold:
                logger.warning(
                    f"{func.__name__} exceeded threshold of {threshold} seconds",
                    extra={"execution_time": execution_time, "threshold": threshold}
                )
            return result

        return wrapper

    return decorator

def cache_result(ttl: int = 300) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    A decorator that caches the result of a function for a specified time.

    Args:
    - ttl: Time to live for the cached result in seconds
    """

    def decorator(func: Callable[P, T]) -> Callable[P, T]:
        cache: dict = {}

        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
            key = str(args) + str(kwargs)
            if key in cache and time.time() - cache[key]["time"] < ttl:
                logger.debug(f"Cache hit for {func.__name__}")
                return cache[key]["result"]
            result = func(*args, **kwargs)
            cache[key] = {"result": result, "time": time.time()}
            logger.debug(f"Cache miss for {func.__name__}, result cached")
            return result

        return wrapper

    return decorator



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/exceptions.py:
from typing import Optional

class AppException(Exception):
    """Base exception class for the application."""
    def __init__(self, message, error_code=None, details=None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code
        self.details = details or {}

    def __str__(self):
        if self.error_code:
            return f"{self.error_code}: {self.message}"
        return self.message

class DatabaseException(AppException):
    """Exception raised for database-related errors."""
    pass

class ValidationException(AppException):
    """Exception raised for validation errors."""
    pass

class ConfigurationException(AppException):
    """Exception raised for configuration-related errors."""
    pass

class BusinessLogicException(AppException):
    """Exception raised for business logic errors."""
    pass

class UIException(AppException):
    """Exception raised for UI-related errors."""
    pass

class NetworkException(AppException):
    """Exception raised for network-related errors."""
    pass

class SecurityException(AppException):
    """Exception raised for security-related errors."""
    pass

class NotFoundException(AppException):
    """Exception raised when a requested resource is not found."""
    pass

class ExternalServiceException(AppException):
    """Exception raised for external service-related errors."""
    pass

class FileOperationException(AppException):
    """Exception raised for file operation errors."""
    pass

class AuthenticationException(AppException):
    """Exception raised for authentication-related errors."""
    pass

class AuthorizationException(AppException):
    """Exception raised for authorization-related errors."""
    pass

class DataFormatException(AppException):
    """Exception raised for data format errors."""
    pass

class SystemConfigurationException(AppException):
    """Exception raised for system configuration errors."""
    pass

class ResourceException(AppException):
    """Exception raised for resource-related errors."""
    pass

class ConcurrencyException(AppException):
    """Exception raised for concurrency-related errors."""
    pass



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/helpers.py:
from PySide6.QtWidgets import QTableWidget, QHeaderView, QMessageBox, QWidget
from typing import List, Any, Optional, Union, Callable, TypeVar
from decimal import Decimal
import datetime
from utils.exceptions import ValidationException
from utils.system.logger import logger

T = TypeVar("T")

def create_table(headers: List[str]) -> QTableWidget:
    """
    Create and return a QTableWidget with the specified headers.

    Args:
        headers (List[str]): A list of strings to be used as table headers.

    Returns:
        QTableWidget: A configured table widget with the specified headers.
    """
    try:
        table = QTableWidget()
        table.setColumnCount(len(headers))
        table.setHorizontalHeaderLabels(headers)
        table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
        table.horizontalHeader().setStretchLastSection(True)
        table.setSortingEnabled(True)
        table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        logger.debug(f"Created table with {len(headers)} columns")
        return table
    except Exception as e:
        logger.error(f"Error creating table: {str(e)}")
        raise

def show_message(
    title: str, message: str, icon: QMessageBox.Icon = QMessageBox.Icon.Information
) -> None:
    """
    Display a message box with the specified title, message, and icon.

    Args:
        title (str): The title of the message box.
        message (str): The message to be displayed.
        icon (QMessageBox.Icon): The icon to be displayed in the message box.
    """
    try:
        msg_box = QMessageBox()
        msg_box.setIcon(icon)
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.exec()
        logger.debug(f"Showed message: {title} - {message}")
    except Exception as e:
        logger.error(f"Error showing message: {str(e)}")
        raise

def show_error_message(title: str, message: str) -> None:
    """
    Display an error message box with the specified title and message.

    Args:
        title (str): The title of the error message box.
        message (str): The detailed error message to be displayed.
    """
    show_message(title, message, QMessageBox.Icon.Critical)
    logger.error(f"Error message shown: {title} - {message}")

def show_info_message(title: str, message: str) -> None:
    """
    Display an information message box with the specified title and message.

    Args:
        title (str): The title of the information message box.
        message (str): The detailed information message to be displayed.
    """
    show_message(title, message, QMessageBox.Icon.Information)
    logger.info(f"Info message shown: {title} - {message}")

def validate_integer_input(
    value: str,
    field_name: str,
    min_value: Optional[int] = None,
    max_value: Optional[int] = None,
) -> int:
    """
    Validate and convert a string input to an integer within an optional range.

    Args:
        value (str): The string value to be converted.
        field_name (str): The name of the field for error reporting.
        min_value (Optional[int]): The minimum allowed value (inclusive).
        max_value (Optional[int]): The maximum allowed value (inclusive).

    Returns:
        int: The converted integer value.

    Raises:
        ValidationException: If the input cannot be converted to a valid integer or is out of the specified range.
    """
    try:
        int_value = int(value)
        if min_value is not None and int_value < min_value:
            raise ValidationException(f"{field_name} must be at least {min_value}.")
        if max_value is not None and int_value > max_value:
            raise ValidationException(f"{field_name} must not exceed {max_value}.")
        return int_value
    except ValueError:
        raise ValidationException(f"{field_name} must be a valid integer.")

def safe_convert(value: Any, target_type: Callable[[Any], T], default: T) -> T:
    """
    Safely convert a value to a target type, returning a default value if conversion fails.

    Args:
        value (Any): The value to be converted.
        target_type (Callable[[Any], T]): The type to convert the value to.
        default (T): The default value to return if conversion fails.

    Returns:
        T: The converted value or the default value if conversion fails.
    """
    try:
        return target_type(value)
    except (ValueError, TypeError):
        logger.warning(f"Conversion failed for value: {value}. Using default: {default}")
        return default

def format_date(date: datetime.date, format_str: str = "%Y-%m-%d") -> str:
    """
    Format a date object as a string.

    Args:
        date (datetime.date): The date to be formatted.
        format_str (str, optional): The format string to use. Defaults to "%Y-%m-%d".

    Returns:
        str: The formatted date string.
    """
    return date.strftime(format_str)

def truncate_string(text: str, max_length: int, ellipsis: str = "...") -> str:
    """
    Truncate a string to a maximum length, appending an ellipsis if truncated.

    Args:
        text (str): The string to truncate.
        max_length (int): The maximum length of the resulting string, including the ellipsis.
        ellipsis (str, optional): The ellipsis to append if truncated. Defaults to "...".

    Returns:
        str: The truncated string.
    """
    if len(text) <= max_length:
        return text
    return text[: max_length - len(ellipsis)] + ellipsis

def format_price(amount: Union[int, float, Decimal]) -> str:
    """
    Format a price with dot as thousand separator and no decimals.

    Args:
        amount (Union[int, float, Decimal]): The price amount to format.

    Returns:
        str: The formatted price string.
    """
    return f"{int(amount):,}".replace(",", ".")

def confirm_action(parent: Optional[QWidget], title: str, message: str) -> bool:
    """
    Display a confirmation dialog and return the user's choice.

    Args:
        parent (Optional[QWidget]): The parent widget for the dialog.
        title (str): The title of the confirmation dialog.
        message (str): The message to display in the confirmation dialog.

    Returns:
        bool: True if the user confirms, False otherwise.
    """
    try:
        msg_box = QMessageBox(parent) if parent else QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setStandardButtons(
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)

        result = msg_box.exec()

        confirmed = result == QMessageBox.StandardButton.Yes
        logger.debug(f"Action confirmation: {title} - {'Confirmed' if confirmed else 'Cancelled'}")
        return confirmed
    except Exception as e:
        logger.error(f"Error in confirm_action: {str(e)}")
        raise



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/sanitizers.py:
import html
import re
from typing import Union
from decimal import Decimal

def sanitize_html(value: str) -> str:
    """
    Escape HTML special characters in the given string.
    
    Args:
        value (str): The string to sanitize.
    
    Returns:
        str: The sanitized string.
    """
    return html.escape(value)

def sanitize_sql(value: str) -> str:
    """
    Remove SQL injection vulnerable characters from the given string.
    
    Args:
        value (str): The string to sanitize.
    
    Returns:
        str: The sanitized string.
    """
    return re.sub(r"['\";]", "", value)

def sanitize_filename(value: str) -> str:
    """
    Remove characters that are not allowed in filenames.
    
    Args:
        value (str): The filename to sanitize.
    
    Returns:
        str: The sanitized filename.
    """
    return re.sub(r'[<>:"/\\|?*]', '', value)

def strip_tags(value: str) -> str:
    """
    Remove all HTML tags from the given string.
    
    Args:
        value (str): The string to sanitize.
    
    Returns:
        str: The sanitized string.
    """
    return re.sub(r'<[^>]*>', '', value)

def sanitize_number(value: Union[int, float, Decimal, str]) -> Union[int, float, Decimal]:
    """
    Ensure the given value is a valid number.
    
    Args:
        value (Union[int, float, Decimal, str]): The value to sanitize.
    
    Returns:
        Union[int, float, Decimal]: The sanitized number.
    
    Raises:
        ValueError: If the value cannot be converted to a number.
    """
    if isinstance(value, (int, float, Decimal)):
        return value
    try:
        return int(value)
    except ValueError:
        try:
            return float(value)
        except ValueError:
            try:
                return Decimal(value)
            except:
                raise ValueError(f"Cannot convert {value} to a number")

def truncate_string(value: str, max_length: int) -> str:
    """
    Truncate the given string to the specified maximum length.
    
    Args:
        value (str): The string to truncate.
        max_length (int): The maximum allowed length.
    
    Returns:
        str: The truncated string.
    """
    return value[:max_length]

def sanitize_email(value: str) -> str:
    """
    Sanitize and validate an email address.
    
    Args:
        value (str): The email address to sanitize.
    
    Returns:
        str: The sanitized email address.
    
    Raises:
        ValueError: If the email address is invalid.
    """
    email = value.strip().lower()
    if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
        raise ValueError("Invalid email address")
    return email

def sanitize_phone(value: str) -> str:
    """
    Sanitize and validate a phone number.
    
    Args:
        value (str): The phone number to sanitize.
    
    Returns:
        str: The sanitized phone number.
    
    Raises:
        ValueError: If the phone number is invalid.
    """
    phone = re.sub(r'\D', '', value)
    if not 7 <= len(phone) <= 15:
        raise ValueError("Invalid phone number")
    return phone

def sanitize_url(value: str) -> str:
    """
    Sanitize and validate a URL.
    
    Args:
        value (str): The URL to sanitize.
    
    Returns:
        str: The sanitized URL.
    
    Raises:
        ValueError: If the URL is invalid.
    """
    url = value.strip()
    if not re.match(r'^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$', url):
        raise ValueError("Invalid URL")
    return url



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/__init__.py:
from .helpers import *
from .decorators import *
from .exceptions import *
from .data_handling import excel_exporter
from .ui import table_items, sound
from .system import event_system, logger
from .validation import validators

__all__ = [
    "excel_exporter",
    "table_items",
    "sound",
    "event_system",
    "logger",
    "validators",
]


C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/data_handling/excel_exporter.py:
import xlsxwriter
from datetime import datetime
from typing import List, Dict, Any, Iterable
import os
import logging
from utils.decorators import handle_external_service #, validate_input
from utils.exceptions import ExternalServiceException, ValidationException

logger = logging.getLogger(__name__)


class ExcelExporter:
    @staticmethod
    @handle_external_service(show_dialog=True)
    #@validate_input(show_dialog=True)
    def export_to_excel(
        data: List[Dict[str, Any]],
        headers: List[str],
        filename: str,
        sheet_name: str = "Sheet1",
        auto_adjust_columns: bool = True,
    ) -> None:
        """
        Export data to an Excel file.

        Args:
            data (List[Dict[str, Any]]): The data to be exported. Each dictionary represents a row.
            headers (List[str]): The column headers for the Excel file.
            filename (str): The name of the file to be created (including path).
            sheet_name (str, optional): Name of the worksheet. Defaults to "Sheet1".
            auto_adjust_columns (bool, optional): Whether to auto-adjust column widths. Defaults to True.

        Raises:
            ValidationException: If the data is empty or headers don't match the data.
            ExternalServiceException: If there's an issue writing to the file.
        """
        if not data:
            raise ValidationException("No data to export")

        if set(headers) != set(data[0].keys()):
            raise ValidationException("Headers don't match the data keys")

        try:
            with xlsxwriter.Workbook(filename) as workbook:
                worksheet = workbook.add_worksheet(sheet_name)

                # Define styles
                header_format = workbook.add_format(
                    {"bold": True, "bg_color": "#D3D3D3"}
                )
                date_format = workbook.add_format({"num_format": "yyyy-mm-dd hh:mm:ss"})

                # Add headers
                for col, header in enumerate(headers):
                    worksheet.write(0, col, header, header_format)

                # Add data
                for row, item in enumerate(data, start=1):
                    for col, (key, value) in enumerate(item.items()):
                        if isinstance(value, datetime):
                            worksheet.write_datetime(row, col, value, date_format)
                        else:
                            worksheet.write(row, col, value)

                if auto_adjust_columns:
                    for col, header in enumerate(headers):
                        max_width = max(len(str(item[header])) for item in data)
                        worksheet.set_column(col, col, max(len(header), max_width) + 2)

            logger.info(f"Excel file created successfully: {os.path.abspath(filename)}")
        except IOError as e:
            raise ExternalServiceException(
                f"Error writing to file {filename}: {str(e)}"
            )
        except Exception as e:
            raise ExternalServiceException(
                f"An error occurred while exporting to Excel: {str(e)}"
            )

    @staticmethod
    @handle_external_service(show_dialog=True)
    #@validate_input(show_dialog=True)
    def export_large_dataset(
        data_generator: Iterable[Dict[str, Any]],
        headers: List[str],
        filename: str,
        sheet_name: str = "Sheet1",
        chunk_size: int = 1000,
    ) -> None:
        """
        Export a large dataset to Excel file using a generator to conserve memory.

        Args:
            data_generator (Iterable[Dict[str, Any]]): A generator that yields dictionaries representing rows.
            headers (List[str]): The column headers for the Excel file.
            filename (str): The name of the file to be created (including path).
            sheet_name (str, optional): Name of the worksheet. Defaults to "Sheet1".
            chunk_size (int, optional): Number of rows to write at a time. Defaults to 1000.

        Raises:
            ExternalServiceException: If there's an issue writing to the file.
        """
        try:
            with xlsxwriter.Workbook(filename) as workbook:
                worksheet = workbook.add_worksheet(sheet_name)

                # Define styles
                header_format = workbook.add_format(
                    {"bold": True, "bg_color": "#D3D3D3"}
                )
                date_format = workbook.add_format({"num_format": "yyyy-mm-dd hh:mm:ss"})

                # Add headers
                for col, header in enumerate(headers):
                    worksheet.write(0, col, header, header_format)

                row = 1
                for item in data_generator:
                    for col, (key, value) in enumerate(item.items()):
                        if isinstance(value, datetime):
                            worksheet.write_datetime(row, col, value, date_format)
                        else:
                            worksheet.write(row, col, value)
                    row += 1

                    if row % chunk_size == 0:
                        logger.info(f"Exported {row} rows...")

            logger.info(
                f"Large dataset exported successfully: {os.path.abspath(filename)}"
            )
        except IOError as e:
            raise ExternalServiceException(
                f"Error writing to file {filename}: {str(e)}"
            )
        except Exception as e:
            raise ExternalServiceException(
                f"An error occurred while exporting large dataset to Excel: {str(e)}"
            )



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/data_handling/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/system/event_system.py:
from PySide6.QtCore import QObject, Signal
from typing import Any, Callable, Optional, List
from utils.system.logger import logger

class EventSystem(QObject):
    """
    A centralized event system for inter-component communication.

    This class provides signals that can be emitted when certain events occur
    in the application, allowing different components to react to these events.
    """

    # Product-related signals
    product_added = Signal(int)  # Emits the ID of the added product
    product_updated = Signal(int)  # Emits the ID of the updated product
    product_deleted = Signal(int)  # Emits the ID of the deleted product

    # Purchase-related signals
    purchase_added = Signal(int)  # Emits the ID of the added purchase
    purchase_updated = Signal(int)  # Emits the ID of the updated purchase
    purchase_deleted = Signal(int)  # Emits the ID of the deleted purchase

    # Sale-related signals
    sale_added = Signal(int)  # Emits the ID of the added sale
    sale_updated = Signal(int)  # Emits the ID of the updated sale
    sale_deleted = Signal(int)  # Emits the ID of the deleted sale

    # Inventory-related signals
    inventory_changed = Signal(int)  # Emits the ID of the product whose inventory changed
    inventory_updated = Signal()  # Add if missing

    # Customer-related signals
    customer_added = Signal(int)  # Emits the ID of the added customer
    customer_updated = Signal(int)  # Emits the ID of the updated customer
    customer_deleted = Signal(int)  # Emits the ID of the deleted customer

    # Category-related signals
    category_added = Signal(int)  # Emits the ID of the added category
    category_updated = Signal(int)  # Emits the ID of the updated category
    category_deleted = Signal(int)  # Emits the ID of the deleted category

    # General application signals
    app_settings_changed = Signal(dict)  # Emits a dictionary of changed settings
    data_import_completed = Signal(bool)  # Emits True if import was successful, False otherwise
    data_export_completed = Signal(bool)  # Emits True if export was successful, False otherwise

    def __init__(self):
        super().__init__()
        self._signal_map = {
            "product_added": self.product_added,
            "product_updated": self.product_updated,
            "product_deleted": self.product_deleted,
            "purchase_added": self.purchase_added,
            "purchase_updated": self.purchase_updated,
            "purchase_deleted": self.purchase_deleted,
            "sale_added": self.sale_added,
            "sale_updated": self.sale_updated,
            "sale_deleted": self.sale_deleted,
            "inventory_changed": self.inventory_changed,
            "customer_added": self.customer_added,
            "customer_updated": self.customer_updated,
            "customer_deleted": self.customer_deleted,
            "category_added": self.category_added,
            "category_updated": self.category_updated,
            "category_deleted": self.category_deleted,
            "app_settings_changed": self.app_settings_changed,
            "data_import_completed": self.data_import_completed,
            "data_export_completed": self.data_export_completed,
        }

    def emit_event(self, event_name: str, *args: Any) -> None:
        """
        Emit an event by name with optional arguments.

        Args:
            event_name (str): The name of the event to emit.
            *args: Variable length argument list to pass with the event.

        Raises:
            ValueError: If the event_name is not recognized.
        """
        if event_name in self._signal_map:
            self._signal_map[event_name].emit(*args)
            logger.debug(f"Event emitted: {event_name}", extra={"args": args})
        else:
            logger.error(f"Unknown event: {event_name}")
            raise ValueError(f"Unknown event: {event_name}")

    def connect_to_event(self, event_name: str, slot: Callable[..., None]) -> None:
        """
        Connect a slot (callback function) to a specific event.

        Args:
            event_name (str): The name of the event to connect to.
            slot (Callable[..., None]): The function to be called when the event is emitted.

        Raises:
            ValueError: If the event_name is not recognized.
        """
        if event_name in self._signal_map:
            self._signal_map[event_name].connect(slot)
            logger.debug(f"Connected to event: {event_name}", extra={"slot_name": slot.__name__})
        else:
            logger.error(f"Unknown event: {event_name}")
            raise ValueError(f"Unknown event: {event_name}")

    def disconnect_from_event(
        self, event_name: str, slot: Optional[Callable[..., None]] = None
    ) -> None:
        """
        Disconnect a slot (callback function) from a specific event.

        Args:
            event_name (str): The name of the event to disconnect from.
            slot (Optional[Callable[..., None]]): The function to be disconnected. If None, all connections are removed.

        Raises:
            ValueError: If the event_name is not recognized.
        """
        if event_name in self._signal_map:
            if slot is None:
                self._signal_map[event_name].disconnect()
                logger.debug(f"Disconnected all slots from event: {event_name}")
            else:
                self._signal_map[event_name].disconnect(slot)
                logger.debug(f"Disconnected from event: {event_name}", extra={"slot_name": slot.__name__})
        else:
            logger.error(f"Unknown event: {event_name}")
            raise ValueError(f"Unknown event: {event_name}")

    def get_available_events(self) -> List[str]:
        """
        Get a list of all available event names.

        Returns:
            List[str]: A list of all available event names.
        """
        return list(self._signal_map.keys())

    def clear_all_connections(self) -> None:
        """
        Clear all event connections.
        """
        for signal in self._signal_map.values():
            signal.disconnect()
        logger.info("All event connections cleared")

# Global instance of the event system
event_system = EventSystem()



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/system/logger.py:
import logging
import logging.config
import logging.handlers
from pathlib import Path
import yaml
from typing import Any, Optional, Dict
import json
from functools import wraps
from config import DEBUG_LEVEL, APP_NAME
from datetime import datetime

class LogLevel:
    """Enum-like class for log levels with clear hierarchy."""
    DEBUG = logging.DEBUG       # Detailed information for debugging
    INFO = logging.INFO        # General operational events
    WARNING = logging.WARNING  # Warning messages for potential issues
    ERROR = logging.ERROR      # Error events that might still allow the app to run
    CRITICAL = logging.CRITICAL  # Critical errors that prevent proper functioning

class StructuredLogger:
    """Enhanced logger with structured logging capabilities and context management."""
    
    def __init__(self, name: str, log_file: Optional[Path] = None):
        self.name = name
        self._context = {}
        self._log_file = log_file
        self._logger = logging.getLogger(name)
        self._logger.setLevel(DEBUG_LEVEL)  # Set level immediately
        
        if log_file is not None:
            handler = logging.FileHandler(log_file, encoding='utf-8')
            handler.setLevel(DEBUG_LEVEL)  # Set handler level
            formatter = JsonFormatter()
            handler.setFormatter(formatter)
            self._logger.addHandler(handler)

        self._logger.propagate = False  # Prevent double logging

    def with_context(self, **kwargs) -> 'StructuredLogger':
        """Create a new logger instance with added context."""
        new_logger = StructuredLogger(self.name, self._log_file)
        new_logger._context = {**self._context, **kwargs}
        return new_logger

    def _format_message(self, message: str, extra: Optional[Dict[str, Any]] = None) -> str:
        """Format message with context and extra data."""
        log_data = {
            "message": message,
            "timestamp": datetime.now().isoformat(),
            **self._context,
            **(extra or {})  # Use empty dict if extra is None
        }
        return json.dumps(log_data)

    def info(self, message: str, extra: Optional[Dict[str, Any]] = None) -> None:
        self._logger.info(self._format_message(message, extra))

    def debug(self, message: str, extra: Optional[Dict[str, Any]] = None) -> None:
        self._logger.debug(self._format_message(message, extra))

    def warning(self, message: str, extra: Optional[Dict[str, Any]] = None) -> None:
        self._logger.warning(self._format_message(message, extra))

    def error(self, message: str, extra: Optional[Dict[str, Any]] = None) -> None:
        self._logger.error(self._format_message(message, extra))

    def critical(self, message: str, extra: Optional[Dict[str, Any]] = None) -> None:
        self._logger.critical(self._format_message(message, extra))

    def _log(self, level: int, message: str, **kwargs) -> None:
        """Internal method for logging with level."""
        self._logger.log(level, self._format_message(message, kwargs))

class JsonFormatter(logging.Formatter):
    """Format log records as JSON."""
    
    def format(self, record: logging.LogRecord) -> str:
        """Format the log record as JSON."""
        data = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "logger": record.name
        }
        
        # Parse the message if it's JSON
        try:
            message_data = json.loads(record.msg)
            data.update(message_data)
        except (json.JSONDecodeError, TypeError):
            data["message"] = record.msg
            
        return json.dumps(data)

class LoggerConfig:
    """Configuration class for logger settings."""
    def __init__(self, log_file: Path, level: int, max_size: int, backup_count: int, format: str):
        self.log_file = log_file
        self.level = level
        self.max_size = max_size
        self.backup_count = backup_count
        self.format = format

def setup_logger(config: LoggerConfig) -> StructuredLogger:
    """Set up the logger with the given configuration."""
    logger = StructuredLogger("app", config.log_file)
    
    handler = logging.handlers.RotatingFileHandler(
        config.log_file,
        maxBytes=config.max_size,
        backupCount=config.backup_count,
        encoding='utf-8'
    )
    
    handler.setFormatter(
        JsonFormatter() if config.format == "json" 
        else logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    )
    
    logger._logger.addHandler(handler)
    logger._logger.setLevel(config.level)
    return logger

def rotate_logs(log_dir: Path) -> None:
    """Rotate log files in the given directory."""
    for handler in logger._logger.handlers:
        if isinstance(handler, logging.handlers.RotatingFileHandler):
            handler.doRollover()

def clear_logs(log_dir: Path) -> None:
    """Clear all log files in the given directory."""
    for log_file in log_dir.glob("*.log*"):
        log_file.unlink(missing_ok=True)

def setup_structured_logger() -> StructuredLogger:
    """Configure and set up the application logger."""
    # Set root logger level first
    logging.getLogger().setLevel(DEBUG_LEVEL)
    
    config_path = Path("login_config.yaml")
    
    if config_path.exists():
        with open(config_path) as f:
            config = yaml.safe_load(f)
            logging.config.dictConfig(config)
    else:
        # Fallback configuration if YAML doesn't exist
        logging.basicConfig(
            level=DEBUG_LEVEL,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler(f"{APP_NAME.lower()}.log"),
            ],
        )

    logger = StructuredLogger(APP_NAME)
    logger._logger.setLevel(DEBUG_LEVEL)  # Ensure logger level is set
    return logger

def log_method(level: int = LogLevel.DEBUG):
    """Decorator for logging method calls with their arguments and results."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            func_logger = logger.with_context(
                function=func.__name__,
                module=func.__module__
            )
            
            # Log method entry
            func_logger._log(level, f"Entering {func.__name__}", 
                           args=str(args[1:]), kwargs=str(kwargs))
            
            try:
                result = func(*args, **kwargs)
                # Log successful completion
                func_logger._log(level, f"Completed {func.__name__}")
                return result
            except Exception as e:
                # Log exception with full context
                func_logger.error(
                    f"Exception in {func.__name__}",
                    extra={
                        "exc_info": True,
                        "exception_type": type(e).__name__,
                        "exception_message": str(e)
                    }
                )
                raise
            
        return wrapper
    return decorator

# Initialize global logger instance
logger = setup_structured_logger()



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/ui/sound.py:
from typing import Protocol
from utils.system.logger import logger
import os

class SoundPlayer(Protocol):
    """Protocol defining the interface for sound players."""
    def play(self) -> None: ...

class DummySound:
    """A silent implementation for when sound can't be played."""
    def play(self) -> None:
        """Dummy play method that does nothing."""
        pass

class SoundEffect:
    """A wrapper class for sound effects that gracefully falls back to silent mode."""
    def __init__(self, sound_file: str):
        self._player: SoundPlayer = self._create_player(sound_file)
    
    def _create_player(self, sound_file: str) -> SoundPlayer:
        try:
            from PySide6.QtMultimedia import QSoundEffect
            from PySide6.QtCore import QUrl
            
            player = QSoundEffect()
            file_path = os.path.join(os.path.dirname(__file__), "..", "..", "ui", "resources", sound_file)
            
            if os.path.exists(file_path):
                player.setSource(QUrl.fromLocalFile(file_path))
                player.setVolume(0.5)
                # Test if sound can be loaded
                if player.status() != QSoundEffect.Status.Error:
                    logger.info(f"Sound system initialized successfully: {file_path}")
                    return player
            
            logger.warning(f"Sound file not found or couldn't be loaded: {file_path}")
            return DummySound()
            
        except Exception as e:
            logger.info(f"Sound system not available ({str(e)}), running in silent mode")
            return DummySound()
    
    def play(self) -> None:
        """Play the sound effect, silently failing if it can't be played."""
        try:
            self._player.play()
        except Exception as e:
            logger.debug(f"Could not play sound: {str(e)}")



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/ui/table_items.py:
from PySide6.QtWidgets import QTableWidgetItem
from PySide6.QtCore import Qt
from typing import Union, Callable, Any


class NumericTableWidgetItem(QTableWidgetItem):
    def __init__(self, value: Union[int, float]):
        super().__init__(str(value))
        self.value = value
        self.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )

    def __lt__(self, other: "NumericTableWidgetItem") -> bool:
        if isinstance(other, NumericTableWidgetItem):
            return self.value < other.value
        return super().__lt__(other)


class PercentageTableWidgetItem(QTableWidgetItem):
    def __init__(self, value: Union[int, float, None]):
        display_value = (
            f"{value:.2f}%".replace(".", ",") if value is not None else "N/A"
        )
        super().__init__(display_value)
        self.value = (
            value if value is not None else float("-inf")
        )  # Use -inf for N/A to sort it at the bottom
        self.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )

    def __lt__(self, other: "PercentageTableWidgetItem") -> bool:
        if isinstance(other, PercentageTableWidgetItem):
            return self.value < other.value
        return super().__lt__(other)


class PriceTableWidgetItem(QTableWidgetItem):
    def __init__(
        self,
        value: Union[int, float, None],
        format_func: Callable[[Union[int, float]], str],
    ):
        display_value = format_func(value) if value is not None else "N/A"
        super().__init__(display_value)
        self.value = (
            value if value is not None else float("-inf")
        )  # Use -inf for N/A to sort it at the bottom
        self.setTextAlignment(
            Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter
        )

    def __lt__(self, other: "PriceTableWidgetItem") -> bool:
        if isinstance(other, PriceTableWidgetItem):
            return self.value < other.value
        return super().__lt__(other)


class DateTableWidgetItem(QTableWidgetItem):
    def __init__(self, date: Any, format_str: str = "%Y-%m-%d"):
        super().__init__(date.strftime(format_str) if date else "")
        self.date = date
        self.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

    def __lt__(self, other: "DateTableWidgetItem") -> bool:
        if isinstance(other, DateTableWidgetItem):
            if self.date and other.date:
                return self.date < other.date
            return bool(self.date) < bool(other.date)  # None dates sort last
        return super().__lt__(other)


class CheckboxTableWidgetItem(QTableWidgetItem):
    def __init__(self, checked: bool = False):
        super().__init__()
        self.setFlags(self.flags() | Qt.ItemFlag.ItemIsUserCheckable)
        self.setCheckState(
            Qt.CheckState.Checked if checked else Qt.CheckState.Unchecked
        )


class DepartmentIdentifierTableWidgetItem(QTableWidgetItem):
    """Custom table item for department identifiers (3 or 4 digits)"""
    def __init__(self, value: str):
        # Handle empty or N/A values
        if not value or value == "N/A":
            # Use a very high number for sorting "N/A" at the end
            self.sort_key = float('inf')
            display_value = "N/A"
        else:
            # For actual department numbers, use numeric value for sorting
            try:
                self.sort_key = int(value)
                display_value = value
            except ValueError:
                self.sort_key = float('inf')
                display_value = value

        super().__init__(display_value)
        self.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

    def __lt__(self, other: "DepartmentIdentifierTableWidgetItem") -> bool:
        if not isinstance(other, DepartmentIdentifierTableWidgetItem):
            return super().__lt__(other)
        
        # Both are valid numbers - sort by length first, then by value
        if isinstance(self.sort_key, int) and isinstance(other.sort_key, int):
            self_str = str(self.sort_key)
            other_str = str(other.sort_key)
            
            # If lengths are different, shorter numbers come first
            if len(self_str) != len(other_str):
                return len(self_str) < len(other_str)
            
            # If lengths are the same, sort by numeric value
            return self.sort_key < other.sort_key
            
        # Handle "N/A" and invalid values
        return self.sort_key < other.sort_key


C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/ui/__init__.py:



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/validation/data_validator.py:
import sqlite3
from typing import Tuple, List, Dict, Any
from database import DatabaseManager
from utils.exceptions import DatabaseException
from utils.system.logger import logger
from utils.decorators import db_operation

class DataValidationService:
    """Service for validating data integrity across the application."""
    
    @staticmethod
    @db_operation(show_dialog=True)
    def diagnose_sales_data() -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
        """
        Diagnose sales data for inconsistencies.
        Returns tuple of (invalid_sales, orphaned_items)
        """
        logger.info("Starting sales data diagnosis")
        
        invalid_sales = []
        orphaned_items = []

        # Check for sales with future dates
        future_date_query = """
            SELECT s.*, GROUP_CONCAT(si.id) as item_ids
            FROM sales s
            LEFT JOIN sale_items si ON s.id = si.sale_id
            WHERE date > date('now')
            GROUP BY s.id
        """
        
        # Check for orphaned sale items
        orphaned_items_query = """
            SELECT si.*
            FROM sale_items si
            LEFT JOIN sales s ON si.sale_id = s.id
            WHERE s.id IS NULL
        """
        
        try:
            with DatabaseManager.get_db_connection() as conn:
                # Check future dates
                cursor = conn.execute(future_date_query)
                future_sales = cursor.fetchall()
                for row in future_sales:
                    invalid_sales.append(dict(row))
                    logger.error(f"Found sale with future date: {dict(row)}")

                # Check orphaned items
                cursor = conn.execute(orphaned_items_query)
                orphaned = cursor.fetchall()
                for row in orphaned:
                    orphaned_items.append(dict(row))
                    logger.error(f"Found orphaned sale item: {dict(row)}")

            return invalid_sales, orphaned_items

        except sqlite3.Error as e:
            logger.error(f"Database error during diagnosis: {e}")
            raise DatabaseException(f"Database error during diagnosis: {e}")

    @staticmethod
    @db_operation(show_dialog=True)
    def fix_invalid_sales() -> None:
        """
        Fix invalid sales data by removing future sales and orphaned items.
        """
        logger.info("Starting sales data fix")
        
        try:
            invalid_sales, orphaned_items = DataValidationService.diagnose_sales_data()
            
            if not invalid_sales and not orphaned_items:
                logger.info("No invalid sales data found")
                return

            with DatabaseManager.get_db_connection() as conn:
                if invalid_sales:
                    # Delete sale items first (foreign key constraint)
                    sale_ids = [sale['id'] for sale in invalid_sales]
                    placeholders = ','.join('?' * len(sale_ids))
                    
                    # Log the specific items being deleted
                    logger.info(f"Deleting sale items for sales: {sale_ids}")
                    delete_items_query = f"""
                        DELETE FROM sale_items 
                        WHERE sale_id IN ({placeholders})
                    """
                    cursor = conn.execute(delete_items_query, sale_ids)
                    logger.info(f"Deleted {cursor.rowcount} sale items")
                    
                    # Then delete the sales
                    logger.info(f"Deleting invalid sales: {sale_ids}")
                    delete_sales_query = f"""
                        DELETE FROM sales 
                        WHERE id IN ({placeholders})
                    """
                    cursor = conn.execute(delete_sales_query, sale_ids)
                    logger.info(f"Deleted {cursor.rowcount} invalid sales")

                if orphaned_items:
                    item_ids = [item['id'] for item in orphaned_items]
                    placeholders = ','.join('?' * len(item_ids))
                    
                    logger.info(f"Deleting orphaned items: {item_ids}")
                    delete_orphaned_query = f"""
                        DELETE FROM sale_items 
                        WHERE id IN ({placeholders})
                    """
                    cursor = conn.execute(delete_orphaned_query, item_ids)
                    logger.info(f"Deleted {cursor.rowcount} orphaned items")

                conn.commit()
                logger.info("Sales data fix completed successfully")

        except sqlite3.Error as e:
            logger.error(f"Database error during fix: {e}")
            logger.error("Failed SQL operations details:", exc_info=True)
            raise DatabaseException(f"Database error during fix: {e}")
        except Exception as e:
            logger.error(f"Error during sales fix: {e}")
            logger.error("Full error details:", exc_info=True)
            raise

    @staticmethod
    def validate_all_data():
        """
        Validate all application data during startup.
        Add more validation methods here as needed.
        """
        try:
            # Validate sales data
            invalid_sales, orphaned_items = DataValidationService.diagnose_sales_data()
            
            if invalid_sales or orphaned_items:
                logger.warning(f"Found {len(invalid_sales)} invalid sales and {len(orphaned_items)} orphaned items")
                try:
                    logger.info("Attempting to fix invalid data...")
                    DataValidationService.fix_invalid_sales()
                    
                    # Verify the fix
                    remaining_invalid, remaining_orphaned = DataValidationService.diagnose_sales_data()
                    if remaining_invalid or remaining_orphaned:
                        logger.error("Failed to fix all invalid data!")
                        logger.error(f"Remaining invalid sales: {len(remaining_invalid)}")
                        logger.error(f"Remaining orphaned items: {len(remaining_orphaned)}")
                    else:
                        logger.info("Successfully fixed all invalid data")
                        
                except Exception as fix_error:
                    logger.error(f"Error while fixing invalid data: {str(fix_error)}")
                    # Log the specific items that failed to be fixed
                    logger.error(f"Failed to fix invalid sales: {invalid_sales}")
                    logger.error(f"Failed to fix orphaned items: {orphaned_items}")
            else:
                logger.info("All sales data is valid")

            # Add more validation checks here for other data types
            # Example:
            # DataValidationService.validate_inventory_data()
            # DataValidationService.validate_customer_data()
            
        except Exception as e:
            logger.error(f"Error during data validation: {e}")
            # Log full details of the error for debugging
            logger.error(f"Full validation error details: {str(e)}", exc_info=True)



C:/Users/corte/VS Code Projects/billing_inventory_system_new/utils/validation/validators.py:
import re
from typing import Union, Optional, TypeVar, Any, Type, Tuple, List, Callable
from datetime import datetime
from utils.exceptions import ValidationException
from utils.sanitizers import sanitize_html

T = TypeVar("T")

def validate(value: Any, validators: List[Callable[[Any], bool]], error_message: str):
    for validator in validators:
        if not validator(value):
            raise ValidationException(error_message)

def validate_and_sanitize(value: Any, validators: List[Callable[[Any], bool]], sanitizer: Callable[[Any], Any], error_message: str) -> Any:
    if not all(validator(value) for validator in validators):
        raise ValidationException(error_message)
    return sanitizer(value)

def is_instance_of(class_or_tuple: Union[Type, Tuple[Type, ...]]) -> Callable[[Any], bool]:
    return lambda value: isinstance(value, class_or_tuple)

def is_non_empty_string(value: Any) -> bool:
    return is_instance_of(str)(value) and len(value.strip()) > 0

def is_numeric(value: Any) -> bool:
    return is_instance_of((int, float))(value)

def is_positive(value: Any) -> bool:
    return is_numeric(value) and value > 0

def is_non_negative(value: Any) -> bool:
    return is_numeric(value) and value >= 0

def is_string(value: str, min_length: int = 1, max_length: int = 100) -> bool:
    return isinstance(value, str) and min_length <= len(value) <= max_length

def is_in_range(min_value: float, max_value: float) -> Callable[[Any], bool]:
    return lambda value: is_numeric(value) and min_value <= value <= max_value

def matches_pattern(pattern: str) -> Callable[[str], bool]:
    compiled_pattern = re.compile(pattern)
    return lambda value: is_instance_of(str)(value) and compiled_pattern.match(value) is not None

def has_length(min_length: int, max_length: int) -> Callable[[Any], bool]:
    return lambda value: min_length <= len(value) <= max_length

def validate_string(value: str, min_length: int = 0, max_length: Optional[int] = 100) -> str:
    """Validate a string value."""
    if not isinstance(value, str):
        raise ValidationException("Value must be a string")
    
    # Normalize whitespace
    value = " ".join(value.split())
    
    if len(value) < min_length:
        raise ValidationException(f"Value must be at least {min_length} characters long")
    
    if max_length is not None and len(value) > max_length:
        raise ValidationException(f"Value cannot exceed {max_length} characters")
    
    # Use Python string methods instead of REGEXP
    if not all(c.isalnum() or c.isspace() or c in '-.' for c in value):
        raise ValidationException("Value contains invalid characters")
    
    return value

def validate_integer(value: Any, min_value: Optional[int] = None, max_value: Optional[int] = None) -> int:
    """
    Validate and convert a value to integer.
    Specifically for money values in Chilean Pesos.

    Args:
        value: Value to validate
        min_value: Minimum allowed value (inclusive)
        max_value: Maximum allowed value (inclusive)

    Returns:
        int: Validated integer value

    Raises:
        ValidationException: If validation fails
    """
    try:
        int_value = int(value)
        if not isinstance(int_value, int):
            raise ValidationException("Value must be an integer")
        if min_value is not None and int_value < min_value:
            raise ValidationException(f"Value must be greater than or equal to {min_value}")
        if max_value is not None and int_value > max_value:
            raise ValidationException(f"Value must be less than or equal to {max_value}")
        return int_value
    except (ValueError, TypeError):
        raise ValidationException(f"Invalid integer value: {value}")

def validate_float(value: Any, min_value: Optional[float] = None, max_value: Optional[float] = None,
                  max_decimals: int = 3) -> float:
    """
    Validate and convert a value to float.
    Used primarily for quantities with up to 3 decimal places.

    Args:
        value: Value to validate
        min_value: Minimum allowed value (inclusive)
        max_value: Maximum allowed value (inclusive)
        max_decimals: Maximum allowed decimal places

    Returns:
        float: Validated float value

    Raises:
        ValidationException: If validation fails
    """
    try:
        float_value = float(value)
        
        # Check decimal places
        str_value = str(float_value)
        if '.' in str_value:
            decimals = len(str_value.split('.')[1])
            if decimals > max_decimals:
                raise ValidationException(f"Value cannot have more than {max_decimals} decimal places")
        
        if min_value is not None and float_value < min_value:
            raise ValidationException(f"Value must be greater than or equal to {min_value}")
        if max_value is not None and float_value > max_value:
            raise ValidationException(f"Value must be less than or equal to {max_value}")
        
        # Round to specified decimal places
        return round(float_value, max_decimals)
    except (ValueError, TypeError):
        raise ValidationException("Invalid float value")

def validate_float_non_negative(value: float) -> float:
    """Validate a non-negative float value with 3 decimal places max."""
    return validate_float(value, min_value=0, max_decimals=3)

def validate_int_non_negative(value: int) -> int:
    """Validate a non-negative integer value."""
    return validate_integer(value, min_value=0)

def validate_money(value: Any, field_name: str = "Amount") -> int:
    """
    Validate a money value (Chilean Pesos).
    Must be a positive integer not exceeding 1.000.000 CLP.

    Args:
        value: Value to validate
        field_name: Name of field for error messages

    Returns:
        int: Validated money value

    Raises:
        ValidationException: If value is invalid
    """
    try:
        money_value = int(round(float(value)))
        if not isinstance(money_value, int):
            raise ValidationException(f"{field_name} must be an integer")
        if money_value < 0:
            raise ValidationException(f"{field_name} cannot be negative")
        if money_value > 1_000_000:
            raise ValidationException(f"{field_name} cannot exceed 1.000.000 CLP")
        return money_value
    except (ValueError, TypeError):
        raise ValidationException(f"Invalid {field_name.lower()} value")

def validate_money_multiplication(amount: int, quantity: float, field_name: str = "Total") -> int:
    """
    Validate multiplication of money value by quantity.
    Result must not exceed 1.000.000 CLP.

    Args:
        amount: Base amount in CLP
        quantity: Quantity multiplier
        field_name: Name of field for error messages

    Returns:
        int: Validated result

    Raises:
        ValidationException: If result is invalid
    """
    try:
        result = int(round(float(amount) * quantity))
        return validate_money(result, field_name)
    except (ValueError, TypeError):
        raise ValidationException(f"Invalid {field_name.lower()} calculation")

def validate_quantity(value: Any) -> float:
    """
    Validate a quantity value.
    Must be a positive float with up to 3 decimal places.

    Args:
        value: Value to validate

    Returns:
        float: Validated quantity value

    Raises:
        ValidationException: If validation fails
    """
    return validate_float(value, min_value=0.001, max_decimals=3)

def validate_price_pair(cost_price: int, sell_price: int) -> None:
    """
    Validate a pair of cost and sell prices.
    Sell price must be greater than or equal to cost price.

    Args:
        cost_price: Cost price to validate
        sell_price: Sell price to validate

    Raises:
        ValidationException: If validation fails
    """
    validated_cost = validate_money(cost_price)
    validated_sell = validate_money(sell_price)
    
    if validated_sell < validated_cost:
        raise ValidationException("Sell price cannot be less than cost price")

def validate_date(date_str: str, format: str = "%Y-%m-%d") -> str:
    try:
        datetime_obj = datetime.strptime(date_str, format)
        
        current_date = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        check_date = datetime_obj.replace(hour=0, minute=0, second=0, microsecond=0)
        if check_date > current_date:
            raise ValidationException("Date cannot be in the future")
        
        return datetime_obj.strftime(format)
    except ValueError:
        raise ValidationException(f"Invalid date format. Expected format: {format}")

def validate_boolean(value: Any) -> bool:
    if isinstance(value, bool):
        return value
    if isinstance(value, str):
        lowered = value.lower()
        if lowered in ("true", "1", "yes", "on"):
            return True
        if lowered in ("false", "0", "no", "off"):
            return False
    raise ValidationException(f"Invalid boolean value: {value}")

def validate_with_pattern(value: str, pattern: str, error_message: str = "Invalid format") -> str:
    """Validate string with regex pattern."""
    if not re.match(pattern, value):
        raise ValidationException(error_message)
    return value

def validate_email(value: str) -> str:
    value = validate_string(value)
    return validate_with_pattern(value, r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', "Invalid email format")

def validate_phone(value: str) -> str:
    value = validate_string(value)
    return validate_with_pattern(value, r'^\+?1?\d{9,15}$', "Invalid phone format")

def validate_url(value: str) -> str:
    value = validate_string(value)
    return validate_with_pattern(value, r'^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$', "Invalid URL format")

def validate_identifier(value: str, length: Union[int, Tuple[int, ...]]) -> str:
    """Validate numeric identifier with specific length(s)."""
    value = validate_string(value)
    
    if isinstance(length, int):
        pattern = fr"^\d{{{length}}}$"
        error_message = f"Identifier must be exactly {length} digits"
    else:
        pattern = fr"^\d{{{','.join(map(str, length))}}}$"
        error_message = f"Identifier must be {' or '.join(map(str, length))} digits"
    
    return validate_with_pattern(value, pattern, error_message)

def validate_9digit_identifier(value: str) -> str:
    """Validate a 9-digit identifier."""
    return validate_identifier(value, length=9)

def validate_3or4digit_identifier(value: str) -> str:
    """Validate a 3 or 4-digit identifier."""
    return validate_identifier(value, length=(3, 4))

def validate_list(value: Any, item_validator: Callable[[Any], Any], 
                 min_length: int = 0, max_length: Optional[int] = None) -> List[Any]:
    if not isinstance(value, list):
        raise ValidationException("Value must be a list")
    if len(value) < min_length:
        raise ValidationException(f"List must have at least {min_length} items")
    if max_length is not None and len(value) > max_length:
        raise ValidationException(f"List can have at most {max_length} items")
    return [item_validator(item) for item in value]

def validate_dict(value: Any, key_validator: Callable[[Any], Any], 
                 value_validator: Callable[[Any], Any]) -> dict:
    if not isinstance(value, dict):
        raise ValidationException("Value must be a dictionary")
    return {key_validator(k): value_validator(v) for k, v in value.items()}
